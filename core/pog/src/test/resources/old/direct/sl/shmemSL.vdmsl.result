["type invariant satisfiable obligation:(exists mk_M(-, a, b):M \u0026 (b \u003e\u003d a))","type compatibility obligation:(forall m:M \u0026 ((((m.stop) - (m.start)) + 1) \u003e 0))","recursive function obligation:(forall size:nat1, Q:Quadrant \u0026 ((not ([] \u003d Q)) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((not (((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003e\u003d size))) \u003d\u003e (QuadrantLen(size, Q) \u003e QuadrantLen(size, tail)))))))","cases exhaustive obligation:(forall size:nat1, Q:Quadrant \u0026 ((Q \u003d []) or (exists [h] ^ tail:Quadrant \u0026 (Q \u003d ([h] ^ tail)))))","recursive function obligation:(forall size:nat1, Q:Quadrant \u0026 ((not ([] \u003d Q)) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003e\u003d size)) \u003d\u003e (QuadrantLen(size, Q) \u003e QuadrantLen(size, tail)))))))","recursive function obligation:(forall size:nat1, Q:Quadrant \u0026 ((not ([] \u003d Q)) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((not (((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003e\u003d size))) \u003d\u003e (QuadrantLen(size, Q) \u003e QuadrantLen(size, tail)))))))","cases exhaustive obligation:(forall size:nat1, Q:Quadrant \u0026 ((Q \u003d []) or (exists [h] ^ tail:Quadrant \u0026 (Q \u003d ([h] ^ tail)))))","type compatibility obligation:(forall size:nat1, hole:nat1, Q:Quadrant \u0026 ((hole \u003e\u003d size) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003d hole)) \u003d\u003e ((hole \u003d size) \u003d\u003e inv_M(mk_M(\u003cUSED\u003e, (h.start), (h.stop)))))))))","type compatibility obligation:(forall size:nat1, hole:nat1, Q:Quadrant \u0026 ((hole \u003e\u003d size) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003d hole)) \u003d\u003e ((not (hole \u003d size)) \u003d\u003e ((((h.start) + size) - 1) \u003e\u003d 0)))))))","type compatibility obligation:(forall size:nat1, hole:nat1, Q:Quadrant \u0026 ((hole \u003e\u003d size) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003d hole)) \u003d\u003e ((not (hole \u003d size)) \u003d\u003e (inv_M(mk_M(\u003cUSED\u003e, (h.start), (((h.start) + size) - 1))) and ((((h.start) + size) - 1) \u003e\u003d 0))))))))","type compatibility obligation:(forall size:nat1, hole:nat1, Q:Quadrant \u0026 ((hole \u003e\u003d size) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003d hole)) \u003d\u003e ((not (hole \u003d size)) \u003d\u003e inv_M(mk_M(\u003cFREE\u003e, ((h.start) + size), (h.stop)))))))))","legal function application obligation:(forall size:nat1, hole:nat1, Q:Quadrant \u0026 ((hole \u003e\u003d size) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((not (((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003d hole))) \u003d\u003e pre_add(size, hole, tail))))))","recursive function obligation:(forall size:nat1, hole:nat1, Q:Quadrant \u0026 ((hole \u003e\u003d size) \u003d\u003e (exists [h] ^ tail:Quadrant \u0026 ((([h] ^ tail) \u003d Q) \u003d\u003e let [h] ^ tail \u003d Q in ((not (((h.type) \u003d \u003cFREE\u003e) and (sizeof(h) \u003d hole))) \u003d\u003e (QuadrantLen2(size, hole, Q) \u003e QuadrantLen2(size, hole, tail)))))))","recursive function obligation:(forall Q:Quadrant \u0026 (exists [h1, h2] ^ tail:Quadrant \u0026 ((([h1, h2] ^ tail) \u003d Q) \u003d\u003e let [h1, h2] ^ tail \u003d Q in ((((h1.type) \u003d \u003cFREE\u003e) and ((h2.type) \u003d \u003cFREE\u003e)) \u003d\u003e (QuadrantLen0(Q) \u003e QuadrantLen0(([mk_M(\u003cFREE\u003e, (h1.start), (h2.stop))] ^ tail)))))))","type compatibility obligation:(forall Q:Quadrant \u0026 (exists [h1, h2] ^ tail:Quadrant \u0026 ((([h1, h2] ^ tail) \u003d Q) \u003d\u003e let [h1, h2] ^ tail \u003d Q in ((((h1.type) \u003d \u003cFREE\u003e) and ((h2.type) \u003d \u003cFREE\u003e)) \u003d\u003e inv_M(mk_M(\u003cFREE\u003e, (h1.start), (h2.stop)))))))","recursive function obligation:(forall Q:Quadrant \u0026 (exists [h1, h2] ^ tail:Quadrant \u0026 ((([h1, h2] ^ tail) \u003d Q) \u003d\u003e let [h1, h2] ^ tail \u003d Q in ((not (((h1.type) \u003d \u003cFREE\u003e) and ((h2.type) \u003d \u003cFREE\u003e))) \u003d\u003e (QuadrantLen0(Q) \u003e QuadrantLen0((tl Q)))))))","non-empty sequence obligation:(forall Q:Quadrant \u0026 (exists [h1, h2] ^ tail:Quadrant \u0026 ((([h1, h2] ^ tail) \u003d Q) \u003d\u003e let [h1, h2] ^ tail \u003d Q in ((not (((h1.type) \u003d \u003cFREE\u003e) and ((h2.type) \u003d \u003cFREE\u003e))) \u003d\u003e (Q \u003c\u003e [])))))","non-empty sequence obligation:(forall item:M, Q:Quadrant \u0026 (Q \u003c\u003e []))","type compatibility obligation:(forall item:M, Q:Quadrant \u0026 (((hd Q) \u003d item) \u003d\u003e inv_M(mk_M(\u003cFREE\u003e, (item.start), (item.stop)))))","non-empty sequence obligation:(forall item:M, Q:Quadrant \u0026 (((hd Q) \u003d item) \u003d\u003e (Q \u003c\u003e [])))","non-empty sequence obligation:(forall item:M, Q:Quadrant \u0026 ((not ((hd Q) \u003d item)) \u003d\u003e (Q \u003c\u003e [])))","recursive function obligation:(forall item:M, Q:Quadrant \u0026 ((not ((hd Q) \u003d item)) \u003d\u003e (MQuadrantLen(item, Q) \u003e MQuadrantLen(item, (tl Q)))))","non-empty sequence obligation:(forall item:M, Q:Quadrant \u0026 ((not ((hd Q) \u003d item)) \u003d\u003e (Q \u003c\u003e [])))","type compatibility obligation:(forall Q:Quadrant \u0026 (((card {x | x in set (elems Q) \u0026 ((x.type) \u003d \u003cFREE\u003e)}) - 1) \u003e\u003d 0))","state invariant holds obligation:(forall n:nat1, oldstate:Memory \u0026 let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))","state invariant holds obligation:let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0))","type compatibility obligation:((((rseed * 69069) + 5) mod 4294967296) \u003e\u003d 0)","type compatibility obligation:(forall n:nat1, oldstate:Memory \u0026 (true \u003d\u003e (RESULT \u003e 0)))","state invariant holds obligation:(forall size:nat1, oldstate:Memory \u0026 let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))","legal function application obligation:(forall size:nat1, oldstate:Memory \u0026 pre_add(size, q4, Q4))","state invariant holds obligation:(forall size:nat1, oldstate:Memory \u0026 let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))","legal function application obligation:(forall size:nat1, oldstate:Memory \u0026 pre_add(size, q3, Q3))","state invariant holds obligation:(forall size:nat1, oldstate:Memory \u0026 let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))","legal function application obligation:(forall size:nat1, oldstate:Memory \u0026 pre_add(size, q4, Q4))","state invariant holds obligation:(forall size:nat1, oldstate:Memory \u0026 let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))","legal function application obligation:(forall size:nat1, oldstate:Memory \u0026 pre_add(size, q3, Q3))","state invariant holds obligation:let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0))","type compatibility obligation:((MAXMEM - 1) \u003e\u003d 0)","type compatibility obligation:(inv_M(mk_M(\u003cFREE\u003e, 0, (MAXMEM - 1))) and ((MAXMEM - 1) \u003e\u003d 0))","state invariant holds obligation:let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0))","type compatibility obligation:((MAXMEM - 1) \u003e\u003d 0)","type compatibility obligation:(inv_M(mk_M(\u003cFREE\u003e, 0, (MAXMEM - 1))) and ((MAXMEM - 1) \u003e\u003d 0))","legal sequence application obligation:(((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e (i in set (inds Q3)))","state invariant holds obligation:(((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))","legal sequence application obligation:(((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e (i in set (inds Q3)))","operation call obligation:(((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e ((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))))","legal sequence application obligation:(((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e (true \u003d\u003e (i in set (inds Q4))))","state invariant holds obligation:(((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0))))","legal sequence application obligation:(((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e (true \u003d\u003e (i in set (inds Q4))))","operation call obligation:(((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))) \u003d\u003e (true \u003d\u003e ((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e)))))","while loop termination obligation:...","operation call obligation:(forall loops:nat, oldstate:Memory \u0026 ((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))))","state invariant holds obligation:(forall loops:nat, oldstate:Memory \u0026 (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0))))","while loop termination obligation:...","operation call obligation:(forall loops:nat, oldstate:Memory \u0026 ((exists m in set (elems Q3) \u0026 ((m.type) \u003d \u003cUSED\u003e)) or (exists m in set (elems Q4) \u0026 ((m.type) \u003d \u003cUSED\u003e))))","state invariant holds obligation:(forall loops:nat, oldstate:Memory \u0026 (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0))))","state invariant holds obligation:(forall tries:nat1, loops:nat1, oldstate:Memory \u0026 (true \u003d\u003e (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))))","state invariant holds obligation:(forall tries:nat1, loops:nat1, oldstate:Memory \u0026 (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))))))","state invariant holds obligation:(forall tries:nat1, loops:nat1, oldstate:Memory \u0026 (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))))))","state invariant holds obligation:(forall tries:nat1, loops:nat1, oldstate:Memory \u0026 (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))))))","state invariant holds obligation:(forall tries:nat1, loops:nat1, oldstate:Memory \u0026 (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e let mk_Memory(-, q3, q4) \u003d Memory in (((len q3) \u003e 0) and ((len q4) \u003e 0)))))))"]