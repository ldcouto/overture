["map compatible obligation:(forall lval:LVAL, bind:Model \u0026 (forall mk_(val, b) in set lval \u0026 ((forall id in set ((dom b) inter (dom bind)) \u0026 (b(id) \u003d bind(id))) \u003d\u003e (forall ldom1 in set (dom b), rdom2 in set (dom bind) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (b(ldom1) \u003d bind(rdom2)))))))","legal map application obligation:(forall lval:LVAL, bind:Model \u0026 (forall mk_(val, b) in set lval \u0026 (forall id in set ((dom b) inter (dom bind)) \u0026 (id in set (dom b)))))","legal map application obligation:(forall lval:LVAL, bind:Model \u0026 (forall mk_(val, b) in set lval \u0026 (forall id in set ((dom b) inter (dom bind)) \u0026 (id in set (dom bind)))))","function establishes postcondition obligation:(forall s:set of (VAL) \u0026 post_SetToSeq(s, (if (s \u003d {})\nthen []\nelse let e in set s in ([e] ^ SetToSeq((s \\ {e}))))))","let be st existence obligation:(forall s:set of (VAL) \u0026 ((not (s \u003d {})) \u003d\u003e (exists e in set s \u0026 true)))","legal sequence application obligation:(forall l:seq of (VAL) \u0026 ((not ([] \u003d l)) \u003d\u003e ((not (exists [-]:seq of (VAL) \u0026 ([any1] \u003d l))) \u003d\u003e (forall i in set (inds l) \u0026 (forall j in set Permute(RestSeq(l, i)) \u0026 (i in set (inds l)))))))","legal sequence application obligation:(forall l:seq of (VAL), i:nat1 \u0026 (forall j in set ((inds l) \\ {i}) \u0026 (j in set (inds l))))","cases exhaustive obligation:(forall pat:Pattern \u0026 ((((exists mk_PatternName(mk_(nm, pos)):Pattern \u0026 (pat \u003d mk_PatternName(mk_(nm, pos)))) or (exists mk_MatchVal(-):Pattern \u0026 (pat \u003d mk_MatchVal(any1)))) or (exists mk_SetEnumPattern(els):Pattern \u0026 (pat \u003d mk_SetEnumPattern(els)))) or (exists mk_SetUnionPattern(lp, rp):Pattern \u0026 (pat \u003d mk_SetUnionPattern(lp, rp)))))","map compatible obligation:(forall mk_LetBeSTExpr(lhs, st_e, in_e):LetBeSTExpr, oldstate:Sigma \u0026 (true \u003d\u003e (forall ldom1 in set (dom m2), rdom2 in set (dom m) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (m2(ldom1) \u003d m(rdom2))))))","while loop termination obligation:...","non-empty sequence obligation:(forall mk_CasesExpr(sel, altns, Others):CasesExpr, oldstate:Sigma \u0026 (alt_l \u003c\u003e []))","non-empty sequence obligation:(forall mk_CasesExpr(sel, altns, Others):CasesExpr, oldstate:Sigma \u0026 (true \u003d\u003e (true \u003d\u003e (alt_l \u003c\u003e []))))","operation call obligation:(forall mk_BinaryExpr(left_e, opr, right_e):BinaryExpr, oldstate:Sigma \u0026 (forall mk_(v, -) in set (l_lv union r_lv) \u0026 is_(v, SET)))","operation call obligation:(forall mk_BinaryExpr(left_e, opr, right_e):BinaryExpr, oldstate:Sigma \u0026 (true \u003d\u003e (true \u003d\u003e (forall mk_(v, -) in set (l_lv union r_lv) \u0026 is_(v, NUM)))))","map compatible obligation:(forall l_lv:LVAL, r_lv:LVAL, oldstate:Sigma \u0026 ((forall mk_(v, -) in set (l_lv union r_lv) \u0026 is_(v, SET)) \u003d\u003e (forall ldom1 in set (dom rm), rdom2 in set (dom lm) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (rm(ldom1) \u003d lm(rdom2))))))","map compatible obligation:(forall l_lv:LVAL, r_lv:LVAL, oldstate:Sigma \u0026 (forall ldom1 in set (dom rm), rdom2 in set (dom lm) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (rm(ldom1) \u003d lm(rdom2)))))","map compatible obligation:(forall l_lv:LVAL, opr:BinaryOp, r_lv:LVAL, oldstate:Sigma \u0026 ((forall mk_(v, -) in set (l_lv union r_lv) \u0026 is_(v, NUM)) \u003d\u003e (forall ldom1 in set (dom rm), rdom2 in set (dom lm) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (rm(ldom1) \u003d lm(rdom2))))))","map compatible obligation:(forall l_lv:LVAL, opr:BinaryOp, r_lv:LVAL, oldstate:Sigma \u0026 ((forall mk_(v, -) in set (l_lv union r_lv) \u0026 is_(v, NUM)) \u003d\u003e (forall ldom1 in set (dom rm), rdom2 in set (dom lm) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (rm(ldom1) \u003d lm(rdom2))))))","map compatible obligation:(forall l_lv:LVAL, opr:BinaryOp, r_lv:LVAL, oldstate:Sigma \u0026 ((forall mk_(v, -) in set (l_lv union r_lv) \u0026 is_(v, NUM)) \u003d\u003e (forall ldom1 in set (dom rm), rdom2 in set (dom lm) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (rm(ldom1) \u003d lm(rdom2))))))","legal sequence application obligation:(forall mk_SetEnumerationExpr(els):SetEnumerationExpr, oldstate:Sigma \u0026 (1 in set (inds els)))","legal sequence application obligation:(forall mk_SetEnumerationExpr(els):SetEnumerationExpr, oldstate:Sigma \u0026 (index in set (inds els)))","map compatible obligation:(forall mk_SetEnumerationExpr(els):SetEnumerationExpr, oldstate:Sigma \u0026 (forall mk_(s, m) in set sm_s, mk_(e, m2) in set elm_llv \u0026 ((forall id in set ((dom m) inter (dom m2)) \u0026 (m(id) \u003d m2(id))) \u003d\u003e (forall ldom1 in set (dom m), rdom2 in set (dom m2) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (m(ldom1) \u003d m2(rdom2)))))))","legal map application obligation:(forall mk_SetEnumerationExpr(els):SetEnumerationExpr, oldstate:Sigma \u0026 (forall mk_(s, m) in set sm_s, mk_(e, m2) in set elm_llv \u0026 (forall id in set ((dom m) inter (dom m2)) \u0026 (id in set (dom m)))))","legal map application obligation:(forall mk_SetEnumerationExpr(els):SetEnumerationExpr, oldstate:Sigma \u0026 (forall mk_(s, m) in set sm_s, mk_(e, m2) in set elm_llv \u0026 (forall id in set ((dom m) inter (dom m2)) \u0026 (id in set (dom m2)))))","operation call obligation:(forall mk_ApplyExpr(fct_e, arg_e):ApplyExpr, oldstate:Sigma \u0026 (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (curfn \u003c\u003e []))))))","type compatibility obligation:(forall lit:Literal, oldstate:Sigma \u0026 ((not is_(lit, NumLit)) \u003d\u003e is_((lit.val), bool)))","value binding obligation:(forall pat_p:Pattern, val_v:VAL, oldstate:Sigma \u0026 (exists mk_PatternName(id):Pattern \u0026 (mk_PatternName(id) \u003d pat_p)))","type compatibility obligation:(forall pat_p:Pattern, val_v:VAL, oldstate:Sigma \u0026 is_(pat_p, PatternName))","legal sequence application obligation:(forall els_lp:seq of (Pattern), val_lv:seq of (VAL), oldstate:Sigma \u0026 (forall i in set (inds els_lp) \u0026 (i in set (inds els_lp))))","legal sequence application obligation:(forall els_lp:seq of (Pattern), val_lv:seq of (VAL), oldstate:Sigma \u0026 (forall i in set (inds els_lp) \u0026 (i in set (inds val_lv))))","while loop termination obligation:...","non-empty sequence obligation:(forall blk_l:BlkEnv, oldstate:Sigma \u0026 (tmpblk_l \u003c\u003e []))","non-empty sequence obligation:(forall blk_l:BlkEnv, oldstate:Sigma \u0026 (tmpblk_l \u003c\u003e []))","non-empty sequence obligation:(forall blk_l:BlkEnv, oldstate:Sigma \u0026 (tmpblk_l \u003c\u003e []))","type compatibility obligation:(forall mk_SetBind(pat_p, set_e):SetBind, oldstate:Sigma \u0026 is_(RESULT, set of ((BlkEnv * Model))))","comprehension map injectivity obligation:(forall val_l:seq of (ValueDef), oldstate:Sigma \u0026 (forall m1, m2 in set {{id |-\u003e {mk_(Look(env, id), model) | env in set env_s}} | id in set (dinter {SelDom(env) | env in set env_s})} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal function application obligation:(forall val_l:seq of (ValueDef), oldstate:Sigma \u0026 (forall id in set (dinter {SelDom(env) | env in set env_s}) \u0026 (forall env in set env_s \u0026 pre_Look(env, id))))","non-empty set obligation:(forall val_l:seq of (ValueDef), oldstate:Sigma \u0026 ({SelDom(env) | env in set env_s} \u003c\u003e {}))","comprehension map injectivity obligation:(forall fn_marg:map (Name) to (ExplFnDef), oldstate:Sigma \u0026 (forall m1, m2 in set {{nm |-\u003e mk_((fn_marg(nm).pat), (fn_marg(nm).body))} | nm in set (dom fn_marg)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal map application obligation:(forall fn_marg:map (Name) to (ExplFnDef), oldstate:Sigma \u0026 (forall nm in set (dom fn_marg) \u0026 (nm in set (dom fn_marg))))","legal map application obligation:(forall fn_marg:map (Name) to (ExplFnDef), oldstate:Sigma \u0026 (forall nm in set (dom fn_marg) \u0026 (nm in set (dom fn_marg))))","non-empty sequence obligation:((curfn \u003c\u003e []) \u003d\u003e (curfn \u003c\u003e []))","non-empty sequence obligation:(env_l \u003c\u003e [])","non-empty sequence obligation:(env_l \u003c\u003e [])","non-empty sequence obligation:(env_l \u003c\u003e [])","non-empty sequence obligation:((hd env_l) \u003c\u003e [])","non-empty sequence obligation:(env_l \u003c\u003e [])","non-empty sequence obligation:(forall benv:BlkEnv, oldstate:Sigma \u0026 (env_l \u003c\u003e []))","non-empty sequence obligation:(forall benv:BlkEnv, oldstate:Sigma \u0026 (env_l \u003c\u003e []))","non-empty sequence obligation:(curfn \u003c\u003e [])","map compatible obligation:(forall nm:Name, oldstate:Sigma \u0026 (forall mk_(v, m) in set val_m(id) \u0026 (forall ldom1 in set (dom m), rdom2 in set (dom {id |-\u003e v}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (m(ldom1) \u003d {id |-\u003e v}(rdom2))))))","legal map application obligation:(forall nm:Name, oldstate:Sigma \u0026 (id in set (dom val_m)))","type compatibility obligation:(forall nm:Name, oldstate:Sigma \u0026 is_(RESULT, set of ((VAL * Model))))","legal map application obligation:(forall nm:Name, oldstate:Sigma \u0026 ((nm in set (dom fn_m)) \u003d\u003e (nm in set (dom fn_m))))","non-empty sequence obligation:(forall env:BlkEnv, id:UniqueId \u0026 ((exists mk_(nm, -) in set (elems env) \u0026 (nm \u003d id)) \u003d\u003e ((not (env \u003d [])) \u003d\u003e (env \u003c\u003e []))))","legal function application obligation:(forall env:BlkEnv, id:UniqueId \u0026 ((exists mk_(nm, -) in set (elems env) \u0026 (nm \u003d id)) \u003d\u003e ((not (env \u003d [])) \u003d\u003e let mk_(nm, val):NameVal \u003d (hd env) in ((not (nm \u003d id)) \u003d\u003e pre_Look((tl env), id)))))","non-empty sequence obligation:(forall env:BlkEnv, id:UniqueId \u0026 ((exists mk_(nm, -) in set (elems env) \u0026 (nm \u003d id)) \u003d\u003e ((not (env \u003d [])) \u003d\u003e let mk_(nm, val):NameVal \u003d (hd env) in ((not (nm \u003d id)) \u003d\u003e (env \u003c\u003e [])))))","comprehension map injectivity obligation:(forall val_m:map (UniqueId) to (LVAL), upd_m:map (UniqueId) to (LVAL) \u0026 (forall m1, m2 in set {{id |-\u003e (if (id in set (dom val_m))\nthen (val_m(id) union upd_m(id))\nelse upd_m(id))} | id in set (dom upd_m)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal map application obligation:(forall val_m:map (UniqueId) to (LVAL), upd_m:map (UniqueId) to (LVAL) \u0026 (forall id in set (dom upd_m) \u0026 ((id in set (dom val_m)) \u003d\u003e (id in set (dom val_m)))))","legal map application obligation:(forall val_m:map (UniqueId) to (LVAL), upd_m:map (UniqueId) to (LVAL) \u0026 (forall id in set (dom upd_m) \u0026 ((id in set (dom val_m)) \u003d\u003e (id in set (dom upd_m)))))","legal map application obligation:(forall val_m:map (UniqueId) to (LVAL), upd_m:map (UniqueId) to (LVAL) \u0026 (forall id in set (dom upd_m) \u0026 ((not (id in set (dom val_m))) \u003d\u003e (id in set (dom upd_m)))))"]