["enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cAdam\u003e |-\u003e 1}, {\u003cBill\u003e |-\u003e 2}, {\u003cCharlie\u003e |-\u003e 3}, {\u003cFrank\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cBill\u003e |-\u003e 1}, {\u003cAdam\u003e |-\u003e 2}, {\u003cCharlie\u003e |-\u003e 3}, {\u003cGeorge\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cAdam\u003e |-\u003e 1}, {\u003cCharlie\u003e |-\u003e 2}, {\u003cBill\u003e |-\u003e 3}, {\u003cHarry\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cBill\u003e |-\u003e 1}, {\u003cCharlie\u003e |-\u003e 2}, {\u003cAdam\u003e |-\u003e 3}, {\u003cIan\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cCharlie\u003e |-\u003e 1}, {\u003cAdam\u003e |-\u003e 2}, {\u003cBill\u003e |-\u003e 3}, {\u003cJohn\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cCharlie\u003e |-\u003e 1}, {\u003cBill\u003e |-\u003e 2}, {\u003cAdam\u003e |-\u003e 3}, {\u003cDonald\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cDonald\u003e |-\u003e 1}, {\u003cAdam\u003e |-\u003e 2}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cFrank\u003e |-\u003e 1}, {\u003cBill\u003e |-\u003e 2}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cGeorge\u003e |-\u003e 1}, {\u003cCharlie\u003e |-\u003e 2}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cHarry\u003e |-\u003e 1}, {\u003cBill\u003e |-\u003e 2}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cIan\u003e |-\u003e 1}, {\u003cAdam\u003e |-\u003e 2}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cJohn\u003e |-\u003e 1}, {\u003cCharlie\u003e |-\u003e 2}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{{\u003cAdam\u003e |-\u003e 1, \u003cBill\u003e |-\u003e 2, \u003cCharlie\u003e |-\u003e 3, \u003cFrank\u003e |-\u003e 4} |-\u003e 100000}, {{\u003cBill\u003e |-\u003e 1, \u003cAdam\u003e |-\u003e 2, \u003cCharlie\u003e |-\u003e 3, \u003cGeorge\u003e |-\u003e 4} |-\u003e 100000}, {{\u003cAdam\u003e |-\u003e 1, \u003cCharlie\u003e |-\u003e 2, \u003cBill\u003e |-\u003e 3, \u003cHarry\u003e |-\u003e 4} |-\u003e 100000}, {{\u003cBill\u003e |-\u003e 1, \u003cCharlie\u003e |-\u003e 2, \u003cAdam\u003e |-\u003e 3, \u003cIan\u003e |-\u003e 4} |-\u003e 100000}, {{\u003cCharlie\u003e |-\u003e 1, \u003cAdam\u003e |-\u003e 2, \u003cBill\u003e |-\u003e 3, \u003cJohn\u003e |-\u003e 4} |-\u003e 100000}, {{\u003cCharlie\u003e |-\u003e 1, \u003cBill\u003e |-\u003e 2, \u003cAdam\u003e |-\u003e 3, \u003cDonald\u003e |-\u003e 4} |-\u003e 100000}, {{\u003cDonald\u003e |-\u003e 1, \u003cAdam\u003e |-\u003e 2} |-\u003e 1000}, {{\u003cFrank\u003e |-\u003e 1, \u003cBill\u003e |-\u003e 2} |-\u003e 1000}, {{\u003cGeorge\u003e |-\u003e 1, \u003cCharlie\u003e |-\u003e 2} |-\u003e 1000}, {{\u003cHarry\u003e |-\u003e 1, \u003cBill\u003e |-\u003e 2} |-\u003e 1000}, {{\u003cIan\u003e |-\u003e 1, \u003cAdam\u003e |-\u003e 2} |-\u003e 1000}, {{\u003cJohn\u003e |-\u003e 1, \u003cCharlie\u003e |-\u003e 2} |-\u003e 1000}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal map application obligation:(forall v:map (Candidate_names) to (nat1) \u0026 (forall name:Candidate_names \u0026 (name in set (dom v))))","type invariant satisfiable obligation:(exists v:Voting_paper \u0026 (exists1 name:Candidate_names \u0026 (v(name) \u003d 1)))","legal sequence application obligation:(forall s:seq of (Score) \u0026 (forall i in set (inds s), j in set (inds s) \u0026 ((i \u003c j) \u003d\u003e (i in set (inds s)))))","legal sequence application obligation:(forall s:seq of (Score) \u0026 (forall i in set (inds s), j in set (inds s) \u0026 ((i \u003c j) \u003d\u003e (j in set (inds s)))))","legal sequence application obligation:(forall s:seq of (Score) \u0026 (forall i in set (inds s), j in set (inds s) \u0026 ((i \u003c j) \u003d\u003e ((((s(i).count) \u003e\u003d (s(j).count)) and (i \u003c\u003e j)) \u003d\u003e (i in set (inds s))))))","legal sequence application obligation:(forall s:seq of (Score) \u0026 (forall i in set (inds s), j in set (inds s) \u0026 ((i \u003c j) \u003d\u003e ((((s(i).count) \u003e\u003d (s(j).count)) and (i \u003c\u003e j)) \u003d\u003e (j in set (inds s))))))","type invariant satisfiable obligation:(exists s:Stage \u0026 (forall i in set (inds s), j in set (inds s) \u0026 ((i \u003c j) \u003d\u003e ((((s(i).count) \u003e\u003d (s(j).count)) and (i \u003c\u003e j)) \u003d\u003e ((s(i).name) \u003c\u003e (s(j).name))))))","type invariant satisfiable obligation:(exists v:Value \u0026 (v \u003e\u003d 0))","type invariant satisfiable obligation:(exists candidate:Candidate \u0026 ((forall ov in set (dom (candidate.original_votes)) \u0026 (((ov :\u003e {1}) \u003d {(candidate.name) |-\u003e 1}) and (({(candidate.name)} \u003c: ov) \u003d {(candidate.name) |-\u003e 1}))) and (forall sub_parcel in set (elems (candidate.transferred_votes)) \u0026 (forall tv in set (dom (sub_parcel.votes)) \u0026 ((candidate.name) in set (dom tv))))))","let be st existence obligation:(forall s:set of ((nat * Parcel)) \u0026 ((not (s \u003d {})) \u003d\u003e (exists mk_(m, pa) in set s \u0026 true)))","type compatibility obligation:(forall votes:Parcel, names:set of (Candidate_names) \u0026 (forall name in set names \u0026 inv_Candidate(mk_Candidate(name, vote_res(votes, {v | v in set (dom votes) \u0026 ((v :\u003e {1}) \u003d {name |-\u003e 1})}), []))))","legal sequence application obligation:(forall s:seq of (Score) \u0026 ((s \u003c\u003e []) \u003d\u003e ((len s) in set (inds s))))","legal function application obligation:(forall quota:real, stage:Stage \u0026 (((len stage) \u003e 1) \u003d\u003e pre_stage_bk(stage)))","legal sequence application obligation:(forall quota:real, stage:Stage \u0026 (((len stage) \u003e 1) \u003d\u003e (((len stage) - 1) in set (inds stage))))","legal sequence application obligation:(forall quota:real, stage:Stage \u0026 (((len stage) \u003e 1) \u003d\u003e let lowest_value:real \u003d (stage_bk(stage).count), second_lowest_value:real \u003d (stage(((len stage) - 1)).count) in (forall i in set (inds stage) \u0026 (((stage(i).count) \u003e quota) \u003d\u003e (i in set (inds stage))))))","legal sequence application obligation:(forall quota:real, stage:Stage \u0026 (((len stage) \u003e 1) \u003d\u003e let lowest_value:real \u003d (stage_bk(stage).count), second_lowest_value:real \u003d (stage(((len stage) - 1)).count) in (forall i in set (inds stage) \u0026 (i in set (inds stage)))))","non-empty sequence obligation:(forall s:seq of (real) \u0026 ((not (s \u003d [])) \u003d\u003e (s \u003c\u003e [])))","non-empty sequence obligation:(forall s:seq of (real) \u0026 ((not (s \u003d [])) \u003d\u003e (s \u003c\u003e [])))","unique existence binding obligation:(forall stage:Stage, name:Candidate_names, leaders:set of (Candidate_names) \u0026 (exists1 c in set (elems stage) \u0026 ((c.name) \u003d name)))","non-empty sequence obligation:(forall name:Candidate_names, all_stages:seq of (Stage) \u0026 (all_stages \u003c\u003e []))","non-empty sequence obligation:(forall name:Candidate_names, all_stages:seq of (Stage) \u0026 (forall score in set (elems (hd all_stages)) \u0026 (all_stages \u003c\u003e [])))","non-empty sequence obligation:(forall name:Candidate_names, all_stages:seq of (Stage) \u0026 (forall score in set (elems (hd all_stages)) \u0026 ((hd all_stages) \u003c\u003e [])))","legal sequence application obligation:(forall name:Candidate_names, all_stages:seq of (Stage) \u0026 let leaders:set of (Candidate_names) \u003d {(score.name) | score in set (elems (hd all_stages)) \u0026 ((score.count) \u003d ((hd (hd all_stages)).count))} in (forall i in set (inds all_stages) \u0026 (i in set (inds all_stages))))","legal sequence application obligation:(forall name:Candidate_names, all_stages:seq of (Stage) \u0026 let leaders:set of (Candidate_names) \u003d {(score.name) | score in set (elems (hd all_stages)) \u0026 ((score.count) \u003d ((hd (hd all_stages)).count))} in (forall i in set (inds all_stages) \u0026 (sole_leader(all_stages(i), name, leaders) \u003d\u003e (forall j in set {(i + 1), ... ,(len all_stages)}, other_leader in set leaders \u0026 (j in set (inds all_stages))))))","comprehension map injectivity obligation:(forall val:Value, parcel:Parcel, discontinuing:Candidate, continuing_candidates:set of (Candidate) \u0026 let names:set of (Candidate_names) \u003d {(candidate.name) | candidate in set continuing_candidates} in (forall m1, m2 in set {{n |-\u003e mk_Sub_parcel({v |-\u003e parcel(v) | v in set (dom parcel) \u0026 next_preference(n, v, names)}, val)} | n in set names} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","comprehension map injectivity obligation:(forall val:Value, parcel:Parcel, discontinuing:Candidate, continuing_candidates:set of (Candidate) \u0026 let names:set of (Candidate_names) \u003d {(candidate.name) | candidate in set continuing_candidates} in (forall n in set names \u0026 (forall m1, m2 in set {{v |-\u003e parcel(v)} | v in set (dom parcel) \u0026 next_preference(n, v, names)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))))","legal map application obligation:(forall val:Value, parcel:Parcel, discontinuing:Candidate, continuing_candidates:set of (Candidate) \u0026 let names:set of (Candidate_names) \u003d {(candidate.name) | candidate in set continuing_candidates} in (forall n in set names \u0026 (forall v in set (dom parcel) \u0026 (next_preference(n, v, names) \u003d\u003e (v in set (dom parcel))))))","comprehension map injectivity obligation:(forall val:Value, parcel:Parcel, discontinuing:Candidate, continuing_candidates:set of (Candidate) \u0026 let names:set of (Candidate_names) \u003d {(candidate.name) | candidate in set continuing_candidates} in let sub_parcel_map:map (Candidate_names) to (Sub_parcel) \u003d {n |-\u003e mk_Sub_parcel({v |-\u003e parcel(v) | v in set (dom parcel) \u0026 next_preference(n, v, names)}, val) | n in set names} in (forall m1, m2 in set {{n |-\u003e sub_parcel_map(n)} | n in set (dom sub_parcel_map) \u0026 ((sub_parcel_map(n).votes) \u003c\u003e {|-\u003e})} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal map application obligation:(forall val:Value, parcel:Parcel, discontinuing:Candidate, continuing_candidates:set of (Candidate) \u0026 let names:set of (Candidate_names) \u003d {(candidate.name) | candidate in set continuing_candidates} in let sub_parcel_map:map (Candidate_names) to (Sub_parcel) \u003d {n |-\u003e mk_Sub_parcel({v |-\u003e parcel(v) | v in set (dom parcel) \u0026 next_preference(n, v, names)}, val) | n in set names} in (forall n in set (dom sub_parcel_map) \u0026 (((sub_parcel_map(n).votes) \u003c\u003e {|-\u003e}) \u003d\u003e (n in set (dom sub_parcel_map)))))","legal map application obligation:(forall val:Value, parcel:Parcel, discontinuing:Candidate, continuing_candidates:set of (Candidate) \u0026 let names:set of (Candidate_names) \u003d {(candidate.name) | candidate in set continuing_candidates} in let sub_parcel_map:map (Candidate_names) to (Sub_parcel) \u003d {n |-\u003e mk_Sub_parcel({v |-\u003e parcel(v) | v in set (dom parcel) \u0026 next_preference(n, v, names)}, val) | n in set names} in (forall n in set (dom sub_parcel_map) \u0026 (n in set (dom sub_parcel_map))))","type compatibility obligation:(forall val:Value, parcel:Parcel, discontinuing:Candidate, continuing_candidates:set of (Candidate) \u0026 let names:set of (Candidate_names) \u003d {(candidate.name) | candidate in set continuing_candidates} in let sub_parcel_map:map (Candidate_names) to (Sub_parcel) \u003d {n |-\u003e mk_Sub_parcel({v |-\u003e parcel(v) | v in set (dom parcel) \u0026 next_preference(n, v, names)}, val) | n in set names} in let non_empty_sub_parcel_map:map (Candidate_names) to (Sub_parcel) \u003d {n |-\u003e sub_parcel_map(n) | n in set (dom sub_parcel_map) \u0026 ((sub_parcel_map(n).votes) \u003c\u003e {|-\u003e})} in inv_Value(1.0))","legal map application obligation:(forall name:Candidate_names, vote:Voting_paper, continuing:set of (Candidate_names) \u0026 ((name in set (dom vote)) \u003d\u003e (forall i in set (rng vote) \u0026 (name in set (dom vote)))))","type compatibility obligation:(forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 inv_Value(1.0))","type compatibility obligation:(forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 let new_sub_parcels:Sub_parcel_bundle \u003d construct_sub_parcels(1.0, old_votes, disc, cont_cands) in let total_no_of_trans_votes:int \u003d (size(old_votes) - size(((new_sub_parcels.non_transferable).votes))) in let total_val_trans_votes:real \u003d (total_no_of_trans_votes * old_value) in inv_Value(total_val_trans_votes))","type compatibility obligation:(forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 let new_sub_parcels:Sub_parcel_bundle \u003d construct_sub_parcels(1.0, old_votes, disc, cont_cands) in let total_no_of_trans_votes:int \u003d (size(old_votes) - size(((new_sub_parcels.non_transferable).votes))) in let total_val_trans_votes:real \u003d (total_no_of_trans_votes * old_value) in (total_no_of_trans_votes \u003e\u003d 0))","comprehension map injectivity obligation:(forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 let new_sub_parcels:Sub_parcel_bundle \u003d construct_sub_parcels(1.0, old_votes, disc, cont_cands) in let total_no_of_trans_votes:int \u003d (size(old_votes) - size(((new_sub_parcels.non_transferable).votes))) in let total_val_trans_votes:real \u003d (total_no_of_trans_votes * old_value) in let transf_val:Value \u003d calc_transf_value(surplus, total_val_trans_votes, old_value, total_no_of_trans_votes) in (forall m1, m2 in set {{n |-\u003e mk_Sub_parcel(((new_sub_parcels.sub_parcels)(n).votes), transf_val)} | n in set (dom (new_sub_parcels.sub_parcels))} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal map application obligation:(forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 let new_sub_parcels:Sub_parcel_bundle \u003d construct_sub_parcels(1.0, old_votes, disc, cont_cands) in let total_no_of_trans_votes:int \u003d (size(old_votes) - size(((new_sub_parcels.non_transferable).votes))) in let total_val_trans_votes:real \u003d (total_no_of_trans_votes * old_value) in let transf_val:Value \u003d calc_transf_value(surplus, total_val_trans_votes, old_value, total_no_of_trans_votes) in (forall n in set (dom (new_sub_parcels.sub_parcels)) \u0026 (n in set (dom (new_sub_parcels.sub_parcels)))))","type compatibility obligation:(forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 let new_sub_parcels:Sub_parcel_bundle \u003d construct_sub_parcels(1.0, old_votes, disc, cont_cands) in let total_no_of_trans_votes:int \u003d (size(old_votes) - size(((new_sub_parcels.non_transferable).votes))) in let total_val_trans_votes:real \u003d (total_no_of_trans_votes * old_value) in let transf_val:Value \u003d calc_transf_value(surplus, total_val_trans_votes, old_value, total_no_of_trans_votes) in inv_Value(total_val_trans_votes))","type compatibility obligation:(forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 let new_sub_parcels:Sub_parcel_bundle \u003d construct_sub_parcels(1.0, old_votes, disc, cont_cands) in let total_no_of_trans_votes:int \u003d (size(old_votes) - size(((new_sub_parcels.non_transferable).votes))) in let total_val_trans_votes:real \u003d (total_no_of_trans_votes * old_value) in let transf_val:Value \u003d calc_transf_value(surplus, total_val_trans_votes, old_value, total_no_of_trans_votes) in (total_no_of_trans_votes \u003e\u003d 0))","type compatibility obligation:(forall surplus:real, old_value:Value, old_votes:Parcel, disc:Candidate, cont_cands:set of (Candidate) \u0026 let new_sub_parcels:Sub_parcel_bundle \u003d construct_sub_parcels(1.0, old_votes, disc, cont_cands) in let total_no_of_trans_votes:int \u003d (size(old_votes) - size(((new_sub_parcels.non_transferable).votes))) in let total_val_trans_votes:real \u003d (total_no_of_trans_votes * old_value) in let transf_val:Value \u003d calc_transf_value(surplus, total_val_trans_votes, old_value, total_no_of_trans_votes) in inv_Value(total_val_trans_votes))","non-zero obligation:(forall surplus:real, total_value:Value, old_value:Value, total_no:nat \u0026 ((surplus \u003c total_value) \u003d\u003e (total_no \u003c\u003e 0)))","type compatibility obligation:(forall surplus:real, total_value:Value, old_value:Value, total_no:nat \u0026 inv_Value((if (surplus \u003c total_value)\nthen ((floor ((100 * surplus) / total_no)) / 100)\nelse old_value)))","non-zero obligation:(forall surplus:real, total_value:Value, total_number:nat, old_value:Value \u0026 ((surplus \u003c total_value) \u003d\u003e (total_number \u003c\u003e 0)))","non-zero obligation:(forall surplus:real, total_value:Value, total_number:nat, old_value:Value \u0026 ((surplus \u003c total_value) \u003d\u003e (total_value \u003c\u003e 0)))","type compatibility obligation:(forall surplus:real, total_value:Value \u0026 inv_Value((if (surplus \u003e total_value)\nthen (surplus - total_value)\nelse 0)))","legal map application obligation:(forall previous_collection:Candset, bundle:Sub_parcel_bundle \u0026 (((dom (bundle.sub_parcels)) subset {(candidate.name) | candidate in set previous_collection}) \u003d\u003e (forall candidate in set previous_collection, n in set (dom (bundle.sub_parcels)) \u0026 (((candidate.name) \u003d n) \u003d\u003e (n in set (dom (bundle.sub_parcels)))))))","let be st existence obligation:(forall sta:Stage \u0026 ((not ([] \u003d sta)) \u003d\u003e ((not (exists [e]:Stage \u0026 ([e] \u003d sta))) \u003d\u003e (exists sta1 ^ sta2 in set {sta} \u0026 ((abs ((len sta1) - (len sta2))) \u003c 2)))))","non-empty sequence obligation:(forall sta1:Stage, sta2:Stage \u0026 ((not (exists mk_([], sta):(Stage * Stage) \u0026 (mk_([], sta) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (exists mk_(sta, []):(Stage * Stage) \u0026 (mk_(sta, []) \u003d mk_(sta1, sta2)))) \u003d\u003e (sta1 \u003c\u003e []))))","non-empty sequence obligation:(forall sta1:Stage, sta2:Stage \u0026 ((not (exists mk_([], sta):(Stage * Stage) \u0026 (mk_([], sta) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (exists mk_(sta, []):(Stage * Stage) \u0026 (mk_(sta, []) \u003d mk_(sta1, sta2)))) \u003d\u003e (sta2 \u003c\u003e []))))","non-empty sequence obligation:(forall sta1:Stage, sta2:Stage \u0026 ((not (exists mk_([], sta):(Stage * Stage) \u0026 (mk_([], sta) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (exists mk_(sta, []):(Stage * Stage) \u0026 (mk_(sta, []) \u003d mk_(sta1, sta2)))) \u003d\u003e ((((hd sta1).count) \u003e\u003d ((hd sta2).count)) \u003d\u003e (sta1 \u003c\u003e [])))))","non-empty sequence obligation:(forall sta1:Stage, sta2:Stage \u0026 ((not (exists mk_([], sta):(Stage * Stage) \u0026 (mk_([], sta) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (exists mk_(sta, []):(Stage * Stage) \u0026 (mk_(sta, []) \u003d mk_(sta1, sta2)))) \u003d\u003e ((((hd sta1).count) \u003e\u003d ((hd sta2).count)) \u003d\u003e (sta1 \u003c\u003e [])))))","non-empty sequence obligation:(forall sta1:Stage, sta2:Stage \u0026 ((not (exists mk_([], sta):(Stage * Stage) \u0026 (mk_([], sta) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (exists mk_(sta, []):(Stage * Stage) \u0026 (mk_(sta, []) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (((hd sta1).count) \u003e\u003d ((hd sta2).count))) \u003d\u003e (sta2 \u003c\u003e [])))))","non-empty sequence obligation:(forall sta1:Stage, sta2:Stage \u0026 ((not (exists mk_([], sta):(Stage * Stage) \u0026 (mk_([], sta) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (exists mk_(sta, []):(Stage * Stage) \u0026 (mk_(sta, []) \u003d mk_(sta1, sta2)))) \u003d\u003e ((not (((hd sta1).count) \u003e\u003d ((hd sta2).count))) \u003d\u003e (sta2 \u003c\u003e [])))))","type compatibility obligation:(forall sta1:Stage, sta2:Stage \u0026 inv_Stage((cases mk_(sta1, sta2) :\nmk_([], sta) -\u003e sta,\nmk_(sta, []) -\u003e sta\nothers (if (((hd sta1).count) \u003e\u003d ((hd sta2).count))\nthen ([(hd sta1)] ^ score_merge((tl sta1), sta2))\nelse ([(hd sta2)] ^ score_merge(sta1, (tl sta2))))\n end)))","let be st existence obligation:(forall s:set of (Score) \u0026 ((not (s \u003d {})) \u003d\u003e (exists e in set s \u0026 true)))","type compatibility obligation:(forall s:set of (Score) \u0026 inv_Stage((if (s \u003d {})\nthen []\nelse let e in set s in ([e] ^ set_seq((s \\ {e}))))))","legal map application obligation:(forall old_stage:Stage, discontinuing:Candidate_names, bundle:Sub_parcel_bundle \u0026 let cands_with_more_votes:set of (Candidate_names) \u003d (dom (bundle.sub_parcels)) in (forall mk_Score(name, old_count) in set (elems old_stage) \u0026 ((name in set cands_with_more_votes) \u003d\u003e (name in set (dom (bundle.sub_parcels))))))","legal map application obligation:(forall old_stage:Stage, discontinuing:Candidate_names, bundle:Sub_parcel_bundle \u0026 let cands_with_more_votes:set of (Candidate_names) \u003d (dom (bundle.sub_parcels)) in (forall mk_Score(name, old_count) in set (elems old_stage) \u0026 ((name in set cands_with_more_votes) \u003d\u003e (name in set (dom (bundle.sub_parcels))))))","non-empty sequence obligation:(forall stages:seq of (Stage), quota:real \u0026 (stages \u003c\u003e []))","non-empty sequence obligation:(forall stages:seq of (Stage), quota:real \u0026 ((hd stages) \u003c\u003e []))","legal function application obligation:(forall stages:seq of (Stage), quota:real \u0026 ((((hd (hd stages)).count) \u003e\u003d quota) \u003d\u003e pre_defer_transfer_of_surplus(quota, (hd stages))))","non-empty sequence obligation:(forall stages:seq of (Stage), quota:real \u0026 ((((hd (hd stages)).count) \u003e\u003d quota) \u003d\u003e (stages \u003c\u003e [])))","legal function application obligation:(forall name:Candidate_names, all_stages:seq1 of (Stage) \u0026 pre_stage_bk((hd all_stages)))","legal sequence application obligation:(forall name:Candidate_names, all_stages:seq1 of (Stage) \u0026 let trailing_count:real \u003d (stage_bk((hd all_stages)).count) in let lowest:set of (Candidate_names) \u003d {(score.name) | score in set (elems (hd all_stages)) \u0026 ((score.count) \u003d trailing_count)} in (forall i in set (inds all_stages) \u0026 (i in set (inds all_stages))))","legal sequence application obligation:(forall name:Candidate_names, all_stages:seq1 of (Stage) \u0026 let trailing_count:real \u003d (stage_bk((hd all_stages)).count) in let lowest:set of (Candidate_names) \u003d {(score.name) | score in set (elems (hd all_stages)) \u0026 ((score.count) \u003d trailing_count)} in (forall i in set (inds all_stages) \u0026 (sole_trailer(all_stages(i), name, lowest) \u003d\u003e (forall j in set {(i + 1), ... ,(len all_stages)}, other in set lowest \u0026 (j in set (inds all_stages))))))","unique existence binding obligation:(forall stage:Stage, name:Candidate_names, lowest:set of (Candidate_names) \u0026 (exists1 c in set (elems stage) \u0026 ((c.name) \u003d name)))","type compatibility obligation:(forall cands:set of (Candidate_names) \u0026 ((Number_of_vacancies - (card cands)) \u003e\u003d 0))","non-empty sequence obligation:(forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 (stages \u003c\u003e []))","legal map application obligation:(forall paper:Voting_paper, discontinuing:Candidate_names, continuing_names:set of (Candidate_names) \u0026 ((not (((dom (paper :-\u003e {1})) inter continuing_names) \u003d {})) \u003d\u003e (discontinuing in set (dom paper))))","legal function application obligation:(forall paper:Voting_paper, discontinuing:Candidate_names, continuing_names:set of (Candidate_names) \u0026 ((not (((dom (paper :-\u003e {1})) inter continuing_names) \u003d {})) \u003d\u003e let s:set of (nat1) \u003d (rng (paper :-\u003e {1, ... ,paper(discontinuing)})) in ((not (s \u003d {})) \u003d\u003e pre_min(s))))","let be st existence obligation:(forall s:set of (real) \u0026 ((s \u003c\u003e {}) \u003d\u003e (exists m in set s \u0026 true)))","legal function application obligation:(forall s:set of (real) \u0026 ((s \u003c\u003e {}) \u003d\u003e (forall m in set s \u0026 ((not ((card s) \u003d 1)) \u003d\u003e pre_min((s \\ {m}))))))","legal sequence application obligation:(forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 ((((hd stages)(i).name) in set continuing_names) \u003d\u003e (i in set (inds (hd stages))))))","non-empty sequence obligation:(forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 ((((hd stages)(i).name) in set continuing_names) \u003d\u003e (stages \u003c\u003e []))))","non-empty sequence obligation:(forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (stages \u003c\u003e []))","legal sequence application obligation:(forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 (i in set (inds (hd stages)))))","non-empty sequence obligation:(forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 (stages \u003c\u003e [])))","legal sequence application obligation:(forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 ((((hd stages)(i).count) \u003e quota) \u003d\u003e (i in set (inds (hd stages))))))","non-empty sequence obligation:(forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 ((((hd stages)(i).count) \u003e quota) \u003d\u003e (stages \u003c\u003e []))))","non-empty sequence obligation:(forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (stages \u003c\u003e []))","legal sequence application obligation:(forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 (i in set (inds (hd stages)))))","non-empty sequence obligation:(forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in (forall i in set (inds (hd stages)) \u0026 (stages \u003c\u003e [])))","legal sequence application obligation:(forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in let continuing_scores:seq of (Score) \u003d [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).name) in set continuing_names)], surplus_scores:seq of (Score) \u003d [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).count) \u003e quota)] in (forall i in set (inds continuing_scores) \u0026 (i in set (inds continuing_scores))))","legal sequence application obligation:(forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in let continuing_scores:seq of (Score) \u003d [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).name) in set continuing_names)], surplus_scores:seq of (Score) \u003d [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).count) \u003e quota)] in (forall i in set (inds continuing_scores) \u0026 (forall j in set ((inds continuing_scores) \\ {i}) \u0026 (j in set (inds continuing_scores)))))","legal sequence application obligation:(forall continuing:set of (Candidate), stages:seq of (Stage), quota:real \u0026 let continuing_names:set of (Candidate_names) \u003d {(c.name) | c in set continuing} in let continuing_scores:seq of (Score) \u003d [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).name) in set continuing_names)], surplus_scores:seq of (Score) \u003d [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).count) \u003e quota)] in (forall i in set (inds continuing_scores) \u0026 (forall j in set (inds surplus_scores) \u0026 (j in set (inds surplus_scores)))))","legal sequence application obligation:(forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 ((i + 1) in set (inds stages))))","legal sequence application obligation:(forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 (i in set (inds stages))))","unique existence binding obligation:(forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 (((len stages((i + 1))) \u003e (len stages(i))) \u003d\u003e (exists1 ex in set Cand_names \u0026 (ex in set {(sc.name) | sc in set (elems stages((i + 1))) \u0026 (forall osc in set (elems stages(i)) \u0026 ((osc.name) \u003c\u003e (sc.name)))})))))","legal sequence application obligation:(forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 (((len stages((i + 1))) \u003e (len stages(i))) \u003d\u003e (forall ex in set Cand_names \u0026 ((i + 1) in set (inds stages))))))","legal sequence application obligation:(forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 (((len stages((i + 1))) \u003e (len stages(i))) \u003d\u003e (forall ex in set Cand_names \u0026 (forall sc in set (elems stages((i + 1))) \u0026 (i in set (inds stages)))))))","legal sequence application obligation:(forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 (((len stages((i + 1))) \u003e (len stages(i))) \u003d\u003e let excluded:(\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cDonald\u003e | \u003cEdward\u003e | \u003cFrank\u003e | \u003cGeorge\u003e | \u003cHarry\u003e | \u003cIan\u003e | \u003cJohn\u003e) \u003d (iota ex in set Cand_names \u0026 (ex in set {(sc.name) | sc in set (elems stages((i + 1))) \u0026 (forall osc in set (elems stages(i)) \u0026 ((osc.name) \u003c\u003e (sc.name)))})) in ((i + 1) in set (inds record)))))","unique existence binding obligation:(forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 ((not ((len stages((i + 1))) \u003e (len stages(i)))) \u003d\u003e (exists1 tf in set Cand_names \u0026 (tf in set {(sc.name) | sc in set (elems stages((i + 1))) \u0026 ((mk_Score((sc.name), quota) in set (elems stages(i))) and ((sc.count) \u003e quota))})))))","legal sequence application obligation:(forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 ((not ((len stages((i + 1))) \u003e (len stages(i)))) \u003d\u003e (forall tf in set Cand_names \u0026 ((i + 1) in set (inds stages))))))","legal sequence application obligation:(forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 ((not ((len stages((i + 1))) \u003e (len stages(i)))) \u003d\u003e (forall tf in set Cand_names \u0026 (forall sc in set (elems stages((i + 1))) \u0026 (i in set (inds stages)))))))","legal sequence application obligation:(forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 (forall i:nat1 \u0026 ((not ((len stages((i + 1))) \u003e (len stages(i)))) \u003d\u003e let transferred:(\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cDonald\u003e | \u003cEdward\u003e | \u003cFrank\u003e | \u003cGeorge\u003e | \u003cHarry\u003e | \u003cIan\u003e | \u003cJohn\u003e) \u003d (iota tf in set Cand_names \u0026 (tf in set {(sc.name) | sc in set (elems stages((i + 1))) \u0026 ((mk_Score((sc.name), quota) in set (elems stages(i))) and ((sc.count) \u003e quota))})) in ((i + 1) in set (inds record)))))","type compatibility obligation:(forall stages:seq of (Stage), quota:real, record:seq of (Record_entry), elected:set of (Candidate_names) \u0026 let result: (nat1 -\u003e Result)\n\tresult(i) \u003d\u003d\n(if ((len stages((i + 1))) \u003e (len stages(i)))\nthen let excluded:(\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cDonald\u003e | \u003cEdward\u003e | \u003cFrank\u003e | \u003cGeorge\u003e | \u003cHarry\u003e | \u003cIan\u003e | \u003cJohn\u003e) \u003d (iota ex in set Cand_names \u0026 (ex in set {(sc.name) | sc in set (elems stages((i + 1))) \u0026 (forall osc in set (elems stages(i)) \u0026 ((osc.name) \u003c\u003e (sc.name)))})) in mk_Result((record((i + 1)).scores), nil, excluded)\nelse let transferred:(\u003cAdam\u003e | \u003cBill\u003e | \u003cCharlie\u003e | \u003cDonald\u003e | \u003cEdward\u003e | \u003cFrank\u003e | \u003cGeorge\u003e | \u003cHarry\u003e | \u003cIan\u003e | \u003cJohn\u003e) \u003d (iota tf in set Cand_names \u0026 (tf in set {(sc.name) | sc in set (elems stages((i + 1))) \u0026 ((mk_Score((sc.name), quota) in set (elems stages(i))) and ((sc.count) \u003e quota))})) in mk_Result((record((i + 1)).scores), transferred, nil)) in (forall j in set {1, ... ,((len record) - 1)} \u0026 (((len record) - j) \u003e 0)))","let be st existence obligation:(forall s:set of (Sub_parcel) \u0026 ((not (s \u003d {})) \u003d\u003e (exists e in set s \u0026 true)))","let be st existence obligation:(forall sps:seq of (Sub_parcel) \u0026 ((not ([] \u003d sps)) \u003d\u003e ((not (exists [e]:seq of (Sub_parcel) \u0026 ([e] \u003d sps))) \u003d\u003e (exists sps1 ^ sps2 in set {sps} \u0026 ((abs ((len sps1) - (len sps2))) \u003c 2)))))","non-empty sequence obligation:(forall sps1:seq of (Sub_parcel), sps2:seq of (Sub_parcel) \u0026 ((not (exists mk_([], sps):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_([], sps) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (exists mk_(sps, []):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_(sps, []) \u003d mk_(sps1, sps2)))) \u003d\u003e (sps1 \u003c\u003e []))))","non-empty sequence obligation:(forall sps1:seq of (Sub_parcel), sps2:seq of (Sub_parcel) \u0026 ((not (exists mk_([], sps):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_([], sps) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (exists mk_(sps, []):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_(sps, []) \u003d mk_(sps1, sps2)))) \u003d\u003e (sps2 \u003c\u003e []))))","non-empty sequence obligation:(forall sps1:seq of (Sub_parcel), sps2:seq of (Sub_parcel) \u0026 ((not (exists mk_([], sps):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_([], sps) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (exists mk_(sps, []):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_(sps, []) \u003d mk_(sps1, sps2)))) \u003d\u003e ((total_value((hd sps1)) \u003e\u003d total_value((hd sps2))) \u003d\u003e (sps1 \u003c\u003e [])))))","non-empty sequence obligation:(forall sps1:seq of (Sub_parcel), sps2:seq of (Sub_parcel) \u0026 ((not (exists mk_([], sps):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_([], sps) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (exists mk_(sps, []):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_(sps, []) \u003d mk_(sps1, sps2)))) \u003d\u003e ((total_value((hd sps1)) \u003e\u003d total_value((hd sps2))) \u003d\u003e (sps1 \u003c\u003e [])))))","non-empty sequence obligation:(forall sps1:seq of (Sub_parcel), sps2:seq of (Sub_parcel) \u0026 ((not (exists mk_([], sps):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_([], sps) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (exists mk_(sps, []):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_(sps, []) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (total_value((hd sps1)) \u003e\u003d total_value((hd sps2)))) \u003d\u003e (sps2 \u003c\u003e [])))))","non-empty sequence obligation:(forall sps1:seq of (Sub_parcel), sps2:seq of (Sub_parcel) \u0026 ((not (exists mk_([], sps):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_([], sps) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (exists mk_(sps, []):(seq of (Sub_parcel) * seq of (Sub_parcel)) \u0026 (mk_(sps, []) \u003d mk_(sps1, sps2)))) \u003d\u003e ((not (total_value((hd sps1)) \u003e\u003d total_value((hd sps2)))) \u003d\u003e (sps2 \u003c\u003e [])))))","non-empty sequence obligation:((stages \u003c\u003e []) \u003d\u003e (stages \u003c\u003e []))","non-empty sequence obligation:((stages \u003c\u003e []) \u003d\u003e (forall score in set (elems (hd stages)) \u0026 (stages \u003c\u003e [])))","non-empty sequence obligation:((stages \u003c\u003e []) \u003d\u003e (forall score in set (elems (hd stages)) \u0026 ((hd stages) \u003c\u003e [])))","unique existence binding obligation:((stages \u003c\u003e []) \u003d\u003e (exists1 name in set leaders \u0026 greatest_value_at_earliest_stage(name, stages)))","non-empty sequence obligation:((stages \u003c\u003e []) \u003d\u003e (stages \u003c\u003e []))","legal function application obligation:((stages \u003c\u003e []) \u003d\u003e (forall score in set (elems (hd stages)) \u0026 pre_stage_bk((hd stages))))","non-empty sequence obligation:((stages \u003c\u003e []) \u003d\u003e (forall score in set (elems (hd stages)) \u0026 (stages \u003c\u003e [])))","type compatibility obligation:((stages \u003c\u003e []) \u003d\u003e (forall n in set lowest \u0026 is_(stages, seq1 of (Stage))))","unique existence binding obligation:((stages \u003c\u003e []) \u003d\u003e (exists1 name in set lowest \u0026 trailing_candidate(name, stages)))","type compatibility obligation:((stages \u003c\u003e []) \u003d\u003e (forall name in set lowest \u0026 is_(stages, seq1 of (Stage))))","non-empty sequence obligation:(forall s:Candnset, oldstate:St \u0026 (next_choice \u003c\u003e []))","state invariant holds obligation:(forall s:Candnset, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","non-empty sequence obligation:(forall s:Candnset, oldstate:St \u0026 (next_choice \u003c\u003e []))","state invariant holds obligation:(forall votes:Parcel, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation:(forall votes:Parcel, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation:(forall votes:Parcel, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation:(forall votes:Parcel, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation:(forall votes:Parcel, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation:(forall votes:Parcel, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","non-zero obligation:(forall votes:Parcel, oldstate:St \u0026 ((Number_of_vacancies + 1) \u003c\u003e 0))","state invariant holds obligation:(forall votes:Parcel, oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","non-empty sequence obligation:(forall votes:Parcel, oldstate:St \u0026 ([build_first_stage(curr_cont)] \u003c\u003e []))","operation call obligation:(forall votes:Parcel, oldstate:St \u0026 (number_of_candidates_satisfying_quota(continuing, stages, quota) \u003c\u003d number_of_remaining_vacancies({(e.name) | e in set elected})))","state invariant holds obligation:let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name))))))","state invariant holds obligation:let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name))))))","type compatibility obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 inv_Value(0.0))","non-empty sequence obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 (stages \u003c\u003e []))","while loop termination obligation:...","state invariant holds obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","legal sequence application obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 ((i + 1) in set (inds sub_parcels)))","legal sequence application obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 ((i + 1) in set (inds sub_parcels)))","state invariant holds obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","legal sequence application obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 ((i + 1) in set (inds sub_parcels)))","state invariant holds obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","legal function application obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 pre_redistribute_parcels(new_candidates, bundle))","state invariant holds obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","non-empty sequence obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 (record \u003c\u003e []))","state invariant holds obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","legal sequence application obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 (forall i in set (inds new_stage) \u0026 (((new_stage(i).name) \u003c\u003e (ex_cand.name)) \u003d\u003e (i in set (inds new_stage)))))","legal sequence application obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 (forall i in set (inds new_stage) \u0026 (i in set (inds new_stage))))","type compatibility obligation:(forall ex_cand:Candidate, sub_parcels:seq of (Sub_parcel), oldstate:St \u0026 is_(([[new_stage(i) | i in set (inds new_stage) \u0026 ((new_stage(i).name) \u003c\u003e (ex_cand.name))]] ^ stages), seq of (Stage)))","unique existence binding obligation:(last_vacancy_fillable(continuing, stages, quota) \u003d\u003e (exists1 leader in set continuing \u0026 ((leader.name) \u003d ((hd stages)(Number_of_vacancies).name))))","legal sequence application obligation:(last_vacancy_fillable(continuing, stages, quota) \u003d\u003e (forall leader in set continuing \u0026 (Number_of_vacancies in set (inds (hd stages)))))","non-empty sequence obligation:(last_vacancy_fillable(continuing, stages, quota) \u003d\u003e (forall leader in set continuing \u0026 (stages \u003c\u003e [])))","state invariant holds obligation:(last_vacancy_fillable(continuing, stages, quota) \u003d\u003e let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation:(last_vacancy_fillable(continuing, stages, quota) \u003d\u003e let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","unique existence binding obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e (exists1 c in set elected \u0026 ((c.name) \u003d name)))","non-empty sequence obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e (stages \u003c\u003e []))","non-empty sequence obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e ((hd stages) \u003c\u003e []))","type compatibility obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e (surplus_from_original_votes(candidate) \u003d\u003e inv_Value(1.0)))","non-empty sequence obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e ((not surplus_from_original_votes(candidate)) \u003d\u003e ((candidate.transferred_votes) \u003c\u003e [])))","type compatibility obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e inv_Stage(([mk_Score(name, quota)] ^ [(hd stages)(i) | i in set (inds (hd stages)) \u0026 (((hd stages)(i).name) \u003c\u003e name)])))","legal sequence application obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e (forall i in set (inds (hd stages)) \u0026 ((((hd stages)(i).name) \u003c\u003e name) \u003d\u003e (i in set (inds (hd stages))))))","non-empty sequence obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e (forall i in set (inds (hd stages)) \u0026 ((((hd stages)(i).name) \u003c\u003e name) \u003d\u003e (stages \u003c\u003e []))))","non-empty sequence obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e (stages \u003c\u003e []))","legal sequence application obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e (forall i in set (inds (hd stages)) \u0026 (i in set (inds (hd stages)))))","non-empty sequence obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e (forall i in set (inds (hd stages)) \u0026 (stages \u003c\u003e [])))","legal function application obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e pre_redistribute_parcels((continuing \\ {candidate}), sub_parcel_bundle))","state invariant holds obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","non-empty sequence obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e (record \u003c\u003e []))","state invariant holds obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","operation call obligation:(exists_non_deferable_surplus(stages, quota) \u003d\u003e (number_of_candidates_satisfying_quota(continuing, stages, quota) \u003c\u003d number_of_remaining_vacancies({(e.name) | e in set elected})))","unique existence binding obligation:(exists1 c in set continuing \u0026 ((c.name) \u003d name))","type compatibility obligation:inv_Value(1.0)","operation call obligation:(true \u003d\u003e (number_of_candidates_satisfying_quota(continuing, stages, quota) \u003c\u003d number_of_remaining_vacancies({(e.name) | e in set elected})))","operation call obligation:(true \u003d\u003e (true \u003d\u003e last_vacancy_fillable(continuing, stages, quota)))","operation call obligation:(true \u003d\u003e (true \u003d\u003e (true \u003d\u003e exists_non_deferable_surplus(stages, quota))))","while loop termination obligation:...","non-empty sequence obligation:((number_of_candidates_satisfying_quota(continuing, stages, quota) \u003c\u003d number_of_remaining_vacancies({(e.name) | e in set elected})) \u003d\u003e (stages \u003c\u003e []))","state invariant holds obligation:((number_of_candidates_satisfying_quota(continuing, stages, quota) \u003c\u003d number_of_remaining_vacancies({(e.name) | e in set elected})) \u003d\u003e let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))","state invariant holds obligation:((number_of_candidates_satisfying_quota(continuing, stages, quota) \u003c\u003d number_of_remaining_vacancies({(e.name) | e in set elected})) \u003d\u003e let s \u003d St in (({(cand.name) | cand in set (((s.elected) union (s.excluded)) union (s.continuing))} \u003d Cand_names) and (disjoint({(s.elected), (s.excluded), (s.continuing)}) and (forall cand1 in set (((s.elected) union (s.excluded)) union (s.continuing)), cand2 in set (((s.elected) union (s.excluded)) union (s.continuing)) \u0026 ((cand1 \u003d cand2) \u003c\u003d\u003e ((cand1.name) \u003d (cand2.name)))))))"]