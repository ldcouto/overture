["type compatibility obligation:(forall prad:real \u0026 (let degrees:int \u003d (floor ((prad * MATH`pi) / 180)) in (degrees mod 360) \u003e\u003d 0))","non-zero obligation:(World`SIM_RESOLUTION \u003c\u003e 0)","type compatibility obligation:(forall init:real, file:seq of (char) \u0026 is_(file, seq1 of (char)))","legal sequence application obligation:(((line \u003c\u003d lines) and (next_setpoint \u003d nil)) \u003d\u003e (forall filename1:seq of (char), lines2:int, line3:int, setpoint4:real, next_setpoint5:[(real * real)] \u0026 (true \u003d\u003e (1 in set (inds vals)))))","legal sequence application obligation:(((line \u003c\u003d lines) and (next_setpoint \u003d nil)) \u003d\u003e (forall filename1:seq of (char), lines2:int, line3:int, setpoint4:real, next_setpoint5:[(real * real)] \u0026 (true \u003d\u003e (2 in set (inds vals)))))","operation call obligation:((line \u003c\u003d lines) and (next_setpoint \u003d nil))","non-zero obligation:(forall fname:seq1 of (char) \u0026 (true \u003d\u003e (forall cosim1:bool, finish2:bool \u0026 (true \u003d\u003e (true \u003d\u003e (SIM_RESOLUTION \u003c\u003e 0))))))","legal sequence application obligation:(forall tcb:map (seq of (char)) to (seq1 of (tCtCurve)) \u0026 (forall tc in set (rng tcb) \u0026 (forall i in set ((inds tc) \\ {1}) \u0026 ((i - 1) in set (inds tc)))))","legal sequence application obligation:(forall tcb:map (seq of (char)) to (seq1 of (tCtCurve)) \u0026 (forall tc in set (rng tcb) \u0026 (forall i in set ((inds tc) \\ {1}) \u0026 (i in set (inds tc)))))","type invariant satisfiable obligation:(exists tcb:tCtBehavior \u0026 (forall tc in set (rng tcb) \u0026 (forall i in set ((inds tc) \\ {1}) \u0026 ((tc((i - 1)).#1) \u003c (tc(i).#1)))))","type compatibility obligation:inv_tCtBehavior({|-\u003e})","type compatibility obligation:(forall pctvar:seq of (char), pfname:seq of (char) \u0026 ((pctvar in set reserved) \u003d\u003e (true \u003d\u003e is_(pfname, seq1 of (char)))))","while loop termination obligation:...","legal sequence application obligation:(forall pctvar:seq of (char), pfname:seq of (char) \u0026 ((pctvar in set reserved) \u003d\u003e (true \u003d\u003e (true \u003d\u003e (1 in set (inds vs))))))","legal sequence application obligation:(forall pctvar:seq of (char), pfname:seq of (char) \u0026 ((pctvar in set reserved) \u003d\u003e (true \u003d\u003e (true \u003d\u003e (1 in set (inds vs))))))","legal sequence application obligation:(forall pctvar:seq of (char), pfname:seq of (char) \u0026 ((pctvar in set reserved) \u003d\u003e (true \u003d\u003e (true \u003d\u003e (2 in set (inds vs))))))","legal sequence application obligation:(forall pctvar:seq of (char), pfname:seq of (char) \u0026 ((pctvar in set reserved) \u003d\u003e (true \u003d\u003e (true \u003d\u003e (2 in set (inds vs))))))","legal sequence application obligation:(forall pctvar:seq of (char), pfname:seq of (char) \u0026 ((pctvar in set reserved) \u003d\u003e (true \u003d\u003e (true \u003d\u003e ((len (lctc ^ [mk_((cx + 0.5), cy, 0.0)])) in set (inds (lctc ^ [mk_((cx + 0.5), cy, 0.0)])))))))","type compatibility obligation:(forall pctvar:seq of (char), pfname:seq of (char) \u0026 ((pctvar in set reserved) \u003d\u003e (true \u003d\u003e (true \u003d\u003e (inv_tCtBehavior((mCtBehavior ++ {pctvar |-\u003e lctc})) and is_((mCtBehavior ++ {pctvar |-\u003e lctc}), map (seq of (char)) to (seq1 of (tCtCurve))))))))","type compatibility obligation:(forall pfname:seq of (char) \u0026 (true \u003d\u003e (true \u003d\u003e (inv_tCtBehavior(rv) and is_(rv, map (seq of (char)) to (seq1 of (tCtCurve)))))))","legal map application obligation:(forall ptime:real \u0026 (iname in set (dom mCtBehavior)))","operation call obligation:(forall ptime:real \u0026 (ptime \u003e\u003d ptime))","type compatibility obligation:(forall ptime:real \u0026 (forall mCtBehavior1:tCtBehavior, debug2:nat, mWorld3:World, mMaxSimTime4:nat, mLeftWheel5:Wheel, mRightWheel6:Wheel, mLeftHall7:HallSensor, mRightHall8:HallSensor, mUser9:User, ain10:ISensorReal, vin11:ISensorReal, aout12:IActuatorReal, vout13:IActuatorReal, mValues14:map (seq of (char)) to (real) \u0026 (true \u003d\u003e inv_tCtBehavior((mCtBehavior ++ {iname |-\u003e (tl behaviors)})))))","operation call obligation:(forall ptime:real \u0026 (forall mCtBehavior1:tCtBehavior, debug2:nat, mWorld3:World, mMaxSimTime4:nat, mLeftWheel5:Wheel, mRightWheel6:Wheel, mLeftHall7:HallSensor, mRightHall8:HallSensor, mUser9:User, ain10:ISensorReal, vin11:ISensorReal, aout12:IActuatorReal, vout13:IActuatorReal, mValues14:map (seq of (char)) to (real) \u0026 (true \u003d\u003e (ptime \u003e\u003d ptime))))","operation call obligation:(forall ptime:real \u0026 (forall mCtBehavior1:tCtBehavior, debug2:nat, mWorld3:World, mMaxSimTime4:nat, mLeftWheel5:Wheel, mRightWheel6:Wheel, mLeftHall7:HallSensor, mRightHall8:HallSensor, mUser9:User, ain10:ISensorReal, vin11:ISensorReal, aout12:IActuatorReal, vout13:IActuatorReal, mValues14:map (seq of (char)) to (real) \u0026 (true \u003d\u003e (forall mCtBehavior15:tCtBehavior, debug16:nat, mWorld17:World, mMaxSimTime18:nat, mLeftWheel19:Wheel, mRightWheel20:Wheel, mLeftHall21:HallSensor, mRightHall22:HallSensor, mUser23:User, ain24:ISensorReal, vin25:ISensorReal, aout26:IActuatorReal, vout27:IActuatorReal, mValues28:map (seq of (char)) to (real) \u0026 (true \u003d\u003e (ptime \u003e\u003d ptime))))))","operation call obligation:(forall ptime:real, pname:seq of (char), mk_(ltime, lvalue, ldir):tCtCurve \u0026 ((ptime \u003e\u003d ltime) \u003d\u003e (pname in set reserved)))","type compatibility obligation:is_(ChessWay`acc_in, ISensorReal)","type compatibility obligation:is_(ChessWay`vel_in, ISensorReal)","type compatibility obligation:is_(ChessWay`acc_out, IActuatorReal)","type compatibility obligation:is_(ChessWay`vel_out, IActuatorReal)","legal map application obligation:(forall pName:seq of (char) \u0026 (pName in set (dom mValues)))","non-zero obligation:(World`SIM_RESOLUTION \u003c\u003e 0)","legal map application obligation:(true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (pKey in set (dom mValues)))))","non-zero obligation:(World`SIM_RESOLUTION \u003c\u003e 0)","non-zero obligation:((not (dt \u003d 0)) \u003d\u003e (dt \u003c\u003e 0))","non-zero obligation:(forall err:real \u0026 (tauI \u003c\u003e 0))","non-zero obligation:(forall err:real \u0026 ((sampletime + (tauD * beta)) \u003c\u003e 0))","operation call obligation:(forall k_:real, tauI_:real, tauD_:real \u0026 (((tauI_ \u003c\u003e 0) and (tauD_ \u003c\u003e 0)) \u003d\u003e ((k_ \u003c\u003e 0) and ((k_ \u003c\u003e 0) and ((k_ \u003e 0) and (k_ \u003c\u003d 1))))))","operation call obligation:((DEF_K \u003c\u003e 0) and ((DEF_K \u003c\u003e 0) and ((DEF_K \u003e 0) and (DEF_K \u003c\u003d 1))))","non-zero obligation:(forall err:real \u0026 ((sampletime + (tauD * beta)) \u003c\u003e 0))","non-zero obligation:(forall err:real \u0026 (tauI \u003c\u003e 0))","operation call obligation:(forall text:seq of (char) \u0026 ((\"\" \u003d \"\") \u003c\u003d\u003e (\"\" \u003d nil)))","non-zero obligation:(forall a:real \u0026 ((a \u003c\u003e 0) \u003d\u003e (a \u003c\u003e 0)))"]