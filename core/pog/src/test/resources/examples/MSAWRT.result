["comprehension map injectivity obligation:(forall m1, m2 in set {(r.getDetectedMap)() | r in set radars} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal map application obligation:(forall id:FOId \u0026 (((id in set (dom history)) and ((len history(id)) \u003d 3)) \u003d\u003e ((id in set (dom history)) \u003d\u003e (id in set (dom history)))))","legal map application obligation:(forall id:FOId \u0026 (((id in set (dom history)) and ((len history(id)) \u003d 3)) \u003d\u003e (id in set (dom history))))","legal sequence application obligation:(forall id:FOId \u0026 (((id in set (dom history)) and ((len history(id)) \u003d 3)) \u003d\u003e (3 in set (inds hist))))","legal sequence application obligation:(forall id:FOId \u0026 (((id in set (dom history)) and ((len history(id)) \u003d 3)) \u003d\u003e (2 in set (inds hist))))","legal sequence application obligation:(forall id:FOId \u0026 (((id in set (dom history)) and ((len history(id)) \u003d 3)) \u003d\u003e (1 in set (inds hist))))","legal map application obligation:(forall id:FOId \u0026 (((id in set (dom history)) and ((len history(id)) \u003d 3)) \u003d\u003e ((id in set (dom history)) \u003d\u003e (id in set (dom history)))))","legal map application obligation:(forall id:FOId \u0026 (((id in set (dom history)) and ((len history(id)) \u003d 3)) \u003d\u003e (id in set (dom history))))","legal sequence application obligation:(forall id:FOId \u0026 (((id in set (dom history)) and ((len history(id)) \u003d 3)) \u003d\u003e (forall i in set (inds lastHist) \u0026 (i in set (inds lastHist)))))","type compatibility obligation:(forall id:FOId \u0026 (((id in set (dom history)) and ((len history(id)) \u003d 3)) \u003d\u003e is_(RESULT, seq of (nat))))","legal map application obligation:(forall fo:FO \u0026 (id in set (dom history)))","map compatible obligation:(forall fo:FO \u0026 (forall ldom1 in set (dom history), rdom2 in set (dom {id |-\u003e addHistory([], (fo.getCoordinates)(), (fo.getAltitude)())}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (history(ldom1) \u003d {id |-\u003e addHistory([], (fo.getCoordinates)(), (fo.getAltitude)())}(rdom2)))))","legal function application obligation:(forall hist:History, coord:Coordinates, alt:Altitude \u0026 (((len hist) \u003e 0) \u003d\u003e pre_last(hist)))","non-empty sequence obligation:(forall hist:History, coord:Coordinates, alt:Altitude \u0026 (((len hist) \u003e 0) \u003d\u003e let lastValue:Position \u003d last(hist) in ((not (lastValue \u003d mk_Position(coord, alt))) \u003d\u003e ((not ((len hist) \u003c 3)) \u003d\u003e (hist \u003c\u003e [])))))","legal sequence application obligation:(forall hist:History \u0026 (((len hist) \u003e 0) \u003d\u003e ((len hist) in set (inds hist))))","legal map application obligation:(forall busy1:bool, radars2:set of (Radar), obstacles3:set of (Obstacle), history4:map (FOId) to (seq of (Position)) \u0026 (true \u003d\u003e (((fo.getId)() in set (dom history4)) \u003d\u003e ((fo.getId)() in set (dom history4)))))","operation call obligation:(forall busy1:bool, radars2:set of (Radar), obstacles3:set of (Obstacle), history4:map (FOId) to (seq of (Position)) \u0026 (true \u003d\u003e (((fo.getId)() in set (dom history4)) and ((len history((fo.getId)())) \u003d 3))))","non-empty set obligation:(forall radars:set of (Radar) \u0026 ({(r.getDetected)() | r in set radars} \u003c\u003e {}))","type compatibility obligation:(forall msa:MinimumSafetyAltitude, pos:Position \u0026 ((msa \u003c\u003e \u003cNotAllowed\u003e) \u003d\u003e is_(msa, real)))","legal map application obligation:(forall obs:Obstacle, fo:FO \u0026 ((((fo.getId)() in set (dom history)) and ((len history((fo.getId)())) \u003d 3)) \u003d\u003e (((fo.getId)() in set (dom history)) \u003d\u003e ((fo.getId)() in set (dom history)))))","legal map application obligation:(forall fo:FO \u0026 (((fo.getId)() in set (dom history)) \u003d\u003e ((fo.getId)() in set (dom history))))","legal map application obligation:(forall fo:FO \u0026 ((((fo.getId)() in set (dom history)) and ((len history((fo.getId)())) \u003d 3)) \u003d\u003e (((fo.getId)() in set (dom history)) \u003d\u003e ((fo.getId)() in set (dom history)))))","legal sequence application obligation:(forall fo:FO \u0026 ((((fo.getId)() in set (dom history)) and ((len history((fo.getId)())) \u003d 3)) \u003d\u003e (1 in set (inds vs))))","legal sequence application obligation:(forall fo:FO \u0026 ((((fo.getId)() in set (dom history)) and ((len history((fo.getId)())) \u003d 3)) \u003d\u003e (2 in set (inds vs))))","legal sequence application obligation:(forall fo:FO \u0026 ((((fo.getId)() in set (dom history)) and ((len history((fo.getId)())) \u003d 3)) \u003d\u003e (1 in set (inds vs))))","legal function application obligation:(forall fo:FO \u0026 ((((fo.getId)() in set (dom history)) and ((len history((fo.getId)())) \u003d 3)) \u003d\u003e pre_predictAltitude(getAltitudeHistory(foid))))","legal sequence application obligation:(forall fo:FO \u0026 ((((fo.getId)() in set (dom history)) and ((len history((fo.getId)())) \u003d 3)) \u003d\u003e (3 in set (inds history(foid)))))","legal map application obligation:(forall fo:FO \u0026 ((((fo.getId)() in set (dom history)) and ((len history((fo.getId)())) \u003d 3)) \u003d\u003e (foid in set (dom history))))","legal sequence application obligation:(forall alts:seq of (nat) \u0026 (((len alts) \u003d 2) \u003d\u003e (1 in set (inds alts))))","legal sequence application obligation:(forall alts:seq of (nat) \u0026 (((len alts) \u003d 2) \u003d\u003e (1 in set (inds alts))))","legal sequence application obligation:(forall alts:seq of (nat) \u0026 (((len alts) \u003d 2) \u003d\u003e (2 in set (inds alts))))","type compatibility obligation:(forall alts:seq of (nat) \u0026 (((len alts) \u003d 2) \u003d\u003e ((alts(1) + (alts(1) - alts(2))) \u003e\u003d 0)))","non-zero obligation:(forall v:Vector, n:int \u0026 ((n \u003c\u003e 0) \u003d\u003e (n \u003c\u003e 0)))","non-zero obligation:(forall v:Vector, n:int \u0026 ((n \u003c\u003e 0) \u003d\u003e (n \u003c\u003e 0)))","legal function application obligation:(forall v:Vector \u0026 pre_sqrt((((v.X) ** 2) + ((v.Y) ** 2))))","non-zero obligation:(forall v:Vector \u0026 let l:real \u003d vectorLength(v) in (l \u003c\u003e 0))","non-zero obligation:(forall v:Vector \u0026 let l:real \u003d vectorLength(v) in (l \u003c\u003e 0))","legal function application obligation:(forall v1:Vector, v2:Vector \u0026 pre_acos(dvs))","non-zero obligation:(forall r:real \u0026 (MATH`pi \u003c\u003e 0))","legal function application obligation:(forall y:real, x:real \u0026 ((not ((x \u003d 0) and (y \u003d 0))) \u003d\u003e pre_sqrt(((x ** 2) + (y ** 2)))))","non-zero obligation:(forall y:real, x:real \u0026 ((not ((x \u003d 0) and (y \u003d 0))) \u003d\u003e ((MATH`sqrt(((x ** 2) + (y ** 2))) + x) \u003c\u003e 0)))","legal function application obligation:(forall v1:Vector, v2:Vector \u0026 pre_atan2((v2.Y), (v2.X)))","legal function application obligation:(forall v1:Vector, v2:Vector \u0026 pre_atan2((v1.Y), (v1.X)))","legal function application obligation:(forall v:Vector \u0026 pre_acos(((v.X) / MATH`sqrt((((v.X) ** 2) + ((v.Y) ** 2))))))","legal function application obligation:(forall v:Vector \u0026 pre_sqrt((((v.X) ** 2) + ((v.Y) ** 2))))","non-zero obligation:(forall v:Vector \u0026 (MATH`sqrt((((v.X) ** 2) + ((v.Y) ** 2))) \u003c\u003e 0))","legal function application obligation:(forall v:Vector \u0026 pre_asin(((v.Y) / MATH`sqrt((((v.X) ** 2) + ((v.Y) ** 2))))))","legal function application obligation:(forall v:Vector \u0026 pre_sqrt((((v.X) ** 2) + ((v.Y) ** 2))))","non-zero obligation:(forall v:Vector \u0026 (MATH`sqrt((((v.X) ** 2) + ((v.Y) ** 2))) \u003c\u003e 0))","legal function application obligation:(forall x1:real, y1:real, x2:real, y2:real \u0026 pre_atan2(1.0E-6, 0.0))","state invariant initialized obligation:(forall foid1, foid2 in set (dom airspace) \u0026 ((foid1 \u003c\u003e foid2) \u003d\u003e ((airspace(foid1).getId)() \u003c\u003e (airspace(foid2).getId)())))","state invariant satisfiable obligation:(exists airspace:map (FOId) to (FO) \u0026 (forall foid1, foid2 in set (dom airspace) \u0026 ((foid1 \u003c\u003e foid2) \u003d\u003e ((airspace(foid1).getId)() \u003c\u003e (airspace(foid2).getId)()))))","state invariant holds obligation:(forall fo:FO \u0026 (((fo.getId)() not in set (dom airspace)) \u003d\u003e ((forall foid1, foid2 in set (dom airspace) \u0026 ((foid1 \u003c\u003e foid2) \u003d\u003e ((airspace(foid1).getId)() \u003c\u003e (airspace(foid2).getId)()))) \u003d\u003e (forall foid1, foid2 in set (dom airspace) \u0026 ((foid1 \u003c\u003e foid2) \u003d\u003e ((airspace(foid1).getId)() \u003c\u003e (airspace(foid2).getId)()))))))","map compatible obligation:(forall fo:FO \u0026 (((fo.getId)() not in set (dom airspace)) \u003d\u003e (forall ldom1 in set (dom airspace), rdom2 in set (dom {(fo.getId)() |-\u003e fo}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (airspace(ldom1) \u003d {(fo.getId)() |-\u003e fo}(rdom2))))))","state invariant holds obligation:(forall id:FOId \u0026 ((forall foid1, foid2 in set (dom airspace) \u0026 ((foid1 \u003c\u003e foid2) \u003d\u003e ((airspace(foid1).getId)() \u003c\u003e (airspace(foid2).getId)()))) \u003d\u003e (forall foid1, foid2 in set (dom airspace) \u0026 ((foid1 \u003c\u003e foid2) \u003d\u003e ((airspace(foid1).getId)() \u003c\u003e (airspace(foid2).getId)())))))","legal map application obligation:(forall id:FOId \u0026 ((id in set (dom airspace)) \u003d\u003e (id in set (dom airspace))))","legal map application obligation:(forall id:FOId, coord:Coordinates, alt:Altitude \u0026 (id in set (dom airspace)))","state invariant holds obligation:(forall id:FOId, coord:Coordinates, alt:Altitude \u0026 ((forall foid1, foid2 in set (dom airspace) \u0026 ((foid1 \u003c\u003e foid2) \u003d\u003e ((airspace(foid1).getId)() \u003c\u003e (airspace(foid2).getId)()))) \u003d\u003e (forall foid1, foid2 in set (dom airspace) \u0026 ((foid1 \u003c\u003e foid2) \u003d\u003e ((airspace(foid1).getId)() \u003c\u003e (airspace(foid2).getId)())))))","map compatible obligation:(forall id:FOId, coord:Coordinates, alt:Altitude \u0026 (forall ldom1 in set (dom airspace), rdom2 in set (dom {id |-\u003e newfo}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (airspace(ldom1) \u003d {id |-\u003e newfo}(rdom2)))))","type compatibility obligation:(forall msa:MinimumSafetyAltitude, loc:Coordinates, ra:nat, secRa:nat, tp:ObstacleType \u0026 (ra \u003e 0))","legal function application obligation:(forall fname:String \u0026 pre_(((io.freadval))[InputTP]fname))","legal function application obligation:pre_(((io.writeval))[seq of (outline)]outlines)","while loop termination obligation:...","non-empty sequence obligation:(inlines \u003c\u003e [])","non-empty sequence obligation:(inlines \u003c\u003e [])","state invariant holds obligation:(forall x:int, y:int, r:nat1 \u0026 (forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid)))","state invariant holds obligation:(forall as:AirSpace \u0026 ((forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid)) \u003d\u003e (forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid))))","comprehension map injectivity obligation:(forall as:AirSpace \u0026 (forall m1, m2 in set {{(x.getId)() |-\u003e x} | x in set (as.getAirspace)() \u0026 InRange(x)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal sequence application obligation:(forall i in set (inds priority) \u0026 ((i \u003e (floor (range / 4))) \u003d\u003e (i in set (inds priority))))","state invariant holds obligation:(forall fos:set of (FO) \u0026 ((forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid)) \u003d\u003e (forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid))))","legal sequence application obligation:(forall fos:set of (FO) \u0026 (forall i in set (inds priority) \u0026 ((priority(i) in set fos) \u003d\u003e (i in set (inds priority)))))","legal sequence application obligation:(forall fos:set of (FO) \u0026 (forall i in set (inds priority) \u0026 (i in set (inds priority))))","state invariant holds obligation:(forall newlyDetect:map (FOId) to (FO) \u0026 ((forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid)) \u003d\u003e (forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid))))","let be st existence obligation:(forall fos:set of (FO) \u0026 ((not (fos \u003d {})) \u003d\u003e (exists fo in set fos \u0026 true)))","recursive function obligation:(forall fos:set of (FO) \u0026 ((not (fos \u003d {})) \u003d\u003e (forall fo in set fos \u0026 (set2seqFOm(fos) \u003e set2seqFOm((fos \\ {fo}))))))","state invariant holds obligation:((forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid)) \u003d\u003e (forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid)))","comprehension map injectivity obligation:(forall m1, m2 in set {{(x.getId)() |-\u003e x} | x in set (as.getAirspace)() \u0026 InRange(x)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","state invariant holds obligation:((forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid)) \u003d\u003e (forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid)))","state invariant holds obligation:(forall busy1:bool, location2:Coordinates, range3:nat1, detected4:map (FOId) to (FO), priority5:seq of (FO) \u0026 ((forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid)) \u003d\u003e (forall busy6:bool, location7:Coordinates, range8:nat1, detected9:map (FOId) to (FO), priority10:seq of (FO) \u0026 ((forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid)) \u003d\u003e ((forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid)) \u003d\u003e (forall foid in set (dom detected) \u0026 ((detected(foid).getId)() \u003d foid)))))))","operation call obligation:(forall text:seq of (char) \u0026 ((\"\" \u003d \"\") \u003c\u003d\u003e (\"\" \u003d nil)))","non-zero obligation:(forall a:real \u0026 ((a \u003c\u003e 0) \u003d\u003e (a \u003c\u003e 0)))"]