["while loop termination obligation:...","legal function application obligation:(forall p1:Point, p2:Point \u0026 def a \u003d ((((p2.X) - (p1.X)) * ((p2.X) - (p1.X))) + (((p2.Y) - (p1.Y)) * ((p2.Y) - (p1.Y)))) in\n((0 \u003c\u003d a) \u003d\u003e pre_sqrt(a)))","type compatibility obligation:(forall p1:Point, p2:Point \u0026 (def a \u003d ((((p2.X) - (p1.X)) * ((p2.X) - (p1.X))) + (((p2.Y) - (p1.Y)) * ((p2.Y) - (p1.Y)))) in\n(if (0 \u003c\u003d a)\nthen (floor MATH`sqrt(a))\nelse 0) \u003e\u003d 0))","legal sequence application obligation:(((len routes) \u003e 0) \u003d\u003e ((len routes) in set (inds routes)))","legal sequence application obligation:((len routes) in set (inds routes))","legal sequence application obligation:((len r) in set (inds r))","operation establishes postcondition obligation:((RESULT \u003d let cPos:Point \u003d GetPos() in (({mk_Grid`Point((cPos.X), y) | y in set {((cPos.Y) + 1), ((cPos.Y) - 1)} \u0026 (y \u003e\u003d 0)} union {mk_Grid`Point(x, (cPos.Y)) | x in set {((cPos.X) + 1), ((cPos.X) - 1)} \u0026 (x \u003e\u003d 0)}) \\ {cPos})) and (forall p in set RESULT \u0026 (workingGrid.IsValidGridPoint)(p)))","legal sequence application obligation:((len routes) in set (inds routes))","legal sequence application obligation:(forall p:Point \u0026 (forall x in set (inds r) \u0026 ((r(x) \u003d p) \u003d\u003e (x in set (inds r)))))","legal sequence application obligation:(forall p:Point \u0026 (forall x in set (inds r) \u0026 (x in set (inds r))))","legal sequence application obligation:((len routes) in set (inds routes))","legal sequence application obligation:((len routes) in set (inds routes))","legal sequence application obligation:(forall p:Point \u0026 ((((GetBatUsage() * 2) \u003c\u003d batCap) and ((batCap \u003e 1) and let cp:Point \u003d routes((len routes))((len routes((len routes)))) in (((p.X) \u003c\u003e (cp.X)) or ((p.Y) \u003c\u003e (cp.Y))))) \u003d\u003e (((GetBatUsage() * 2) \u003c\u003d batCap) \u003d\u003e ((batCap \u003e 1) \u003d\u003e ((len routes((len routes))) in set (inds routes((len routes))))))))","legal sequence application obligation:(forall p:Point \u0026 ((((GetBatUsage() * 2) \u003c\u003d batCap) and ((batCap \u003e 1) and let cp:Point \u003d routes((len routes))((len routes((len routes)))) in (((p.X) \u003c\u003e (cp.X)) or ((p.Y) \u003c\u003e (cp.Y))))) \u003d\u003e (((GetBatUsage() * 2) \u003c\u003d batCap) \u003d\u003e ((batCap \u003e 1) \u003d\u003e ((len routes) in set (inds routes))))))","legal sequence application obligation:(forall p:Point \u0026 ((((GetBatUsage() * 2) \u003c\u003d batCap) and ((batCap \u003e 1) and let cp:Point \u003d routes((len routes))((len routes((len routes)))) in (((p.X) \u003c\u003e (cp.X)) or ((p.Y) \u003c\u003e (cp.Y))))) \u003d\u003e (((GetBatUsage() * 2) \u003c\u003d batCap) \u003d\u003e ((batCap \u003e 1) \u003d\u003e ((len routes) in set (inds routes))))))","legal sequence application obligation:(forall p:Point \u0026 ((((GetBatUsage() * 2) \u003c\u003d batCap) and ((batCap \u003e 1) and let cp:Point \u003d routes((len routes))((len routes((len routes)))) in (((p.X) \u003c\u003e (cp.X)) or ((p.Y) \u003c\u003e (cp.Y))))) \u003d\u003e ((len routes((len routes))) in set (inds routes((len routes))))))","legal sequence application obligation:(forall p:Point \u0026 ((((GetBatUsage() * 2) \u003c\u003d batCap) and ((batCap \u003e 1) and let cp:Point \u003d routes((len routes))((len routes((len routes)))) in (((p.X) \u003c\u003e (cp.X)) or ((p.Y) \u003c\u003e (cp.Y))))) \u003d\u003e ((len routes) in set (inds routes))))","legal sequence application obligation:(forall p:Point \u0026 ((((GetBatUsage() * 2) \u003c\u003d batCap) and ((batCap \u003e 1) and let cp:Point \u003d routes((len routes))((len routes((len routes)))) in (((p.X) \u003c\u003e (cp.X)) or ((p.Y) \u003c\u003e (cp.Y))))) \u003d\u003e ((len routes) in set (inds routes))))","operation establishes postcondition obligation:(forall p:Point \u0026 ((((GetBatUsage() * 2) \u003c\u003d batCap) and ((batCap \u003e 1) and let cp:Point \u003d routes((len routes))((len routes((len routes)))) in (((p.X) \u003c\u003e (cp.X)) or ((p.Y) \u003c\u003e (cp.Y))))) \u003d\u003e (p \u003d routes((len routes))((len routes((len routes)))))))","while loop termination obligation:...","operation call obligation:(forall p in set neighbourPoints \u0026 (workingGrid.IsValidGridPoint)(p))","operation call obligation:(forall routes25:seq of (Route), obsSensors26:set of (ObstacleSensor), batCap27:int, dest28:Point, workingGrid29:Grid, busy30:bool \u0026 (true \u003d\u003e (((GetBatUsage() * 2) \u003c\u003d batCap27) and ((batCap27 \u003e 1) and let cp:Point \u003d routes((len routes))((len routes((len routes)))) in (((p.X) \u003c\u003e (cp.X)) or ((p.Y) \u003c\u003e (cp.Y)))))))","comprehension map injectivity obligation:(forall neighbourPoints:set of (Point) \u0026 ((forall p in set neighbourPoints \u0026 (workingGrid.IsValidGridPoint)(p)) \u003d\u003e (forall m1, m2 in set {{p |-\u003e (obs.GetPointAvalibility)(p)} | obs in set obsSensors, p in set unknownPoints \u0026 ((obs.GetDirection)() \u003d GetPointDirection(p))} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))))","legal function application obligation:(forall p:Point \u0026 pre_(((file.writeval))[(int * int)]mk_((p.X), (p.Y))))","legal function application obligation:(forall i:int \u0026 pre_(((file.writeval))[int]i))","state invariant holds obligation:(forall startPoint:Point, p:Point \u0026 ((IsValidGridPoint(startPoint) and IsValidGridPoint(p)) \u003d\u003e (forall p in set (dom points) \u0026 IsValidGridPoint(p))))","legal map application obligation:(forall x:int, y:int \u0026 (IsValidGridPoint(mk_Point(x, y)) \u003d\u003e (mk_Point(x, y) in set (dom points))))","state invariant holds obligation:(forall mapping:map (Point) to (PointAvalibility) \u0026 ((forall p in set (dom mapping) \u0026 IsValidGridPoint(p)) \u003d\u003e ((forall p in set (dom points) \u0026 IsValidGridPoint(p)) \u003d\u003e (forall p in set (dom points) \u0026 IsValidGridPoint(p)))))","state invariant holds obligation:((((inputFileName \u003c\u003e []) and (\"TestRun.txt\" \u003c\u003e [])) and (0 \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0))))","state invariant holds obligation:(forall newFileName:seq of (char) \u0026 ((newFileName \u003c\u003e []) \u003d\u003e (((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e ((((newFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))))))","state invariant holds obligation:(forall newFileName:seq of (char) \u0026 ((newFileName \u003c\u003e []) \u003d\u003e (((((newFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e ((((newFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))))))","legal function application obligation:(forall newFileName:seq of (char) \u0026 ((newFileName \u003c\u003e []) \u003d\u003e pre_(((file.freadval))[seq of (inDataType)]inputFileName)))","state invariant holds obligation:(forall newFileName:seq of (char) \u0026 ((newFileName \u003c\u003e []) \u003d\u003e (((((newFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e ((((newFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))))))","type compatibility obligation:(forall newFileName:seq of (char) \u0026 ((newFileName \u003c\u003e []) \u003d\u003e is_(input, seq of (inDataType))))","state invariant holds obligation:(forall data:seq of (inDataType) \u0026 (((startIndex in set (inds data)) and ((destIndex in set (inds data)) and (batCapIndex in set (inds data)))) \u003d\u003e (((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e ((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))))))","legal sequence application obligation:(forall data:seq of (inDataType) \u0026 (((startIndex in set (inds data)) and ((destIndex in set (inds data)) and (batCapIndex in set (inds data)))) \u003d\u003e (startIndex in set (inds data))))","legal sequence application obligation:(forall data:seq of (inDataType) \u0026 (((startIndex in set (inds data)) and ((destIndex in set (inds data)) and (batCapIndex in set (inds data)))) \u003d\u003e (startIndex in set (inds data))))","state invariant holds obligation:(forall data:seq of (inDataType) \u0026 (((startIndex in set (inds data)) and ((destIndex in set (inds data)) and (batCapIndex in set (inds data)))) \u003d\u003e (((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e ((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))))))","legal sequence application obligation:(forall data:seq of (inDataType) \u0026 (((startIndex in set (inds data)) and ((destIndex in set (inds data)) and (batCapIndex in set (inds data)))) \u003d\u003e (destIndex in set (inds data))))","legal sequence application obligation:(forall data:seq of (inDataType) \u0026 (((startIndex in set (inds data)) and ((destIndex in set (inds data)) and (batCapIndex in set (inds data)))) \u003d\u003e (destIndex in set (inds data))))","state invariant holds obligation:(forall data:seq of (inDataType) \u0026 (((startIndex in set (inds data)) and ((destIndex in set (inds data)) and (batCapIndex in set (inds data)))) \u003d\u003e (((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e ((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and ((inData(batCapIndex).#1) \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))))))","legal sequence application obligation:(forall data:seq of (inDataType) \u0026 (((startIndex in set (inds data)) and ((destIndex in set (inds data)) and (batCapIndex in set (inds data)))) \u003d\u003e (batCapIndex in set (inds inData))))","state invariant holds obligation:(forall data:seq of (inDataType) \u0026 (((startIndex in set (inds data)) and ((destIndex in set (inds data)) and (batCapIndex in set (inds data)))) \u003d\u003e (((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and ((inData(batCapIndex).#1) \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e ((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and ((inData(batCapIndex).#1) \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))))))","type compatibility obligation:(forall data:seq of (inDataType) \u0026 (((startIndex in set (inds data)) and ((destIndex in set (inds data)) and (batCapIndex in set (inds data)))) \u003d\u003e (((len data) - 2) \u003e\u003d 0)))","comprehension map injectivity obligation:(forall data:seq of (inDataType) \u0026 (((startIndex in set (inds data)) and ((destIndex in set (inds data)) and (batCapIndex in set (inds data)))) \u003d\u003e (forall m1, m2 in set {{mk_Grid`Point((data(i).#1), (inData(i).#2)) |-\u003e \u003cOccupied\u003e} | i in set {4, ... ,(len data)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))))","legal sequence application obligation:(forall data:seq of (inDataType) \u0026 (((startIndex in set (inds data)) and ((destIndex in set (inds data)) and (batCapIndex in set (inds data)))) \u003d\u003e (forall i in set {4, ... ,(len data)} \u0026 (i in set (inds data)))))","legal sequence application obligation:(forall data:seq of (inDataType) \u0026 (((startIndex in set (inds data)) and ((destIndex in set (inds data)) and (batCapIndex in set (inds data)))) \u003d\u003e (forall i in set {4, ... ,(len data)} \u0026 (i in set (inds inData)))))","legal function application obligation:(forall g:Grid, routes:seq of (Route), dest:Point, b:bool \u0026 (forall file1:IO, inputFileName2:seq of (char), outputFileName3:seq of (char), inData4:seq of (inDataType), dest5:Point, startingPoint6:Point, battery7:nat, counter8:nat, fields9:nat \u0026 (((((inputFileName2 \u003c\u003e []) and (outputFileName3 \u003c\u003e [])) and (battery7 \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e (forall file10:IO, inputFileName11:seq of (char), outputFileName12:seq of (char), inData13:seq of (inDataType), dest14:Point, startingPoint15:Point, battery16:nat, counter17:nat, fields18:nat \u0026 (((((inputFileName11 \u003c\u003e []) and (outputFileName12 \u003c\u003e [])) and (battery16 \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e pre_(((file.fwriteval))[(bool * Point)]outputFileName, mk_(b, dest), \u003cappend\u003e))))))","legal map application obligation:(forall g:Grid, routes:seq of (Route), dest:Point, b:bool \u0026 (forall file1:IO, inputFileName2:seq of (char), outputFileName3:seq of (char), inData4:seq of (inDataType), dest5:Point, startingPoint6:Point, battery7:nat, counter8:nat, fields9:nat \u0026 (((((inputFileName2 \u003c\u003e []) and (outputFileName3 \u003c\u003e [])) and (battery7 \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e (forall file10:IO, inputFileName11:seq of (char), outputFileName12:seq of (char), inData13:seq of (inDataType), dest14:Point, startingPoint15:Point, battery16:nat, counter17:nat, fields18:nat \u0026 (((((inputFileName11 \u003c\u003e []) and (outputFileName12 \u003c\u003e [])) and (battery16 \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e (forall file19:IO, inputFileName20:seq of (char), outputFileName21:seq of (char), inData22:seq of (inDataType), dest23:Point, startingPoint24:Point, battery25:nat, counter26:nat, fields27:nat \u0026 (((((inputFileName20 \u003c\u003e []) and (outputFileName21 \u003c\u003e [])) and (battery25 \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e (forall file28:IO, inputFileName29:seq of (char), outputFileName30:seq of (char), inData31:seq of (inDataType), dest32:Point, startingPoint33:Point, battery34:nat, counter35:nat, fields36:nat \u0026 (((((inputFileName29 \u003c\u003e []) and (outputFileName30 \u003c\u003e [])) and (battery34 \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e (x in set (dom (g.points))))))))))))","legal sequence application obligation:(forall g:Grid, routes:seq of (Route), dest:Point, b:bool \u0026 (forall file1:IO, inputFileName2:seq of (char), outputFileName3:seq of (char), inData4:seq of (inDataType), dest5:Point, startingPoint6:Point, battery7:nat, counter8:nat, fields9:nat \u0026 (((((inputFileName2 \u003c\u003e []) and (outputFileName3 \u003c\u003e [])) and (battery7 \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e (forall file10:IO, inputFileName11:seq of (char), outputFileName12:seq of (char), inData13:seq of (inDataType), dest14:Point, startingPoint15:Point, battery16:nat, counter17:nat, fields18:nat \u0026 (((((inputFileName11 \u003c\u003e []) and (outputFileName12 \u003c\u003e [])) and (battery16 \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e (forall file19:IO, inputFileName20:seq of (char), outputFileName21:seq of (char), inData22:seq of (inDataType), dest23:Point, startingPoint24:Point, battery25:nat, counter26:nat, fields27:nat \u0026 (((((inputFileName20 \u003c\u003e []) and (outputFileName21 \u003c\u003e [])) and (battery25 \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e (forall file28:IO, inputFileName29:seq of (char), outputFileName30:seq of (char), inData31:seq of (inDataType), dest32:Point, startingPoint33:Point, battery34:nat, counter35:nat, fields36:nat \u0026 (((((inputFileName29 \u003c\u003e []) and (outputFileName30 \u003c\u003e [])) and (battery34 \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e (forall file37:IO, inputFileName38:seq of (char), outputFileName39:seq of (char), inData40:seq of (inDataType), dest41:Point, startingPoint42:Point, battery43:nat, counter44:nat, fields45:nat \u0026 (((((inputFileName38 \u003c\u003e []) and (outputFileName39 \u003c\u003e [])) and (battery43 \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e (forall file46:IO, inputFileName47:seq of (char), outputFileName48:seq of (char), inData49:seq of (inDataType), dest50:Point, startingPoint51:Point, battery52:nat, counter53:nat, fields54:nat \u0026 (((((inputFileName47 \u003c\u003e []) and (outputFileName48 \u003c\u003e [])) and (battery52 \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e (forall file55:IO, inputFileName56:seq of (char), outputFileName57:seq of (char), inData58:seq of (inDataType), dest59:Point, startingPoint60:Point, battery61:nat, counter62:nat, fields63:nat \u0026 (((((inputFileName56 \u003c\u003e []) and (outputFileName57 \u003c\u003e [])) and (battery61 \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e (forall file64:IO, inputFileName65:seq of (char), outputFileName66:seq of (char), inData67:seq of (inDataType), dest68:Point, startingPoint69:Point, battery70:nat, counter71:nat, fields72:nat \u0026 (((((inputFileName65 \u003c\u003e []) and (outputFileName66 \u003c\u003e [])) and (battery70 \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e (x in set (inds routes)))))))))))))))))))","state invariant holds obligation:(forall g:Point, p:PointAvalibility \u0026 (((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e ((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0))))))","legal function application obligation:(forall g:Point, p:PointAvalibility \u0026 pre_(((file.fwriteval))[(Point * PointAvalibility)]outputFileName, mk_(g, p), \u003cappend\u003e))","state invariant holds obligation:(forall r:Route \u0026 (((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e ((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0))))))","legal function application obligation:(forall r:Route \u0026 pre_(((file.fwriteval))[Point]outputFileName, r(x), \u003cappend\u003e))","legal sequence application obligation:(forall r:Route \u0026 (x in set (inds r)))","state invariant holds obligation:(forall i:nat \u0026 (((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e ((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0))))))","legal function application obligation:(forall i:nat \u0026 pre_(((file.fwriteval))[nat]outputFileName, i, \u003cappend\u003e))","state invariant holds obligation:(forall line:seq of (char) \u0026 (((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0)))) \u003d\u003e ((((inputFileName \u003c\u003e []) and (outputFileName \u003c\u003e [])) and (battery \u003e\u003d 0)) and ((startIndex \u003e 0) and ((destIndex \u003e 0) and (batCapIndex \u003e 0))))))","legal function application obligation:(forall line:seq of (char) \u0026 pre_(((file.fwriteval))[seq of (char)]outputFileName, line, \u003cappend\u003e))","operation call obligation:(forall text:seq of (char) \u0026 ((\"\" \u003d \"\") \u003c\u003d\u003e (\"\" \u003d nil)))","non-zero obligation:(forall a:real \u0026 ((a \u003c\u003e 0) \u003d\u003e (a \u003c\u003e 0)))"]