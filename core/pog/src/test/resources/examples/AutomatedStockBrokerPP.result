["legal sequence application obligation:(forall sr:StockRecord, predefinedEvents:seq of (Event) \u0026 (let val:nat \u003d (predefinedEvents((len predefinedEvents)).Value) in IsInRegion(val, (sr.NoActionReg)) \u003d\u003e ((len predefinedEvents) in set (inds predefinedEvents))))","state invariant holds obligation:(forall sr:StockRecord, predefinedEvents:seq of (Event) \u0026 (let val:nat \u003d (predefinedEvents((len predefinedEvents)).Value) in IsInRegion(val, (sr.NoActionReg)) \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e))))))))))","state invariant holds obligation:(forall sr:StockRecord \u0026 ((((sr.Name) in set (World`stockMarket.GetStockNames)()) and let val:StockValue \u003d ((World`stockMarket.GetStock)((sr.Name)).GetCurrentValue)() in IsInRegion(val, (sr.NoActionReg))) \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e))))))))))","non-empty sequence obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (stockHistory \u003c\u003e [])))","legal sequence application obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (IsInRegion((hd stockHistory), reg) \u003d\u003e (2 in set (inds stockHistory)))))","state invariant holds obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e ((((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))) \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))))))","non-empty sequence obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (stockHistory \u003c\u003e [])))","legal sequence application obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e ((not IsInRegion((hd stockHistory), reg)) \u003d\u003e (2 in set (inds stockHistory)))))","state invariant holds obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e ((((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))) \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))))))","non-empty sequence obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (stockHistory \u003c\u003e [])))","legal sequence application obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (((hd stockHistory) \u003d u) \u003d\u003e (2 in set (inds stockHistory)))))","state invariant holds obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e ((((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))) \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))))))","non-empty sequence obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (stockHistory \u003c\u003e [])))","legal sequence application obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (((hd stockHistory) \u003d l) \u003d\u003e (2 in set (inds stockHistory)))))","state invariant holds obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e ((((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))) \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))))))","non-empty sequence obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (stockHistory \u003c\u003e [])))","state invariant holds obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e ((((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))) \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))))))","non-empty sequence obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (stockHistory \u003c\u003e [])))","state invariant holds obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e ((((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))) \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))))))","legal sequence application obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (true \u003d\u003e ((len ([mk_Event(\u003cValley\u003e, time, cv)] ^ ([mk_Event(\u003cPeak\u003e, time, cv)] ^ ([mk_Event(\u003cLowerLimit\u003e, time, cv)] ^ ([mk_Event(\u003cUpperLimit\u003e, time, cv)] ^ ([mk_Event(\u003cLeavesNoActionRegion\u003e, time, cv)] ^ ([mk_Event(\u003cEntersNoActionRegion\u003e, time, cv)] ^ eventHistory))))))) in set (inds ([mk_Event(\u003cValley\u003e, time, cv)] ^ ([mk_Event(\u003cPeak\u003e, time, cv)] ^ ([mk_Event(\u003cLowerLimit\u003e, time, cv)] ^ ([mk_Event(\u003cUpperLimit\u003e, time, cv)] ^ ([mk_Event(\u003cLeavesNoActionRegion\u003e, time, cv)] ^ ([mk_Event(\u003cEntersNoActionRegion\u003e, time, cv)] ^ eventHistory)))))))))))","legal sequence application obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (true \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e (e in set (inds eventHistory))))))))","legal sequence application obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (true \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e (((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e ((e + 1) in set (inds eventHistory)))))))))","legal sequence application obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (true \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e (((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e ((not ((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e)) \u003d\u003e ((e + 1) in set (inds eventHistory))))))))))","legal sequence application obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (true \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) \u003d\u003e (e in set (inds eventHistory)))))))))","legal sequence application obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (true \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) \u003d\u003e (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e ((e + 1) in set (inds eventHistory))))))))))","legal sequence application obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (true \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) \u003d\u003e (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e ((not ((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e)) \u003d\u003e ((e + 1) in set (inds eventHistory)))))))))))","legal sequence application obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (true \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) \u003d\u003e (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e ((not ((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e)) \u003d\u003e ((not ((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e)) \u003d\u003e ((e + 1) in set (inds eventHistory))))))))))))","operation establishes postcondition obligation:(forall time:nat \u0026 (let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2) \u003d\u003e (true \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))))))","legal map application obligation:(forall tim:nat \u0026 ((stockRecord.State) in set (dom (stockRecord.Triggers))))","state invariant holds obligation:(forall tim:nat \u0026 ((((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))) \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e))))))))))","operation call obligation:(forall time:nat \u0026 let stockHistory:seq of (StockValue) \u003d ((sm.GetStock)((stockRecord.Name)).GetValueHistory)() in ((len stockHistory) \u003e\u003d 2))","operation establishes postcondition obligation:(forall time:nat \u0026 (forall eventHistory1:seq of (Event), stockRecord2:StockRecord, sm3:[StockMarket], currentlyTriggeredAction4:[ActionType] \u0026 (((((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))) and (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e))))))))) \u003d\u003e (forall eventHistory5:seq of (Event), stockRecord6:StockRecord, sm7:[StockMarket], currentlyTriggeredAction8:[ActionType] \u0026 ((((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))) \u003d\u003e NoActiveTriggerInNoActionRegion(GetStockValue(time), (stockRecord.NoActionReg), currentlyTriggeredAction))))))","state invariant holds obligation:(forall sr:StockRecord \u0026 ((((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e)))))))) \u003d\u003e (((eventHistory((len eventHistory)).Type) \u003d \u003cEntersNoActionRegion\u003e) and (forall e in set (inds eventHistory) \u0026 ((e \u003c\u003e (len eventHistory)) \u003d\u003e ((((eventHistory(e).Type) \u003d \u003cLeavesNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLowerLimit\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cUpperLimit\u003e))) and (((eventHistory(e).Type) \u003d \u003cEntersNoActionRegion\u003e) \u003d\u003e (((eventHistory((e + 1)).Type) \u003d \u003cLeavesNoActionRegion\u003e) or (((eventHistory((e + 1)).Type) \u003d \u003cValley\u003e) or ((eventHistory((e + 1)).Type) \u003d \u003cPeak\u003e))))))))))","legal sequence application obligation:(forall time:nat \u0026 (((len eventHistory) \u003e 0) \u003d\u003e (1 in set (inds eventHistory))))","legal sequence application obligation:(forall time:nat \u0026 (((len eventHistory) \u003e 0) \u003d\u003e (((len eventHistory) - time) in set (inds eventHistory))))","non-empty sequence obligation:(forall svs:seq of (StockValue) \u0026 (svs \u003c\u003e []))","legal sequence application obligation:(forall svs:seq of (StockValue) \u0026 let current:StockValue \u003d (hd svs) in (forall i in set (inds svs) \u0026 (i in set (inds svs))))","legal sequence application obligation:(forall svs:seq of (StockValue) \u0026 let current:StockValue \u003d (hd svs) in let indicesOneAbove:set of (nat1) \u003d {i | i in set (inds svs) \u0026 (((current + 1) \u003d svs(i)) and (i \u003c\u003e (len svs)))} in (forall i in set indicesOneAbove \u0026 (forall v in set {2, ... ,i} \u0026 (v in set (inds svs)))))","legal sequence application obligation:(forall svs:seq of (StockValue) \u0026 let current:StockValue \u003d (hd svs) in let indicesOneAbove:set of (nat1) \u003d {i | i in set (inds svs) \u0026 (((current + 1) \u003d svs(i)) and (i \u003c\u003e (len svs)))} in (forall i in set indicesOneAbove \u0026 (forall v in set {2, ... ,i} \u0026 (((current + 1) \u003d svs(v)) \u003d\u003e ((i + 1) in set (inds svs))))))","non-empty sequence obligation:(forall svs:seq of (StockValue) \u0026 (svs \u003c\u003e []))","legal sequence application obligation:(forall svs:seq of (StockValue) \u0026 let current:StockValue \u003d (hd svs) in (forall i in set (inds svs) \u0026 (i in set (inds svs))))","legal sequence application obligation:(forall svs:seq of (StockValue) \u0026 let current:StockValue \u003d (hd svs) in let indicesOneBelow:set of (nat1) \u003d {i | i in set (inds svs) \u0026 (((current - 1) \u003d svs(i)) and (i \u003c\u003e (len svs)))} in (forall i in set indicesOneBelow \u0026 (forall v in set {2, ... ,i} \u0026 (v in set (inds svs)))))","legal sequence application obligation:(forall svs:seq of (StockValue) \u0026 let current:StockValue \u003d (hd svs) in let indicesOneBelow:set of (nat1) \u003d {i | i in set (inds svs) \u0026 (((current - 1) \u003d svs(i)) and (i \u003c\u003e (len svs)))} in (forall i in set indicesOneBelow \u0026 (forall v in set {2, ... ,i} \u0026 (((current - 1) \u003d svs(v)) \u003d\u003e ((i + 1) in set (inds svs))))))","legal sequence application obligation:(forall time:nat, events:seq of (Event) \u0026 (forall x in set (inds events) \u0026 (x in set (inds events))))","let be st existence obligation:(forall time:nat, events:seq of (Event) \u0026 let pastEvents:set of (nat1) \u003d {x | x in set (inds events) \u0026 ((events(x).TimeStamp) \u003c\u003d time)} in (exists i, j in set pastEvents \u0026 ((i \u003c\u003e j) \u003d\u003e ((events(i).TimeStamp) \u003c\u003d (events(j).TimeStamp)))))","legal sequence application obligation:(forall time:nat, events:seq of (Event) \u0026 let pastEvents:set of (nat1) \u003d {x | x in set (inds events) \u0026 ((events(x).TimeStamp) \u003c\u003d time)} in (forall i, j in set pastEvents \u0026 ((i \u003c\u003e j) \u003d\u003e (i in set (inds events)))))","legal sequence application obligation:(forall time:nat, events:seq of (Event) \u0026 let pastEvents:set of (nat1) \u003d {x | x in set (inds events) \u0026 ((events(x).TimeStamp) \u003c\u003d time)} in (forall i, j in set pastEvents \u0026 ((i \u003c\u003e j) \u003d\u003e (j in set (inds events)))))","legal sequence application obligation:(forall time:nat, action:ActionTrigger, eventHistory:seq of (Event) \u0026 let tgr:seq of (EventType) \u003d (action.Trigger) in let index:nat1 \u003d FindLowestIndexFromTime(time, eventHistory), s:seq of (Event) \u003d (eventHistory(index, ... ,((index + (len tgr)) - 1))) in (forall i in set (inds s) \u0026 (i in set (inds s))))","legal sequence application obligation:(forall time:nat, action:ActionTrigger, eventHistory:seq of (Event) \u0026 let tgr:seq of (EventType) \u003d (action.Trigger) in let index:nat1 \u003d FindLowestIndexFromTime(time, eventHistory), s:seq of (Event) \u003d (eventHistory(index, ... ,((index + (len tgr)) - 1))) in (forall i in set (inds s) \u0026 (i in set (inds tgr))))","legal sequence application obligation:(forall time:nat, action:ActionTrigger, eventHistory:seq of (Event) \u0026 let tgr:seq of (EventType) \u003d (action.Trigger) in let index:nat1 \u003d FindLowestIndexFromTime(time, eventHistory), s:seq of (Event) \u003d (eventHistory(index, ... ,((index + (len tgr)) - 1))) in ((forall i in set (inds s) \u0026 ((s(i).Type) \u003d tgr(i))) \u003d\u003e (1 in set (inds s))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cPotentialBuy\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cLowerLimit\u003e], \u003cBuy\u003e)}, {\u003cBought\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cUpperLimit\u003e], \u003cSell\u003e)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","type compatibility obligation:inv_Region(mk_Region(12, 8))","type compatibility obligation:inv_StockRecord(mk_StockRecord(mk_token(\"test\"), {\u003cPotentialBuy\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cLowerLimit\u003e], \u003cBuy\u003e), \u003cBought\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cUpperLimit\u003e], \u003cSell\u003e)}, mk_Region(12, 8), 10, \u003cBought\u003e))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cPotentialBuy\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cLowerLimit\u003e], \u003cBuy\u003e)}, {\u003cBought\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cUpperLimit\u003e], \u003cSell\u003e)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","type compatibility obligation:inv_Region(mk_Region(12, 8))","type compatibility obligation:inv_StockRecord(mk_StockRecord(mk_token(\"test12\"), {\u003cPotentialBuy\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cLowerLimit\u003e], \u003cBuy\u003e), \u003cBought\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cUpperLimit\u003e], \u003cSell\u003e)}, mk_Region(12, 8), 10, \u003cBought\u003e))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cPotentialBuy\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cLowerLimit\u003e], \u003cBuy\u003e)}, {\u003cBought\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cUpperLimit\u003e], \u003cSell\u003e)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","type compatibility obligation:inv_Region(mk_Region(12, 8))","type compatibility obligation:inv_StockRecord(mk_StockRecord(mk_token(\"test2\"), {\u003cPotentialBuy\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cLowerLimit\u003e], \u003cBuy\u003e), \u003cBought\u003e |-\u003e mk_ActionTrigger([\u003cLeavesNoActionRegion\u003e, \u003cUpperLimit\u003e], \u003cSell\u003e)}, mk_Region(12, 8), 0, \u003cPotentialBuy\u003e))","while loop termination obligation:...","let be st existence obligation:(forall m:map (String) to (seq of (Event)) \u0026 (exists x, y in set {(len m(x)) | x in set (dom m)} \u0026 ((x \u003c\u003e y) \u003d\u003e (x \u003c\u003d y))))","legal map application obligation:(forall m:map (String) to (seq of (Event)) \u0026 (forall x in set (dom m) \u0026 (x in set (dom m))))","state invariant holds obligation:(forall startCash:nat \u0026 ((((startCash \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)))","state invariant holds obligation:(forall sRecord:StockRecord, priority:nat1 \u0026 (((sRecord.Name) not in set {(x.Name) | x in set (elems stocks)}) \u003d\u003e (((((balance \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)) \u003d\u003e ((((balance \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)))))","state invariant holds obligation:(forall sRecord:StockRecord, priority:nat1 \u0026 (((sRecord.Name) not in set {(x.Name) | x in set (elems stocks)}) \u003d\u003e (((((balance \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)) \u003d\u003e ((((balance \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)))))","state invariant holds obligation:(forall sRecord:StockRecord, priority:nat1 \u0026 (((sRecord.Name) not in set {(x.Name) | x in set (elems stocks)}) \u003d\u003e (((((balance \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)) \u003d\u003e ((((balance \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)))))","legal map application obligation:(forall sRecord:StockRecord, priority:nat1 \u0026 (((sRecord.Name) not in set {(x.Name) | x in set (elems stocks)}) \u003d\u003e ((sRecord.Name) in set (dom testValues))))","legal sequence application obligation:(forall sRecord:StockRecord, priority:nat1 \u0026 (((sRecord.Name) not in set {(x.Name) | x in set (elems stocks)}) \u003d\u003e (((sRecord.Name) in set (dom stockWatchers)) \u003d\u003e (priority in set (inds (((stocks(1, ... ,(priority - 1))) ^ [sRecord]) ^ (stocks((priority + 1), ... ,(len stocks)))))))))","operation establishes postcondition obligation:(forall sRecord:StockRecord, priority:nat1 \u0026 (((sRecord.Name) not in set {(x.Name) | x in set (elems stocks)}) \u003d\u003e (((sRecord.Name) in set (dom stockWatchers)) and (sRecord \u003d stocks(priority)))))","legal sequence application obligation:(forall ss:StockState \u0026 (forall s in set (inds stocks) \u0026 ((((stockWatchers((stocks(s).Name)).GetTriggeredAction)() \u003c\u003e nil) and ((stocks(s).State) \u003d ss)) \u003d\u003e (s in set (inds stocks)))))","legal map application obligation:(forall ss:StockState \u0026 (forall s in set (inds stocks) \u0026 ((stocks(s).Name) in set (dom stockWatchers))))","legal sequence application obligation:(forall ss:StockState \u0026 (forall s in set (inds stocks) \u0026 (s in set (inds stocks))))","legal sequence application obligation:(forall ss:StockState \u0026 (forall s in set (inds stocks) \u0026 (((stockWatchers((stocks(s).Name)).GetTriggeredAction)() \u003c\u003e nil) \u003d\u003e (s in set (inds stocks)))))","legal sequence application obligation:(forall ss:StockState \u0026 let res:seq of (StockRecord) \u003d RESULT in (forall i in set (inds res) \u0026 (i in set (inds res))))","operation establishes postcondition obligation:(forall ss:StockState \u0026 let res:seq of (StockRecord) \u003d RESULT in (forall i in set (inds res) \u0026 ((res(i).State) \u003d ss)))","legal sequence application obligation:(forall potBuys:seq of (StockRecord), time:nat \u0026 (forall x in set (inds potBuys) \u0026 (CanAfford(potBuys(x), balance) \u003d\u003e (x in set (inds potBuys)))))","type compatibility obligation:(forall potBuys:seq of (StockRecord), time:nat \u0026 (forall x in set (inds potBuys) \u0026 (balance \u003e\u003d 0)))","legal sequence application obligation:(forall potBuys:seq of (StockRecord), time:nat \u0026 (forall x in set (inds potBuys) \u0026 (x in set (inds potBuys))))","let be st existence obligation:(forall potBuys:seq of (StockRecord), time:nat \u0026 let affordableStocks:seq of (StockRecord) \u003d [potBuys(x) | x in set (inds potBuys) \u0026 CanAfford(potBuys(x), balance)] in (((len affordableStocks) \u003e 0) \u003d\u003e (exists x in set (inds affordableStocks) \u0026 (forall y in set (inds affordableStocks) \u0026 ((stockWatchers((affordableStocks(x).Name)).GetStockValue)(time) \u003e\u003d (stockWatchers((affordableStocks(y).Name)).GetStockValue)(time))))))","legal map application obligation:(forall potBuys:seq of (StockRecord), time:nat \u0026 let affordableStocks:seq of (StockRecord) \u003d [potBuys(x) | x in set (inds potBuys) \u0026 CanAfford(potBuys(x), balance)] in (((len affordableStocks) \u003e 0) \u003d\u003e (forall x in set (inds affordableStocks) \u0026 (forall y in set (inds affordableStocks) \u0026 ((affordableStocks(x).Name) in set (dom stockWatchers))))))","legal sequence application obligation:(forall potBuys:seq of (StockRecord), time:nat \u0026 let affordableStocks:seq of (StockRecord) \u003d [potBuys(x) | x in set (inds potBuys) \u0026 CanAfford(potBuys(x), balance)] in (((len affordableStocks) \u003e 0) \u003d\u003e (forall x in set (inds affordableStocks) \u0026 (forall y in set (inds affordableStocks) \u0026 (x in set (inds affordableStocks))))))","legal map application obligation:(forall potBuys:seq of (StockRecord), time:nat \u0026 let affordableStocks:seq of (StockRecord) \u003d [potBuys(x) | x in set (inds potBuys) \u0026 CanAfford(potBuys(x), balance)] in (((len affordableStocks) \u003e 0) \u003d\u003e (forall x in set (inds affordableStocks) \u0026 (forall y in set (inds affordableStocks) \u0026 ((affordableStocks(y).Name) in set (dom stockWatchers))))))","legal sequence application obligation:(forall potBuys:seq of (StockRecord), time:nat \u0026 let affordableStocks:seq of (StockRecord) \u003d [potBuys(x) | x in set (inds potBuys) \u0026 CanAfford(potBuys(x), balance)] in (((len affordableStocks) \u003e 0) \u003d\u003e (forall x in set (inds affordableStocks) \u0026 (forall y in set (inds affordableStocks) \u0026 (y in set (inds affordableStocks))))))","legal sequence application obligation:(forall potBuys:seq of (StockRecord), time:nat \u0026 let affordableStocks:seq of (StockRecord) \u003d [potBuys(x) | x in set (inds potBuys) \u0026 CanAfford(potBuys(x), balance)] in (((len affordableStocks) \u003e 0) \u003d\u003e (forall x in set (inds affordableStocks) \u0026 ((forall y in set (inds affordableStocks) \u0026 ((stockWatchers((affordableStocks(x).Name)).GetStockValue)(time) \u003e\u003d (stockWatchers((affordableStocks(y).Name)).GetStockValue)(time))) \u003d\u003e (x in set (inds affordableStocks))))))","let be st existence obligation:(forall potSells:seq of (StockRecord), time:nat \u0026 (((len potSells) \u003e 0) \u003d\u003e (exists x in set (inds potSells) \u0026 (forall y in set (inds potSells) \u0026 (((stockWatchers((potSells(x).Name)).GetStockValue)(time) - (potSells(x).Cost)) \u003e\u003d ((stockWatchers((potSells(y).Name)).GetStockValue)(time) - (potSells(y).Cost)))))))","legal map application obligation:(forall potSells:seq of (StockRecord), time:nat \u0026 (((len potSells) \u003e 0) \u003d\u003e (forall x in set (inds potSells) \u0026 (forall y in set (inds potSells) \u0026 ((potSells(x).Name) in set (dom stockWatchers))))))","legal sequence application obligation:(forall potSells:seq of (StockRecord), time:nat \u0026 (((len potSells) \u003e 0) \u003d\u003e (forall x in set (inds potSells) \u0026 (forall y in set (inds potSells) \u0026 (x in set (inds potSells))))))","legal sequence application obligation:(forall potSells:seq of (StockRecord), time:nat \u0026 (((len potSells) \u003e 0) \u003d\u003e (forall x in set (inds potSells) \u0026 (forall y in set (inds potSells) \u0026 (x in set (inds potSells))))))","legal map application obligation:(forall potSells:seq of (StockRecord), time:nat \u0026 (((len potSells) \u003e 0) \u003d\u003e (forall x in set (inds potSells) \u0026 (forall y in set (inds potSells) \u0026 ((potSells(y).Name) in set (dom stockWatchers))))))","legal sequence application obligation:(forall potSells:seq of (StockRecord), time:nat \u0026 (((len potSells) \u003e 0) \u003d\u003e (forall x in set (inds potSells) \u0026 (forall y in set (inds potSells) \u0026 (y in set (inds potSells))))))","legal sequence application obligation:(forall potSells:seq of (StockRecord), time:nat \u0026 (((len potSells) \u003e 0) \u003d\u003e (forall x in set (inds potSells) \u0026 (forall y in set (inds potSells) \u0026 (y in set (inds potSells))))))","legal sequence application obligation:(forall potSells:seq of (StockRecord), time:nat \u0026 (((len potSells) \u003e 0) \u003d\u003e (forall x in set (inds potSells) \u0026 ((forall y in set (inds potSells) \u0026 (((stockWatchers((potSells(x).Name)).GetStockValue)(time) - (potSells(x).Cost)) \u003e\u003d ((stockWatchers((potSells(y).Name)).GetStockValue)(time) - (potSells(y).Cost)))) \u003d\u003e (x in set (inds potSells))))))","legal map application obligation:(forall potSells:seq of (StockRecord), time:nat \u0026 (((len potSells) \u003e 0) \u003d\u003e ((RESULT.Name) in set (dom stockWatchers))))","legal map application obligation:(forall potSells:seq of (StockRecord), time:nat \u0026 (((len potSells) \u003e 0) \u003d\u003e (forall x in set (elems potSells) \u0026 ((x.Name) in set (dom stockWatchers)))))","operation establishes postcondition obligation:(forall potSells:seq of (StockRecord), time:nat \u0026 (((len potSells) \u003e 0) \u003d\u003e IsGTAll(((stockWatchers((RESULT.Name)).GetStockValue)(time) - (RESULT.Cost)), {((stockWatchers((x.Name)).GetStockValue)(time) - (x.Cost)) | x in set (elems potSells)})))","legal map application obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cPotentialBuy\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cBuy\u003e)) \u003d\u003e (((potAction.State) \u003d \u003cPotentialBuy\u003e) \u003d\u003e ((potAction.Name) in set (dom stockWatchers)))))","legal map application obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cPotentialBuy\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cBuy\u003e)) \u003d\u003e ((potAction.Name) in set (dom stockWatchers))))","state invariant holds obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cPotentialBuy\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cBuy\u003e)) \u003d\u003e (((((balance \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)) \u003d\u003e ((((balance \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)))))","state invariant holds obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cPotentialBuy\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cBuy\u003e)) \u003d\u003e (((((balance \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)) \u003d\u003e (((((balance - value) \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)))))","let be st existence obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cPotentialBuy\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cBuy\u003e)) \u003d\u003e (exists i in set (inds stocks) \u0026 ((stocks(i).Name) \u003d (potAction.Name)))))","legal sequence application obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cPotentialBuy\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cBuy\u003e)) \u003d\u003e (i in set (inds stocks))))","state invariant holds obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cPotentialBuy\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cBuy\u003e)) \u003d\u003e ((((((balance - value) \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)) \u003d\u003e (((((balance - value) \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)))))","legal sequence application obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cPotentialBuy\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cBuy\u003e)) \u003d\u003e ((i \u003e 0) and (i \u003c\u003d ((len stocks) + 1)))))","legal sequence application obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cPotentialBuy\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cBuy\u003e)) \u003d\u003e (i in set (inds stocks))))","operation establishes postcondition obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cPotentialBuy\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cBuy\u003e)) \u003d\u003e ((balance - value) \u003e\u003d 0)))","legal map application obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cBought\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cSell\u003e)) \u003d\u003e (((potAction.State) \u003d \u003cBought\u003e) \u003d\u003e ((potAction.Name) in set (dom stockWatchers)))))","legal map application obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cBought\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cSell\u003e)) \u003d\u003e ((potAction.Name) in set (dom stockWatchers))))","state invariant holds obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cBought\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cSell\u003e)) \u003d\u003e (((((balance \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)) \u003d\u003e ((((balance \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)))))","state invariant holds obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cBought\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cSell\u003e)) \u003d\u003e (((((balance \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)) \u003d\u003e (((((balance + value) \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)))))","let be st existence obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cBought\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cSell\u003e)) \u003d\u003e (exists i in set (inds stocks) \u0026 ((stocks(i).Name) \u003d (potAction.Name)))))","legal sequence application obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cBought\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cSell\u003e)) \u003d\u003e (i in set (inds stocks))))","state invariant holds obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cBought\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cSell\u003e)) \u003d\u003e ((((((balance + value) \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)) \u003d\u003e (((((balance + value) \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)))))","legal sequence application obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cBought\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cSell\u003e)) \u003d\u003e ((i \u003e 0) and (i \u003c\u003d ((len stocks) + 1)))))","legal sequence application obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cBought\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cSell\u003e)) \u003d\u003e (i in set (inds stocks))))","operation establishes postcondition obligation:(forall potAction:StockRecord, time:nat \u0026 ((((potAction.State) \u003d \u003cBought\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cSell\u003e)) \u003d\u003e ((balance + value) \u003e\u003d 0)))","legal sequence application obligation:(forall time:nat \u0026 (i in set (inds stocks)))","legal map application obligation:(forall time:nat \u0026 ((stock.Name) in set (dom stockWatchers)))","operation call obligation:(forall time:nat \u0026 (forall stocks1:seq of (StockRecord), stockWatchers2:map (StockIdentifier) to (StockWatcher), actionLog3:seq of (ActionEvent), balance4:int \u0026 (((((balance4 \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)) \u003d\u003e (((FindValidSell(potSells, time).State) \u003d \u003cBought\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cSell\u003e)))))","operation call obligation:(forall time:nat \u0026 (forall stocks1:seq of (StockRecord), stockWatchers2:map (StockIdentifier) to (StockWatcher), actionLog3:seq of (ActionEvent), balance4:int \u0026 (((((balance4 \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)) \u003d\u003e (forall stocks21:seq of (StockRecord), stockWatchers22:map (StockIdentifier) to (StockWatcher), actionLog23:seq of (ActionEvent), balance24:int \u0026 (((balance24 \u003e\u003d 0) and ((((balance24 \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog))) \u003d\u003e (true \u003d\u003e (true \u003d\u003e (((validBuy.State) \u003d \u003cPotentialBuy\u003e) and ((stockWatchers((potAction.Name)).GetTriggeredAction)() \u003d \u003cBuy\u003e)))))))))","operation establishes postcondition obligation:(forall time:nat \u0026 (forall stocks1:seq of (StockRecord), stockWatchers2:map (StockIdentifier) to (StockWatcher), actionLog3:seq of (ActionEvent), balance4:int \u0026 (((((balance4 \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog)) \u003d\u003e (forall stocks21:seq of (StockRecord), stockWatchers22:map (StockIdentifier) to (StockWatcher), actionLog23:seq of (ActionEvent), balance24:int \u0026 (((balance24 \u003e\u003d 0) and ((((balance24 \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog))) \u003d\u003e (true \u003d\u003e (true \u003d\u003e (forall stocks25:seq of (StockRecord), stockWatchers26:map (StockIdentifier) to (StockWatcher), actionLog27:seq of (ActionEvent), balance28:int \u0026 (((balance28 \u003e\u003d 0) and ((((balance28 \u003e\u003d 0) and (forall x, y in set (inds stocks) \u0026 ((x \u003c\u003e y) \u003d\u003e ((stocks(x).Name) \u003c\u003e (stocks(y).Name))))) and let stockIdentifiers:set of (StockIdentifier) \u003d {(si.Name) | si in set (elems stocks)} in (forall stockIdentifier in set stockIdentifiers \u0026 let allEventsStock:seq of (ActionEvent) \u003d [actionLog(i) | i in set (inds actionLog) \u0026 ((actionLog(i).StockName) \u003d stockIdentifier)] in (forall e in set (inds allEventsStock) \u0026 ((e \u003c\u003e (len allEventsStock)) \u003d\u003e ((allEventsStock(e).Type) \u003c\u003e (allEventsStock((e + 1)).Type)))))) and MaxOneOfEachActionTypePerTime(actionLog))) \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e MaxOneOfEachActionTypePerTime(actionLog))))))))))))))))))))","legal sequence application obligation:(forall actionLog:seq of (ActionEvent) \u0026 (forall x, y in set (inds actionLog) \u0026 ((x \u003c\u003e y) \u003d\u003e (x in set (inds actionLog)))))","legal sequence application obligation:(forall actionLog:seq of (ActionEvent) \u0026 (forall x, y in set (inds actionLog) \u0026 ((x \u003c\u003e y) \u003d\u003e (y in set (inds actionLog)))))","legal sequence application obligation:(forall actionLog:seq of (ActionEvent) \u0026 (forall x, y in set (inds actionLog) \u0026 (((x \u003c\u003e y) and ((actionLog(x).Time) \u003d (actionLog(y).Time))) \u003d\u003e (x in set (inds actionLog)))))","legal sequence application obligation:(forall actionLog:seq of (ActionEvent) \u0026 (forall x, y in set (inds actionLog) \u0026 (((x \u003c\u003e y) and ((actionLog(x).Time) \u003d (actionLog(y).Time))) \u003d\u003e (y in set (inds actionLog)))))","type invariant satisfiable obligation:(exists mk_Region(p1, p2):Region \u0026 (p1 \u003e\u003d p2))","legal map application obligation:(forall mk_StockRecord(p1, p2, p3, p4, p5):StockRecord \u0026 (\u003cPotentialBuy\u003e in set (dom p2)))","legal map application obligation:(forall mk_StockRecord(p1, p2, p3, p4, p5):StockRecord \u0026 (((p2(\u003cPotentialBuy\u003e).Action) \u003d \u003cBuy\u003e) \u003d\u003e (\u003cBought\u003e in set (dom p2))))","type invariant satisfiable obligation:(exists mk_StockRecord(p1, p2, p3, p4, p5):StockRecord \u0026 (((p2(\u003cPotentialBuy\u003e).Action) \u003d \u003cBuy\u003e) and ((p2(\u003cBought\u003e).Action) \u003d \u003cSell\u003e)))","enumeration map injectivity obligation:(forall m1, m2 in set {{mk_token(\"test\") |-\u003e [mk_Event(\u003cLeavesNoActionRegion\u003e, 6, 5), mk_Event(\u003cLowerLimit\u003e, 5, 8), mk_Event(\u003cUpperLimit\u003e, 4, 12), mk_Event(\u003cEntersNoActionRegion\u003e, 3, 11), mk_Event(\u003cLeavesNoActionRegion\u003e, 2, 13), mk_Event(\u003cUpperLimit\u003e, 1, 12), mk_Event(\u003cEntersNoActionRegion\u003e, 0, 10)]}, {mk_token(\"test12\") |-\u003e [mk_Event(\u003cLeavesNoActionRegion\u003e, 6, 5), mk_Event(\u003cLowerLimit\u003e, 5, 8), mk_Event(\u003cUpperLimit\u003e, 4, 12), mk_Event(\u003cEntersNoActionRegion\u003e, 3, 11), mk_Event(\u003cLeavesNoActionRegion\u003e, 2, 16), mk_Event(\u003cUpperLimit\u003e, 1, 12), mk_Event(\u003cEntersNoActionRegion\u003e, 0, 10)]}, {mk_token(\"test2\") |-\u003e [mk_Event(\u003cLeavesNoActionRegion\u003e, 6, 5), mk_Event(\u003cUpperLimit\u003e, 5, 8), mk_Event(\u003cLowerLimit\u003e, 4, 8), mk_Event(\u003cEntersNoActionRegion\u003e, 3, 11), mk_Event(\u003cLeavesNoActionRegion\u003e, 2, 6), mk_Event(\u003cLowerLimit\u003e, 1, 8), mk_Event(\u003cEntersNoActionRegion\u003e, 0, 10)]}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","non-empty sequence obligation:(((len valueHistory) \u003e\u003d 1) \u003d\u003e ((nil \u003d currentRateOfChange) \u003d\u003e (valueHistory \u003c\u003e [])))","type compatibility obligation:(((len valueHistory) \u003e\u003d 1) \u003d\u003e ((not (nil \u003d currentRateOfChange)) \u003d\u003e ((is_(currentRateOfChange, \u003cconstant\u003e) or is_(currentRateOfChange, \u003cnegative\u003e)) or is_(currentRateOfChange, \u003cpositive\u003e))))","non-empty sequence obligation:(((len valueHistory) \u003e\u003d 1) \u003d\u003e ((not (nil \u003d currentRateOfChange)) \u003d\u003e (valueHistory \u003c\u003e [])))","non-empty sequence obligation:(((len valueHistory) \u003e\u003d 1) \u003d\u003e (valueHistory \u003c\u003e []))","non-empty sequence obligation:(((len valueHistory) \u003e\u003d 1) \u003d\u003e (([((hd valueHistory) + 1)] ^ valueHistory) \u003c\u003e []))","type compatibility obligation:(((len valueHistory) \u003e\u003d 1) \u003d\u003e is_(([((hd valueHistory) - 1)] ^ valueHistory), seq of (StockValue)))","non-empty sequence obligation:(((len valueHistory) \u003e\u003d 1) \u003d\u003e (([((hd valueHistory) - 1)] ^ ([((hd valueHistory) + 1)] ^ valueHistory)) \u003c\u003e []))","legal sequence application obligation:(((len valueHistory) \u003e\u003d 1) \u003d\u003e (((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cpositive\u003e) \u003d\u003e (1 in set (inds ([(hd valueHistory)] ^ ([((hd valueHistory) - 1)] ^ ([((hd valueHistory) + 1)] ^ valueHistory)))))))","legal sequence application obligation:(((len valueHistory) \u003e\u003d 1) \u003d\u003e (((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cpositive\u003e) \u003d\u003e (2 in set (inds ([(hd valueHistory)] ^ ([((hd valueHistory) - 1)] ^ ([((hd valueHistory) + 1)] ^ valueHistory)))))))","legal sequence application obligation:(((len valueHistory) \u003e\u003d 1) \u003d\u003e ((((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cpositive\u003e) \u003d\u003e (valueHistory(1) \u003e valueHistory(2))) \u003d\u003e (((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cnegative\u003e) \u003d\u003e (1 in set (inds ([(hd valueHistory)] ^ ([((hd valueHistory) - 1)] ^ ([((hd valueHistory) + 1)] ^ valueHistory))))))))","legal sequence application obligation:(((len valueHistory) \u003e\u003d 1) \u003d\u003e ((((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cpositive\u003e) \u003d\u003e (valueHistory(1) \u003e valueHistory(2))) \u003d\u003e (((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cnegative\u003e) \u003d\u003e (2 in set (inds ([(hd valueHistory)] ^ ([((hd valueHistory) - 1)] ^ ([((hd valueHistory) + 1)] ^ valueHistory))))))))","legal sequence application obligation:(((len valueHistory) \u003e\u003d 1) \u003d\u003e ((((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cpositive\u003e) \u003d\u003e (valueHistory(1) \u003e valueHistory(2))) \u003d\u003e ((((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cnegative\u003e) \u003d\u003e (valueHistory(1) \u003c valueHistory(2))) \u003d\u003e (((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cconstant\u003e) \u003d\u003e (1 in set (inds ([(hd valueHistory)] ^ ([((hd valueHistory) - 1)] ^ ([((hd valueHistory) + 1)] ^ valueHistory)))))))))","legal sequence application obligation:(((len valueHistory) \u003e\u003d 1) \u003d\u003e ((((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cpositive\u003e) \u003d\u003e (valueHistory(1) \u003e valueHistory(2))) \u003d\u003e ((((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cnegative\u003e) \u003d\u003e (valueHistory(1) \u003c valueHistory(2))) \u003d\u003e (((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cconstant\u003e) \u003d\u003e (2 in set (inds ([(hd valueHistory)] ^ ([((hd valueHistory) - 1)] ^ ([((hd valueHistory) + 1)] ^ valueHistory)))))))))","non-empty sequence obligation:(((len valueHistory) \u003e\u003d 1) \u003d\u003e ((((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cpositive\u003e) \u003d\u003e (valueHistory(1) \u003e valueHistory(2))) \u003d\u003e ((((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cnegative\u003e) \u003d\u003e (valueHistory(1) \u003c valueHistory(2))) \u003d\u003e ((((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cconstant\u003e) \u003d\u003e (valueHistory(1) \u003d valueHistory(2))) \u003d\u003e (([(hd valueHistory)] ^ ([((hd valueHistory) - 1)] ^ ([((hd valueHistory) + 1)] ^ valueHistory))) \u003c\u003e [])))))","operation establishes postcondition obligation:(((len valueHistory) \u003e\u003d 1) \u003d\u003e ((((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cpositive\u003e) \u003d\u003e (valueHistory(1) \u003e valueHistory(2))) and ((((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cnegative\u003e) \u003d\u003e (valueHistory(1) \u003c valueHistory(2))) and ((((cases currentRateOfChange :\nnil -\u003e InitialRateOfChange((hd valueHistory))\nothers NextRateOfChange(currentRateOfChange, (hd valueHistory))\n end) \u003d \u003cconstant\u003e) \u003d\u003e (valueHistory(1) \u003d valueHistory(2))) and ((hd ([(hd valueHistory)] ^ ([((hd valueHistory) - 1)] ^ ([((hd valueHistory) + 1)] ^ valueHistory)))) \u003e\u003d 0)))))","non-empty sequence obligation:(valueHistory \u003c\u003e [])","cases exhaustive obligation:(forall sv:StockValue \u0026 let r:int \u003d (MATH`rand(21) mod 3) in ((sv \u003e 0) \u003d\u003e (((r \u003d 0) or (r \u003d 1)) or (r \u003d 2))))","cases exhaustive obligation:(forall sv:StockValue \u0026 let r:int \u003d (MATH`rand(21) mod 3) in ((not (sv \u003e 0)) \u003d\u003e (((r \u003d 0) or (r \u003d 1)) or (r \u003d 2))))","finite set obligation:(forall roc:RateOfChange, sv:StockValue \u0026 (exists finmap1:map (nat) to (RateOfChange) \u0026 (forall x:RateOfChange \u0026 (((x \u003c\u003e roc) and ((x \u003d \u003cnegative\u003e) \u003d\u003e (sv \u003e 0))) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d x))))))","legal sequence application obligation:(forall roc:RateOfChange, sv:StockValue \u0026 let r:int \u003d MATH`rand(10), other:seq of (RateOfChange) \u003d MakelistFromSet({x | x:RateOfChange \u0026 ((x \u003c\u003e roc) and ((x \u003d \u003cnegative\u003e) \u003d\u003e (sv \u003e 0)))}) in ((not ((r \u003e\u003d 0) and ((r \u003c\u003d 7) and ((roc \u003d \u003cnegative\u003e) \u003d\u003e (sv \u003e 0))))) \u003d\u003e (((MATH`rand(20) mod (len other)) + 1) in set (inds other))))","let be st existence obligation:(forall roc:set of (RateOfChange) \u0026 (((card roc) \u003e 0) \u003d\u003e (exists r in set roc \u0026 true)))","map compatible obligation:(forall stock:Stock \u0026 (((stock.GetName)() not in set (dom stocks)) \u003d\u003e (forall ldom1 in set (dom {(stock.GetName)() |-\u003e stock}), rdom2 in set (dom stocks) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e ({(stock.GetName)() |-\u003e stock}(ldom1) \u003d stocks(rdom2))))))","operation establishes postcondition obligation:(forall stock:Stock \u0026 (((stock.GetName)() not in set (dom stocks)) \u003d\u003e ((stock.GetName)() in set (dom ({(stock.GetName)() |-\u003e stock} munion stocks)))))","operation establishes postcondition obligation:(forall stock:Stock \u0026 (((stock.GetName)() in set (dom stocks)) \u003d\u003e ((stock.GetName)() not in set (dom ({(stock.GetName)()} \u003c-: stocks)))))","legal map application obligation:(forall name:StockIdentifier \u0026 ((name in set (dom stocks)) \u003d\u003e (name in set (dom stocks))))","operation call obligation:(forall text:seq of (char) \u0026 ((\"\" \u003d \"\") \u003c\u003d\u003e (\"\" \u003d nil)))","non-zero obligation:(forall a:real \u0026 ((a \u003c\u003e 0) \u003d\u003e (a \u003c\u003e 0)))"]