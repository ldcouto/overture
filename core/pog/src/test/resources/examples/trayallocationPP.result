["legal function application obligation:(forall fname:seq1 of (char) \u0026 pre_(((io.freadval))[InputTP]fname))","type compatibility obligation:(forall fname:seq1 of (char) \u0026 (timeval \u003e\u003d 0))","type compatibility obligation:inv_UID(0)","comprehension map injectivity obligation:(forall e:SorterEnviroment \u0026 (forall m1, m2 in set {{num |-\u003e new Tray(num)} | num in set {1, ... ,NumOfTrays}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:(forall e:SorterEnviroment \u0026 is_({num |-\u003e new Tray(num) | num in set {1, ... ,NumOfTrays}}, inmap (UID) to (Tray)))","state invariant holds obligation:(forall e:SorterEnviroment \u0026 ((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len [new InductionController(self, num) | num in set {1, ... ,NumOfInductions}]) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom {num |-\u003e new Tray(num) | num in set {1, ... ,NumOfTrays}})) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom {num |-\u003e new Tray(num) | num in set {1, ... ,NumOfTrays}})))))","state invariant holds obligation:(forall uid:UID, state:State \u0026 ((uid in set (dom sorterRing)) \u003d\u003e (((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom sorterRing)))) \u003d\u003e ((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((uid \u003e 0) \u003d\u003e (uid in set (dom sorterRing)))))))","state invariant holds obligation:(forall uid:UID, state:State \u0026 ((uid in set (dom sorterRing)) \u003d\u003e (((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((uid \u003e 0) \u003d\u003e (uid in set (dom sorterRing)))) \u003d\u003e ((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((uid \u003e 0) \u003d\u003e (uid in set (dom sorterRing)))))))","state invariant holds obligation:(forall ic:InductionController, item:Item \u0026 (((ic in set (elems inductionGroup)) and ((item.GetSizeOfTrays)() \u003c\u003d 2)) \u003d\u003e (((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom sorterRing)))) \u003d\u003e ((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom sorterRing)))))))","state invariant holds obligation:(forall ic:InductionController, item:Item \u0026 (((ic in set (elems inductionGroup)) and ((item.GetSizeOfTrays)() \u003c\u003d 2)) \u003d\u003e (((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom sorterRing)))) \u003d\u003e ((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom sorterRing)))))))","state invariant holds obligation:(forall ic:InductionController, item:Item \u0026 (((ic in set (elems inductionGroup)) and ((item.GetSizeOfTrays)() \u003c\u003d 2)) \u003d\u003e (((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom sorterRing)))) \u003d\u003e ((((((NumOfTrays \u003e (InductionSeperation * NumOfInductions)) and ((len inductionGroup) \u003d NumOfInductions)) and (forall id in set (inds inductionGroup) \u0026 ((inductionGroup(id).GetId)() \u003d id))) and ((card (dom sorterRing)) \u003d NumOfTrays)) and (forall id in set (dom sorterRing) \u0026 ((sorterRing(id).GetId)() \u003d id))) and ((trayAtCardReader \u003e 0) \u003d\u003e (trayAtCardReader in set (dom sorterRing)))))))","operation call obligation:(forall ic:InductionController, item:Item \u0026 (((ic in set (elems inductionGroup)) and ((item.GetSizeOfTrays)() \u003c\u003d 2)) \u003d\u003e (true \u003d\u003e ((item \u003c\u003e {}) and (forall t in set trays \u0026 (t.IsTrayEmpty)())))))","legal map application obligation:(forall id in set (dom sorterRing) \u0026 (id in set (dom sorterRing)))","non-zero obligation:(forall steps:nat, trays:set of (Tray), items:nat \u0026 ((trays \u003c\u003e {}) \u003d\u003e (SorterEnviroment`Speed \u003c\u003e 0)))","non-zero obligation:(forall steps:nat, trays:set of (Tray), items:nat \u0026 ((trays \u003c\u003e {}) \u003d\u003e (runTime \u003c\u003e 0)))","legal map application obligation:(forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (posTray in set (dom (trayAllocator.sorterRing)))))","legal map application obligation:(forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (((trayAllocator.sorterRing)(posTray).IsTrayEmpty)() \u003d\u003e (posTrayNext in set (dom (trayAllocator.sorterRing))))))","type compatibility obligation:(forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (((trayAllocator.sorterRing)(posTray).IsTrayEmpty)() \u003d\u003e (inv_UID(posTrayNext) and is_(posTrayNext, nat)))))","legal map application obligation:(forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (posTray in set (dom (trayAllocator.sorterRing)))))","legal map application obligation:(forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (posTrayNext in set (dom (trayAllocator.sorterRing)))))","type compatibility obligation:(forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (inv_UID(posTrayNext) and is_(posTrayNext, nat))))","legal sequence application obligation:(test in set (inds testfiles))","legal sequence application obligation:(true \u003d\u003e (test in set (inds testfiles)))","while loop termination obligation:...","type compatibility obligation:(forall val:nat \u0026 (((x1 mod 10) + 1) \u003e\u003d 0))","legal sequence application obligation:(forall val:nat \u0026 (((x1 mod 10) + 1) in set (inds numeric)))","type compatibility obligation:(forall val:nat \u0026 ((x1 div 10) \u003e\u003d 0))","type invariant satisfiable obligation:(exists u:UID \u0026 (u \u003c\u003d TrayAllocator`NumOfTrays))","state invariant holds obligation:(forall i:UID \u0026 ((item \u003c\u003e nil) \u003d\u003e (state \u003d \u003cFull\u003e)))","state invariant holds obligation:(forall s:State \u0026 (((item \u003c\u003e nil) \u003d\u003e (state \u003d \u003cFull\u003e)) \u003d\u003e ((nil \u003c\u003e nil) \u003d\u003e (state \u003d \u003cFull\u003e))))","state invariant holds obligation:(forall s:State \u0026 (((nil \u003c\u003e nil) \u003d\u003e (state \u003d \u003cFull\u003e)) \u003d\u003e ((nil \u003c\u003e nil) \u003d\u003e (s \u003d \u003cFull\u003e))))","state invariant holds obligation:(((item \u003c\u003e nil) \u003d\u003e (state \u003d \u003cFull\u003e)) \u003d\u003e ((i \u003c\u003e nil) \u003d\u003e (\u003cFull\u003e \u003d \u003cFull\u003e)))","type invariant satisfiable obligation:(exists it:ItemTraySize \u0026 (it \u003c\u003d ItemMaxTrays))","non-zero obligation:(forall s:nat1, i:nat \u0026 (Tray`TraySize \u003c\u003e 0))","type compatibility obligation:(forall s:nat1, i:nat \u0026 (inv_ItemTraySize(((size div Tray`TraySize) + 1)) and is_(((size div Tray`TraySize) + 1), nat1)))","state invariant holds obligation:(forall s:nat1, i:nat \u0026 ((s \u003e\u003d ItemMinSize) and (s \u003c\u003d ItemMaxSize)))","state invariant holds obligation:(forall tray:Tray \u0026 (((size \u003e\u003d ItemMinSize) and (size \u003c\u003d ItemMaxSize)) \u003d\u003e ((size \u003e\u003d ItemMinSize) and (size \u003c\u003d ItemMaxSize))))","operation postcondition satisfiable obligation:(exists newself:Item \u0026 post_RemoveItemFromTray(oldself, newself))","type compatibility obligation:(forall a:TrayAllocator, n:nat \u0026 (n \u003e 0))","state invariant holds obligation:(forall a:TrayAllocator, n:nat \u0026 ((priority \u003e 0) \u003d\u003e ((len items) \u003e 0)))","non-empty sequence obligation:(items \u003c\u003e [])","state invariant holds obligation:(forall i:Item \u0026 (((priority \u003e 0) \u003d\u003e ((len items) \u003e 0)) \u003d\u003e ((priority \u003e 0) \u003d\u003e ((len (items ^ [i])) \u003e 0))))","state invariant holds obligation:(((priority \u003e 0) \u003d\u003e ((len items) \u003e 0)) \u003d\u003e ((priority \u003e 0) \u003d\u003e ((len items) \u003e 0)))","state invariant holds obligation:(forall priority6:nat, id7:nat1, allocator8:TrayAllocator, items9:seq of (Item), stepCount10:nat \u0026 (((priority6 \u003e 0) \u003d\u003e ((len items9) \u003e 0)) \u003d\u003e (((priority6 \u003e 0) \u003d\u003e ((len items9) \u003e 0)) \u003d\u003e ((priority6 \u003e 0) \u003d\u003e ((len items9) \u003e 0)))))","non-empty sequence obligation:(items \u003c\u003e [])","state invariant holds obligation:(((priority \u003e 0) \u003d\u003e ((len items) \u003e 0)) \u003d\u003e ((0 \u003e 0) \u003d\u003e ((len (tl items)) \u003e 0)))","state invariant holds obligation:(((0 \u003e 0) \u003d\u003e ((len (tl items)) \u003e 0)) \u003d\u003e (((0 + 1) \u003e 0) \u003d\u003e ((len (tl items)) \u003e 0)))","type compatibility obligation:(forall trayAtCardReader:UID, icid:nat \u0026 (inv_UID((((trayAtCardReader + (icid * TrayAllocator`InductionSeperation)) mod TrayAllocator`NumOfTrays) + 1)) and is_((((trayAtCardReader + (icid * TrayAllocator`InductionSeperation)) mod TrayAllocator`NumOfTrays) + 1), nat)))","legal map application obligation:(forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (posTray in set (dom (trayAllocator.sorterRing)))))","legal map application obligation:(forall icid:nat \u0026 ((icid in set (inds (trayAllocator.inductionGroup))) \u003d\u003e (posTray in set (dom (trayAllocator.sorterRing)))))","operation call obligation:(forall text:seq of (char) \u0026 ((\"\" \u003d \"\") \u003c\u003d\u003e (\"\" \u003d nil)))"]