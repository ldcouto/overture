["value binding obligation:(forall node:Nodes_Node \u0026 ((is_(node, Nodes_SingleLink) or (is_(node, Nodes_DoubleLink) or is_(node, Nodes_BinaryTree))) \u003d\u003e ((not is_(node, Nodes_SingleLink)) \u003d\u003e ((not is_(node, Nodes_DoubleLink)) \u003d\u003e (exists mk_Nodes_BinaryTree(data, -, -, -):Nodes_Node \u0026 (mk_Nodes_BinaryTree(data, any1, any2, any3) \u003d node))))))","type compatibility obligation:(forall node:Nodes_Node \u0026 ((is_(node, Nodes_SingleLink) or (is_(node, Nodes_DoubleLink) or is_(node, Nodes_BinaryTree))) \u003d\u003e ((not is_(node, Nodes_SingleLink)) \u003d\u003e ((not is_(node, Nodes_DoubleLink)) \u003d\u003e is_(node, Nodes_BinaryTree)))))","value binding obligation:(forall node:Nodes_Node, data:Nodes_Data \u0026 ((is_(node, Nodes_SingleLink) or (is_(node, Nodes_DoubleLink) or is_(node, Nodes_BinaryTree))) \u003d\u003e ((not is_(node, Nodes_SingleLink)) \u003d\u003e ((not is_(node, Nodes_DoubleLink)) \u003d\u003e (exists mk_Nodes_BinaryTree(-, right, left, parent):Nodes_Node \u0026 (mk_Nodes_BinaryTree(any1, right, left, parent) \u003d node))))))","type compatibility obligation:(forall node:Nodes_Node, data:Nodes_Data \u0026 ((is_(node, Nodes_SingleLink) or (is_(node, Nodes_DoubleLink) or is_(node, Nodes_BinaryTree))) \u003d\u003e ((not is_(node, Nodes_SingleLink)) \u003d\u003e ((not is_(node, Nodes_DoubleLink)) \u003d\u003e is_(node, Nodes_BinaryTree)))))","value binding obligation:(forall node:Nodes_Node \u0026 ((is_(node, Nodes_SingleLink) or is_(node, Nodes_DoubleLink)) \u003d\u003e ((not is_(node, Nodes_SingleLink)) \u003d\u003e (exists mk_Nodes_DoubleLink(-, next, -):Nodes_Node \u0026 (mk_Nodes_DoubleLink(any1, next, any2) \u003d node)))))","type compatibility obligation:(forall node:Nodes_Node \u0026 ((is_(node, Nodes_SingleLink) or is_(node, Nodes_DoubleLink)) \u003d\u003e ((not is_(node, Nodes_SingleLink)) \u003d\u003e is_(node, Nodes_DoubleLink))))","value binding obligation:(forall node:Nodes_Node, next:Nodes_NodePtr \u0026 ((is_(node, Nodes_SingleLink) or is_(node, Nodes_DoubleLink)) \u003d\u003e ((not is_(node, Nodes_SingleLink)) \u003d\u003e (exists mk_Nodes_DoubleLink(data, -, prev):Nodes_Node \u0026 (mk_Nodes_DoubleLink(data, any1, prev) \u003d node)))))","type compatibility obligation:(forall node:Nodes_Node, next:Nodes_NodePtr \u0026 ((is_(node, Nodes_SingleLink) or is_(node, Nodes_DoubleLink)) \u003d\u003e ((not is_(node, Nodes_SingleLink)) \u003d\u003e is_(node, Nodes_DoubleLink))))","type invariant satisfiable obligation:(exists mk_Heaps_Location(d, a):Heaps_Location \u0026 ((a \u003d true) \u003c\u003d\u003e (d \u003c\u003e nil)))","type invariant satisfiable obligation:(exists mk_Heaps_Heap(s):Heaps_Heap \u0026 ((len s) \u003d Heaps_Size))","type compatibility obligation:(forall length:nat1 \u0026 ((length \u003e 1) \u003d\u003e inv_Heaps_Location(mk_Heaps_Location(nil, false))))","type compatibility obligation:(forall length:nat1 \u0026 ((length \u003e 1) \u003d\u003e ((length - 1) \u003e 0)))","type compatibility obligation:(forall length:nat1 \u0026 ((not (length \u003e 1)) \u003d\u003e inv_Heaps_Location(mk_Heaps_Location(nil, false))))","type compatibility obligation:inv_Heaps_Heap(mk_Heaps_Heap(Heaps_InitSequence(Heaps_Size)))","legal sequence application obligation:(forall heap:Heaps_Heap \u0026 let store:seq of (Heaps_Location) \u003d (heap.storage) in (forall i in set (inds store) \u0026 (((store(i).allocated) \u003d true) \u003d\u003e (i in set (inds store)))))","legal sequence application obligation:(forall heap:Heaps_Heap \u0026 let store:seq of (Heaps_Location) \u003d (heap.storage) in (forall i in set (inds store) \u0026 (i in set (inds store))))","sequence modification obligation:(forall heap:Heaps_Heap, address:ADDRESS, location:Heaps_Location \u0026 ((address in set (inds (heap.storage))) \u003d\u003e ((dom {address |-\u003e location}) subset (inds (heap.storage)))))","type compatibility obligation:(forall heap:Heaps_Heap, address:ADDRESS, location:Heaps_Location \u0026 ((address in set (inds (heap.storage))) \u003d\u003e inv_Heaps_Heap(mk_Heaps_Heap(((heap.storage) ++ {address |-\u003e location})))))","legal sequence application obligation:(forall heap:Heaps_Heap, address:ADDRESS, data:Heaps_Data \u0026 let store:seq of (Heaps_Location) \u003d (heap.storage) in ((address in set (inds store)) \u003d\u003e (address in set (inds store))))","legal function application obligation:(forall heap:Heaps_Heap, address:ADDRESS, data:Heaps_Data \u0026 (let store:seq of (Heaps_Location) \u003d (heap.storage) in ((address in set (inds store)) and ((store(address).allocated) \u003d true)) \u003d\u003e pre_Heaps_ModifyLoc(heap, address, mk_Heaps_Location(data, true))))","type compatibility obligation:(forall heap:Heaps_Heap, address:ADDRESS, data:Heaps_Data \u0026 (let store:seq of (Heaps_Location) \u003d (heap.storage) in ((address in set (inds store)) and ((store(address).allocated) \u003d true)) \u003d\u003e inv_Heaps_Location(mk_Heaps_Location(data, true))))","legal sequence application obligation:(forall heap:Heaps_Heap, address:ADDRESS \u0026 let store:seq of (Heaps_Location) \u003d (heap.storage) in ((address in set (inds store)) \u003d\u003e (address in set (inds store))))","legal sequence application obligation:(forall heap:Heaps_Heap, address:ADDRESS \u0026 (let store:seq of (Heaps_Location) \u003d (heap.storage) in ((address in set (inds store)) and ((store(address).allocated) \u003d true)) \u003d\u003e (address in set (inds (heap.storage)))))","legal sequence application obligation:(forall heap:Heaps_Heap \u0026 let store:seq of (Heaps_Location) \u003d (heap.storage) in (forall i in set (inds store) \u0026 (i in set (inds store))))","unique existence binding obligation:(forall heap:Heaps_Heap \u0026 (Heaps_Available(heap) \u003d\u003e (exists1 new in set Heaps_UnallocatedAddresses(heap) \u0026 (forall i in set Heaps_UnallocatedAddresses(heap) \u0026 (new \u003c\u003d i)))))","legal function application obligation:(forall data:Heaps_Data, oldstate:SystemState \u0026 (Heaps_Available(heap) \u003d\u003e pre_Heaps_UnallocatedAddress(heap)))","type compatibility obligation:(forall data:Heaps_Data, oldstate:SystemState \u0026 (Heaps_Available(heap) \u003d\u003e inv_Heaps_Location(mk_Heaps_Location(data, true))))","legal function application obligation:(forall data:Heaps_Data, oldstate:SystemState \u0026 (Heaps_Available(heap) \u003d\u003e pre_Heaps_ModifyLoc(heap, newAddress, newLoc)))","type compatibility obligation:(forall address:ADDRESS, oldstate:SystemState \u0026 (pre_Heaps_ModifyLoc(heap, address, mk_Heaps_Location(nil, false)) \u003d\u003e inv_Heaps_Location(mk_Heaps_Location(nil, false))))","legal function application obligation:(forall address:ADDRESS, oldstate:SystemState \u0026 (pre_Heaps_ModifyLoc(heap, address, mk_Heaps_Location(nil, false)) \u003d\u003e pre_Heaps_ModifyLoc(heap, address, mk_Heaps_Location(nil, false))))","type compatibility obligation:(forall address:ADDRESS, oldstate:SystemState \u0026 (pre_Heaps_ModifyLoc(heap, address, mk_Heaps_Location(nil, false)) \u003d\u003e inv_Heaps_Location(mk_Heaps_Location(nil, false))))","legal function application obligation:(forall ptr:ADDRESS, data:Data, oldstate:SystemState \u0026 pre_Heaps_Modify(heap, ptr, Nodes_SetData(Heaps_Retrieve(heap, ptr), data)))","legal function application obligation:(forall ptr:ADDRESS, data:Data, oldstate:SystemState \u0026 pre_Nodes_SetData(Heaps_Retrieve(heap, ptr), data))","type compatibility obligation:(forall ptr:ADDRESS, data:Data, oldstate:SystemState \u0026 ((is_(Heaps_Retrieve(heap, ptr), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, ptr), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, ptr), Nodes_SingleLink)))","legal function application obligation:(forall ptr:ADDRESS, data:Data, oldstate:SystemState \u0026 pre_Heaps_Retrieve(heap, ptr))","legal function application obligation:(forall ptr:ADDRESS, next:ADDRESS, oldstate:SystemState \u0026 pre_Heaps_Modify(heap, ptr, Nodes_SetNext(Heaps_Retrieve(heap, ptr), next)))","legal function application obligation:(forall ptr:ADDRESS, next:ADDRESS, oldstate:SystemState \u0026 pre_Nodes_SetNext(Heaps_Retrieve(heap, ptr), next))","type compatibility obligation:(forall ptr:ADDRESS, next:ADDRESS, oldstate:SystemState \u0026 ((is_(Heaps_Retrieve(heap, ptr), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, ptr), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, ptr), Nodes_SingleLink)))","legal function application obligation:(forall ptr:ADDRESS, next:ADDRESS, oldstate:SystemState \u0026 pre_Heaps_Retrieve(heap, ptr))","legal function application obligation:(forall ptr:ADDRESS, left:ADDRESS, oldstate:SystemState \u0026 pre_Heaps_Modify(heap, ptr, Nodes_SetLeft(Heaps_Retrieve(heap, ptr), left)))","legal function application obligation:(forall ptr:ADDRESS, left:ADDRESS, oldstate:SystemState \u0026 pre_Nodes_SetLeft(Heaps_Retrieve(heap, ptr), left))","type compatibility obligation:(forall ptr:ADDRESS, left:ADDRESS, oldstate:SystemState \u0026 ((is_(Heaps_Retrieve(heap, ptr), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, ptr), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, ptr), Nodes_SingleLink)))","legal function application obligation:(forall ptr:ADDRESS, left:ADDRESS, oldstate:SystemState \u0026 pre_Heaps_Retrieve(heap, ptr))","legal function application obligation:(forall ptr:ADDRESS, right:ADDRESS, oldstate:SystemState \u0026 pre_Heaps_Modify(heap, ptr, Nodes_SetRight(Heaps_Retrieve(heap, ptr), right)))","legal function application obligation:(forall ptr:ADDRESS, right:ADDRESS, oldstate:SystemState \u0026 pre_Nodes_SetRight(Heaps_Retrieve(heap, ptr), right))","type compatibility obligation:(forall ptr:ADDRESS, right:ADDRESS, oldstate:SystemState \u0026 ((is_(Heaps_Retrieve(heap, ptr), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, ptr), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, ptr), Nodes_SingleLink)))","legal function application obligation:(forall ptr:ADDRESS, right:ADDRESS, oldstate:SystemState \u0026 pre_Heaps_Retrieve(heap, ptr))","legal function application obligation:(forall ptr:ADDRESS, prev:ADDRESS, oldstate:SystemState \u0026 pre_Heaps_Modify(heap, ptr, Nodes_SetPrev(Heaps_Retrieve(heap, ptr), prev)))","legal function application obligation:(forall ptr:ADDRESS, prev:ADDRESS, oldstate:SystemState \u0026 pre_Nodes_SetPrev(Heaps_Retrieve(heap, ptr), prev))","type compatibility obligation:(forall ptr:ADDRESS, prev:ADDRESS, oldstate:SystemState \u0026 ((is_(Heaps_Retrieve(heap, ptr), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, ptr), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, ptr), Nodes_SingleLink)))","legal function application obligation:(forall ptr:ADDRESS, prev:ADDRESS, oldstate:SystemState \u0026 pre_Heaps_Retrieve(heap, ptr))","legal function application obligation:(forall ptr:ADDRESS, parent:ADDRESS, oldstate:SystemState \u0026 pre_Heaps_Modify(heap, ptr, Nodes_SetParent(Heaps_Retrieve(heap, ptr), parent)))","legal function application obligation:(forall ptr:ADDRESS, parent:ADDRESS, oldstate:SystemState \u0026 pre_Nodes_SetParent(Heaps_Retrieve(heap, ptr), parent))","type compatibility obligation:(forall ptr:ADDRESS, parent:ADDRESS, oldstate:SystemState \u0026 ((is_(Heaps_Retrieve(heap, ptr), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, ptr), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, ptr), Nodes_SingleLink)))","legal function application obligation:(forall ptr:ADDRESS, parent:ADDRESS, oldstate:SystemState \u0026 pre_Heaps_Retrieve(heap, ptr))","legal function application obligation:(forall ptr:ADDRESS, oldstate:SystemState \u0026 pre_Nodes_GetData(Heaps_Retrieve(heap, ptr)))","type compatibility obligation:(forall ptr:ADDRESS, oldstate:SystemState \u0026 ((is_(Heaps_Retrieve(heap, ptr), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, ptr), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, ptr), Nodes_SingleLink)))","legal function application obligation:(forall ptr:ADDRESS, oldstate:SystemState \u0026 pre_Heaps_Retrieve(heap, ptr))","legal function application obligation:(forall ptr:ADDRESS, oldstate:SystemState \u0026 pre_Nodes_GetNext(Heaps_Retrieve(heap, ptr)))","type compatibility obligation:(forall ptr:ADDRESS, oldstate:SystemState \u0026 ((is_(Heaps_Retrieve(heap, ptr), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, ptr), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, ptr), Nodes_SingleLink)))","legal function application obligation:(forall ptr:ADDRESS, oldstate:SystemState \u0026 pre_Heaps_Retrieve(heap, ptr))","legal function application obligation:(forall ptr:ADDRESS, oldstate:SystemState \u0026 pre_Nodes_GetLeft(Heaps_Retrieve(heap, ptr)))","type compatibility obligation:(forall ptr:ADDRESS, oldstate:SystemState \u0026 ((is_(Heaps_Retrieve(heap, ptr), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, ptr), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, ptr), Nodes_SingleLink)))","legal function application obligation:(forall ptr:ADDRESS, oldstate:SystemState \u0026 pre_Heaps_Retrieve(heap, ptr))","legal function application obligation:(forall ptr:ADDRESS, oldstate:SystemState \u0026 pre_Nodes_GetRight(Heaps_Retrieve(heap, ptr)))","type compatibility obligation:(forall ptr:ADDRESS, oldstate:SystemState \u0026 ((is_(Heaps_Retrieve(heap, ptr), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, ptr), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, ptr), Nodes_SingleLink)))","legal function application obligation:(forall ptr:ADDRESS, oldstate:SystemState \u0026 pre_Heaps_Retrieve(heap, ptr))","legal function application obligation:(forall ptr:ADDRESS, oldstate:SystemState \u0026 pre_Nodes_GetParent(Heaps_Retrieve(heap, ptr)))","type compatibility obligation:(forall ptr:ADDRESS, oldstate:SystemState \u0026 ((is_(Heaps_Retrieve(heap, ptr), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, ptr), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, ptr), Nodes_SingleLink)))","legal function application obligation:(forall ptr:ADDRESS, oldstate:SystemState \u0026 pre_Heaps_Retrieve(heap, ptr))","legal function application obligation:(forall heap:Heaps_Heap, list:SList_List \u0026 ((not SList_IsEmpty(list)) \u003d\u003e pre_Heaps_Retrieve(heap, list)))","legal function application obligation:(forall heap:Heaps_Heap, list:SList_List \u0026 ((not SList_IsEmpty(list)) \u003d\u003e let node:[Heaps_Data] \u003d Heaps_Retrieve(heap, list) in pre_Nodes_GetData(node)))","type compatibility obligation:(forall heap:Heaps_Heap, list:SList_List \u0026 ((not SList_IsEmpty(list)) \u003d\u003e let node:[Heaps_Data] \u003d Heaps_Retrieve(heap, list) in ((is_(node, Nodes_BinaryTree) or is_(node, Nodes_DoubleLink)) or is_(node, Nodes_SingleLink))))","legal function application obligation:(forall heap:Heaps_Heap, list:SList_List \u0026 ((not SList_IsEmpty(list)) \u003d\u003e let node:[Heaps_Data] \u003d Heaps_Retrieve(heap, list) in let data:Nodes_Data \u003d Nodes_GetData(node) in pre_Nodes_GetNext(node)))","type compatibility obligation:(forall heap:Heaps_Heap, list:SList_List \u0026 ((not SList_IsEmpty(list)) \u003d\u003e let node:[Heaps_Data] \u003d Heaps_Retrieve(heap, list) in let data:Nodes_Data \u003d Nodes_GetData(node) in ((is_(node, Nodes_BinaryTree) or is_(node, Nodes_DoubleLink)) or is_(node, Nodes_SingleLink))))","function establishes postcondition obligation:(forall heap:Heaps_Heap, list:SList_List \u0026 post_SList_Lengthf(heap, list, (if (not SList_IsEmpty(list))\nthen let tail:Nodes_NodePtr \u003d Nodes_GetNext(Heaps_Retrieve(heap, list)) in (1 + SList_Lengthf(heap, tail))\nelse 0)))","legal function application obligation:(forall heap:Heaps_Heap, list:SList_List \u0026 ((not SList_IsEmpty(list)) \u003d\u003e pre_Nodes_GetNext(Heaps_Retrieve(heap, list))))","type compatibility obligation:(forall heap:Heaps_Heap, list:SList_List \u0026 ((not SList_IsEmpty(list)) \u003d\u003e ((is_(Heaps_Retrieve(heap, list), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, list), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, list), Nodes_SingleLink))))","legal function application obligation:(forall heap:Heaps_Heap, list:SList_List \u0026 ((not SList_IsEmpty(list)) \u003d\u003e pre_Heaps_Retrieve(heap, list)))","function establishes postcondition obligation:(forall heap:Heaps_Heap, list:SList_List, position:nat1 \u0026 (pre_SList_PtrToNode(heap, list, position) \u003d\u003e post_SList_PtrToNode(heap, list, position, let tail:Nodes_NodePtr \u003d Nodes_GetNext(Heaps_Retrieve(heap, list)) in (if (position \u003e 1)\nthen SList_PtrToNode(heap, tail, (position - 1))\nelse list))))","legal function application obligation:(forall heap:Heaps_Heap, list:SList_List, position:nat1 \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e let RESULT \u003d let tail:Nodes_NodePtr \u003d Nodes_GetNext(Heaps_Retrieve(heap, list)) in (if (position \u003e 1)\nthen SList_PtrToNode(heap, tail, (position - 1))\nelse list) in pre_Nodes_GetData(Heaps_Retrieve(heap, RESULT))))","type compatibility obligation:(forall heap:Heaps_Heap, list:SList_List, position:nat1 \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e let RESULT \u003d let tail:Nodes_NodePtr \u003d Nodes_GetNext(Heaps_Retrieve(heap, list)) in (if (position \u003e 1)\nthen SList_PtrToNode(heap, tail, (position - 1))\nelse list) in ((is_(Heaps_Retrieve(heap, RESULT), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, RESULT), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, RESULT), Nodes_SingleLink))))","legal function application obligation:(forall heap:Heaps_Heap, list:SList_List, position:nat1 \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e let RESULT \u003d let tail:Nodes_NodePtr \u003d Nodes_GetNext(Heaps_Retrieve(heap, list)) in (if (position \u003e 1)\nthen SList_PtrToNode(heap, tail, (position - 1))\nelse list) in pre_Heaps_Retrieve(heap, RESULT)))","legal sequence application obligation:(forall heap:Heaps_Heap, list:SList_List, position:nat1 \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e let RESULT \u003d let tail:Nodes_NodePtr \u003d Nodes_GetNext(Heaps_Retrieve(heap, list)) in (if (position \u003e 1)\nthen SList_PtrToNode(heap, tail, (position - 1))\nelse list) in let data:Nodes_Data \u003d Nodes_GetData(Heaps_Retrieve(heap, RESULT)), listSeq:seq of (SList_Data) \u003d SList_Seq(heap, list) in (position in set (inds listSeq))))","legal function application obligation:(forall heap:Heaps_Heap, list:SList_List, position:nat1 \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e pre_Nodes_GetNext(Heaps_Retrieve(heap, list))))","type compatibility obligation:(forall heap:Heaps_Heap, list:SList_List, position:nat1 \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e ((is_(Heaps_Retrieve(heap, list), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, list), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, list), Nodes_SingleLink))))","legal function application obligation:(forall heap:Heaps_Heap, list:SList_List, position:nat1 \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e pre_Heaps_Retrieve(heap, list)))","legal function application obligation:(forall heap:Heaps_Heap, list:SList_List, position:nat1 \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e let tail:Nodes_NodePtr \u003d Nodes_GetNext(Heaps_Retrieve(heap, list)) in ((position \u003e 1) \u003d\u003e pre_SList_PtrToNode(heap, tail, (position - 1)))))","type compatibility obligation:(forall heap:Heaps_Heap, list:SList_List, position:nat1 \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e let tail:Nodes_NodePtr \u003d Nodes_GetNext(Heaps_Retrieve(heap, list)) in ((position \u003e 1) \u003d\u003e ((position - 1) \u003e 0))))","operation establishes postcondition obligation:(forall list:SList_List, data:SList_Data, oldstate:SystemState \u0026 (([data] ^ SList_Seq(heap~, list)) \u003d SList_Seq(heap, RESULT)))","legal sequence application obligation:(forall list:SList_List, ptr:Nodes_NodePtr, data:SList_Data, oldstate:SystemState \u0026 (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in (1 in set (inds old))))","non-empty sequence obligation:(forall list:SList_List, ptr:Nodes_NodePtr, data:SList_Data, oldstate:SystemState \u0026 (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in (old \u003c\u003e [])))","operation establishes postcondition obligation:(forall list:SList_List, ptr:Nodes_NodePtr, data:SList_Data, oldstate:SystemState \u0026 (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in ((([old(1)] ^ [data]) ^ (tl old)) \u003d SList_Seq(heap, ptr))))","legal function application obligation:(forall list:SList_List, data:SList_Data, position:nat1, oldstate:SystemState \u0026 (((position \u003c\u003d (SList_Lengthf(heap, list) + 1)) and Heaps_Available(heap)) \u003d\u003e pre_SList_PtrToNode(heap, list, (position - 1))))","type compatibility obligation:(forall list:SList_List, data:SList_Data, position:nat1, oldstate:SystemState \u0026 (((position \u003c\u003d (SList_Lengthf(heap, list) + 1)) and Heaps_Available(heap)) \u003d\u003e ((position - 1) \u003e 0)))","legal sequence application obligation:(forall list:SList_List, data:SList_Data, position:nat1, oldstate:SystemState \u0026 (((position \u003c\u003d (SList_Lengthf(heap, list) + 1)) and Heaps_Available(heap)) \u003d\u003e let new:seq of (SList_Data) \u003d SList_Seq(heap, RESULT) in (forall i in set (inds new) \u0026 ((i \u003c\u003e position) \u003d\u003e (i in set (inds new))))))","legal sequence application obligation:(forall list:SList_List, data:SList_Data, position:nat1, oldstate:SystemState \u0026 (((position \u003c\u003d (SList_Lengthf(heap, list) + 1)) and Heaps_Available(heap)) \u003d\u003e let new:seq of (SList_Data) \u003d SList_Seq(heap, RESULT) in ((SList_Seq(heap~, list) \u003d [new(i) | i in set (inds new) \u0026 (i \u003c\u003e position)]) \u003d\u003e (position in set (inds new)))))","operation establishes postcondition obligation:(forall list:SList_List, data:SList_Data, position:nat1, oldstate:SystemState \u0026 (((position \u003c\u003d (SList_Lengthf(heap, list) + 1)) and Heaps_Available(heap)) \u003d\u003e let new:seq of (SList_Data) \u003d SList_Seq(heap, RESULT) in ((SList_Seq(heap~, list) \u003d [new(i) | i in set (inds new) \u0026 (i \u003c\u003e position)]) and ((new(position) \u003d data) and ((Heaps_AmountUsed(heap~) + 1) \u003d Heaps_AmountUsed(heap))))))","while loop termination obligation:...","operation establishes postcondition obligation:(forall list:SList_List, data:SList_Data, oldstate:SystemState \u0026 (Heaps_Available(heap) \u003d\u003e (((SList_Seq(heap~, list) ^ [data]) \u003d SList_Seq(heap, RESULT)) and ((Heaps_AmountUsed(heap~) + 1) \u003d Heaps_AmountUsed(heap)))))","legal function application obligation:(forall list:SList_List, data:SList_Data, position:nat1, oldstate:SystemState \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e pre_SList_PtrToNode(heap, list, position)))","sequence modification obligation:(forall list:SList_List, data:SList_Data, position:nat1, oldstate:SystemState \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e (true \u003d\u003e ((dom {position |-\u003e data}) subset (inds SList_Seq(heap~, list))))))","operation establishes postcondition obligation:(forall list:SList_List, data:SList_Data, position:nat1, oldstate:SystemState \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e (true \u003d\u003e (((SList_Seq(heap~, list) ++ {position |-\u003e data}) \u003d SList_Seq(heap, RESULT)) and (Heaps_AmountUsed(heap~) \u003d Heaps_AmountUsed(heap))))))","operation call obligation:(forall list:SList_List, oldstate:SystemState \u0026 pre_Heaps_ModifyLoc(heap, address, mk_Heaps_Location(nil, false)))","non-empty sequence obligation:(forall list:SList_List, oldstate:SystemState \u0026 (true \u003d\u003e (SList_Seq(heap~, list) \u003c\u003e [])))","operation establishes postcondition obligation:(forall list:SList_List, oldstate:SystemState \u0026 (true \u003d\u003e ((tl SList_Seq(heap~, list)) \u003d SList_Seq(heap, RESULT))))","operation call obligation:(forall list:SList_List, ptr:Nodes_NodePtr, oldstate:SystemState \u0026 (true \u003d\u003e pre_Heaps_ModifyLoc(heap, address, mk_Heaps_Location(nil, false))))","legal sequence application obligation:(forall list:SList_List, ptr:Nodes_NodePtr, oldstate:SystemState \u0026 (true \u003d\u003e (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in (1 in set (inds old)))))","non-empty sequence obligation:(forall list:SList_List, ptr:Nodes_NodePtr, oldstate:SystemState \u0026 (true \u003d\u003e (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in (old \u003c\u003e []))))","non-empty sequence obligation:(forall list:SList_List, ptr:Nodes_NodePtr, oldstate:SystemState \u0026 (true \u003d\u003e (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in ((tl old) \u003c\u003e []))))","operation establishes postcondition obligation:(forall list:SList_List, ptr:Nodes_NodePtr, oldstate:SystemState \u0026 (true \u003d\u003e (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in (([old(1)] ^ (tl (tl old))) \u003d SList_Seq(heap, ptr)))))","legal function application obligation:(forall list:SList_List, position:nat1, oldstate:SystemState \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e pre_SList_PtrToNode(heap, list, (position - 1))))","type compatibility obligation:(forall list:SList_List, position:nat1, oldstate:SystemState \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e ((position - 1) \u003e 0)))","legal sequence application obligation:(forall list:SList_List, position:nat1, oldstate:SystemState \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, list) in (forall i in set (inds old) \u0026 ((i \u003c\u003e position) \u003d\u003e (i in set (inds old))))))","operation establishes postcondition obligation:(forall list:SList_List, position:nat1, oldstate:SystemState \u0026 ((position \u003c\u003d SList_Lengthf(heap, list)) \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, list) in (([old(i) | i in set (inds old) \u0026 (i \u003c\u003e position)] \u003d SList_Seq(heap, RESULT)) and (Heaps_AmountUsed(heap~) \u003d (Heaps_AmountUsed(heap) + 1)))))","while loop termination obligation:...","legal function application obligation:(forall list:SList_List, traversal:(SList_Data -\u003e SList_Data), oldstate:SystemState \u0026 pre_(traversalDATA(ptr)))","legal function application obligation:(forall list:SList_List, traversal:(SList_Data -\u003e SList_Data), oldstate:SystemState \u0026 (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, list) in ((old \u003c\u003e []) \u003d\u003e (forall i in set (inds old) \u0026 pre_(traversalold(i))))))","legal sequence application obligation:(forall list:SList_List, traversal:(SList_Data -\u003e SList_Data), oldstate:SystemState \u0026 (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, list) in ((old \u003c\u003e []) \u003d\u003e (forall i in set (inds old) \u0026 (i in set (inds old))))))","operation establishes postcondition obligation:(forall list:SList_List, traversal:(SList_Data -\u003e SList_Data), oldstate:SystemState \u0026 (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, list) in ((old \u003c\u003e []) \u003d\u003e ([traversal(old(i)) | i in set (inds old)] \u003d SList_Seq(heap, RESULT)))))","legal function application obligation:(forall list:SList_List, position:nat1, oldstate:SystemState \u0026 pre_SList_PtrToNode(heap, list, position))","legal function application obligation:(forall heap:Heaps_Heap, list:DList_List \u0026 pre_Nodes_GetNext(Heaps_Retrieve(heap, list)))","type compatibility obligation:(forall heap:Heaps_Heap, list:DList_List \u0026 ((is_(Heaps_Retrieve(heap, list), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, list), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, list), Nodes_SingleLink)))","legal function application obligation:(forall heap:Heaps_Heap, list:DList_List \u0026 pre_Heaps_Retrieve(heap, list))","legal function application obligation:(forall heap:Heaps_Heap, list:DList_List \u0026 ((list \u003c\u003e NIL) \u003d\u003e pre_Nodes_GetPrev(Heaps_Retrieve(heap, list))))","type compatibility obligation:(forall heap:Heaps_Heap, list:DList_List \u0026 ((list \u003c\u003e NIL) \u003d\u003e ((is_(Heaps_Retrieve(heap, list), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, list), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, list), Nodes_SingleLink))))","legal function application obligation:(forall heap:Heaps_Heap, list:DList_List \u0026 ((list \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, list)))","legal function application obligation:(forall heap:Heaps_Heap, list:DList_List \u0026 ((list \u003c\u003e NIL) \u003d\u003e let prev:Nodes_NodePtr \u003d Nodes_GetPrev(Heaps_Retrieve(heap, list)) in pre_Nodes_GetData(Heaps_Retrieve(heap, list))))","type compatibility obligation:(forall heap:Heaps_Heap, list:DList_List \u0026 ((list \u003c\u003e NIL) \u003d\u003e let prev:Nodes_NodePtr \u003d Nodes_GetPrev(Heaps_Retrieve(heap, list)) in ((is_(Heaps_Retrieve(heap, list), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, list), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, list), Nodes_SingleLink))))","legal function application obligation:(forall heap:Heaps_Heap, list:DList_List \u0026 ((list \u003c\u003e NIL) \u003d\u003e let prev:Nodes_NodePtr \u003d Nodes_GetPrev(Heaps_Retrieve(heap, list)) in pre_Heaps_Retrieve(heap, list)))","operation establishes postcondition obligation:(forall list:DList_List, data:DList_Data, oldstate:SystemState \u0026 (true \u003d\u003e (([data] ^ SList_Seq(heap~, list)) \u003d SList_Seq(heap, RESULT))))","legal sequence application obligation:(forall list:DList_List, ptr:Nodes_NodePtr, data:DList_Data, oldstate:SystemState \u0026 (true \u003d\u003e (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in (1 in set (inds old)))))","non-empty sequence obligation:(forall list:DList_List, ptr:Nodes_NodePtr, data:DList_Data, oldstate:SystemState \u0026 (true \u003d\u003e (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in (old \u003c\u003e []))))","operation establishes postcondition obligation:(forall list:DList_List, ptr:Nodes_NodePtr, data:DList_Data, oldstate:SystemState \u0026 (true \u003d\u003e (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in ((([old(1)] ^ [data]) ^ (tl old)) \u003d SList_Seq(heap, ptr)))))","legal function application obligation:(forall list:DList_List, data:DList_Data, position:nat1, oldstate:SystemState \u0026 (((position \u003c\u003d (SList_Lengthf(heap, list) + 1)) and (Heaps_Available(heap) and DList_IsList(heap, list))) \u003d\u003e pre_SList_PtrToNode(heap, list, (position - 1))))","type compatibility obligation:(forall list:DList_List, data:DList_Data, position:nat1, oldstate:SystemState \u0026 (((position \u003c\u003d (SList_Lengthf(heap, list) + 1)) and (Heaps_Available(heap) and DList_IsList(heap, list))) \u003d\u003e ((position - 1) \u003e 0)))","legal sequence application obligation:(forall list:DList_List, data:DList_Data, position:nat1, oldstate:SystemState \u0026 (((position \u003c\u003d (SList_Lengthf(heap, list) + 1)) and (Heaps_Available(heap) and DList_IsList(heap, list))) \u003d\u003e (DList_IsList(heap, RESULT) \u003d\u003e let new:seq of (SList_Data) \u003d SList_Seq(heap, RESULT) in (forall i in set (inds new) \u0026 ((i \u003c\u003e position) \u003d\u003e (i in set (inds new)))))))","legal sequence application obligation:(forall list:DList_List, data:DList_Data, position:nat1, oldstate:SystemState \u0026 (((position \u003c\u003d (SList_Lengthf(heap, list) + 1)) and (Heaps_Available(heap) and DList_IsList(heap, list))) \u003d\u003e (DList_IsList(heap, RESULT) \u003d\u003e let new:seq of (SList_Data) \u003d SList_Seq(heap, RESULT) in ((SList_Seq(heap~, list) \u003d [new(i) | i in set (inds new) \u0026 (i \u003c\u003e position)]) \u003d\u003e (position in set (inds new))))))","operation establishes postcondition obligation:(forall list:DList_List, data:DList_Data, position:nat1, oldstate:SystemState \u0026 (((position \u003c\u003d (SList_Lengthf(heap, list) + 1)) and (Heaps_Available(heap) and DList_IsList(heap, list))) \u003d\u003e (DList_IsList(heap, RESULT) and let new:seq of (SList_Data) \u003d SList_Seq(heap, RESULT) in ((SList_Seq(heap~, list) \u003d [new(i) | i in set (inds new) \u0026 (i \u003c\u003e position)]) and (new(position) \u003d data)))))","operation call obligation:(forall list:DList_List, oldstate:SystemState \u0026 (true \u003d\u003e pre_Heaps_ModifyLoc(heap, address, mk_Heaps_Location(nil, false))))","non-empty sequence obligation:(forall list:DList_List, oldstate:SystemState \u0026 (true \u003d\u003e (true \u003d\u003e (SList_Seq(heap~, list) \u003c\u003e []))))","operation establishes postcondition obligation:(forall list:DList_List, oldstate:SystemState \u0026 (true \u003d\u003e (true \u003d\u003e ((tl SList_Seq(heap~, list)) \u003d SList_Seq(heap, RESULT)))))","operation call obligation:(forall list:DList_List, ptr:Nodes_NodePtr, oldstate:SystemState \u0026 (true \u003d\u003e (true \u003d\u003e pre_Heaps_ModifyLoc(heap, address, mk_Heaps_Location(nil, false)))))","legal sequence application obligation:(forall list:DList_List, ptr:Nodes_NodePtr, oldstate:SystemState \u0026 (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in (1 in set (inds old))))))","non-empty sequence obligation:(forall list:DList_List, ptr:Nodes_NodePtr, oldstate:SystemState \u0026 (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in (old \u003c\u003e [])))))","non-empty sequence obligation:(forall list:DList_List, ptr:Nodes_NodePtr, oldstate:SystemState \u0026 (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in ((tl old) \u003c\u003e [])))))","operation establishes postcondition obligation:(forall list:DList_List, ptr:Nodes_NodePtr, oldstate:SystemState \u0026 (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, ptr) in (([old(1)] ^ (tl (tl old))) \u003d SList_Seq(heap, ptr))))))","legal function application obligation:(forall list:DList_List, position:nat1, oldstate:SystemState \u0026 (((position \u003c\u003d SList_Lengthf(heap, list)) and DList_IsList(heap, list)) \u003d\u003e pre_SList_PtrToNode(heap, list, (position - 1))))","type compatibility obligation:(forall list:DList_List, position:nat1, oldstate:SystemState \u0026 (((position \u003c\u003d SList_Lengthf(heap, list)) and DList_IsList(heap, list)) \u003d\u003e ((position - 1) \u003e 0)))","legal sequence application obligation:(forall list:DList_List, position:nat1, oldstate:SystemState \u0026 (((position \u003c\u003d SList_Lengthf(heap, list)) and DList_IsList(heap, list)) \u003d\u003e (DList_IsList(heap, RESULT) \u003d\u003e let old:seq of (SList_Data) \u003d SList_Seq(heap~, list) in (forall i in set (inds old) \u0026 ((i \u003c\u003e position) \u003d\u003e (i in set (inds old)))))))","operation establishes postcondition obligation:(forall list:DList_List, position:nat1, oldstate:SystemState \u0026 (((position \u003c\u003d SList_Lengthf(heap, list)) and DList_IsList(heap, list)) \u003d\u003e (DList_IsList(heap, RESULT) and let old:seq of (SList_Data) \u003d SList_Seq(heap~, list) in (([old(i) | i in set (inds old) \u0026 (i \u003c\u003e position)] \u003d SList_Seq(heap, RESULT)) and (Heaps_AmountUsed(heap~) \u003d (Heaps_AmountUsed(heap) + 1))))))","while loop termination obligation:...","operation establishes postcondition obligation:(forall list:DList_List, data:DList_Data, oldstate:SystemState \u0026 ((Heaps_Available(heap) and DList_IsList(heap, list)) \u003d\u003e (((SList_Seq(heap~, list) ^ [data]) \u003d SList_Seq(heap, RESULT)) and (((Heaps_AmountUsed(heap~) + 1) \u003d Heaps_AmountUsed(heap)) and DList_IsList(heap, RESULT)))))","operation call obligation:(forall list:DList_List, data:DList_Data, position:nat1, oldstate:SystemState \u0026 (list \u003c\u003d SList_Lengthf(heap, list)))","type compatibility obligation:(forall queue:Queues_Queue, oldstate:SystemState \u0026 is_(RESULT, (Queues_Queue * Queues_Data)))","type compatibility obligation:(forall stack:Stacks_Stack, oldstate:SystemState \u0026 is_(RESULT, (Stacks_Stack * Stacks_Data)))","legal function application obligation:(forall tree:set of (STrees_Node) \u0026 (forall node in set tree \u0026 pre_STrees_IsRoot(tree, node)))","legal function application obligation:(forall tree:set of (STrees_Node) \u0026 (forall node in set tree \u0026 pre_STrees_IsChild(tree, node)))","legal function application obligation:(forall tree:set of (STrees_Node) \u0026 ((forall node in set tree \u0026 ((not STrees_IsRoot(tree, node)) \u003c\u003d\u003e (STrees_IsChild(tree, node) and STrees_IsUnique(tree, node)))) \u003d\u003e (forall node in set tree \u0026 pre_STrees_IsRoot(tree, node))))","type invariant satisfiable obligation:(exists tree:STrees_Tree \u0026 ((forall node in set tree \u0026 ((not STrees_IsRoot(tree, node)) \u003c\u003d\u003e (STrees_IsChild(tree, node) and STrees_IsUnique(tree, node)))) and ((tree \u003c\u003e {}) \u003c\u003d\u003e (exists1 node in set tree \u0026 STrees_IsRoot(tree, node)))))","legal function application obligation:(forall mk_STrees_Info(t, c):STrees_Info \u0026 (((c \u003d nil) \u003c\u003d\u003e (t \u003d {})) \u003d\u003e ((c in set t) \u003d\u003e pre_STrees_Root(t))))","type invariant satisfiable obligation:(exists mk_STrees_Info(t, c):STrees_Info \u0026 (((c \u003d nil) \u003c\u003d\u003e (t \u003d {})) and ((c \u003c\u003e nil) \u003c\u003d\u003e ((c in set t) and let r:STrees_Node \u003d STrees_Root(t) in ((r.position) \u003d 1)))))","type compatibility obligation:(forall tree:set of (STrees_Node) \u0026 (inv_STrees_Tree(tree) \u003d\u003e inv_STrees_Tree(tree)))","type compatibility obligation:(forall tree:STrees_Tree, current:STrees_Node \u0026 inv_STrees_Info(mk_STrees_Info(tree, current)))","type compatibility obligation:(forall tree:STrees_Tree, current:STrees_Node \u0026 (inv_STrees_Info(mk_STrees_Info(tree, current)) \u003d\u003e inv_STrees_Info(mk_STrees_Info(tree, current))))","type compatibility obligation:inv_STrees_Tree({})","type compatibility obligation:(inv_STrees_Info(mk_STrees_Info({}, nil)) and inv_STrees_Tree({}))","legal function application obligation:(forall tree:set of (STrees_Node), mk_STrees_Node(dr, pr):STrees_Node \u0026 ((mk_STrees_Node(dr, pr) in set tree) \u003d\u003e pre_STrees_IsChild(tree, mk_STrees_Node(dr, pr))))","legal function application obligation:(forall tree:STrees_Tree, node:STrees_Node \u0026 ((node in set tree) \u003d\u003e (forall child in set tree \u0026 pre_STrees_IsParentOf(tree, node, child))))","legal function application obligation:(forall tree:set of (STrees_Node), node:STrees_Node \u0026 ((node in set tree) \u003d\u003e (forall parent in set tree \u0026 pre_STrees_IsParentOf(tree, parent, node))))","legal function application obligation:(forall tree:set of (STrees_Node), node:STrees_Node \u0026 ((node in set tree) \u003d\u003e ((exists parent in set tree \u0026 STrees_IsParentOf(tree, parent, node)) \u003d\u003e (forall parent in set tree \u0026 pre_STrees_IsParentOf(tree, parent, node)))))","legal function application obligation:(forall tree:set of (STrees_Node), node1:STrees_Node, node2:STrees_Node \u0026 (((node1 in set tree) and (node2 in set tree)) \u003d\u003e pre_STrees_IsRightChildOf(tree, node2, node1)))","legal function application obligation:(forall tree:set of (STrees_Node), node1:STrees_Node, node2:STrees_Node \u0026 (((node1 in set tree) and (node2 in set tree)) \u003d\u003e ((not STrees_IsRightChildOf(tree, node2, node1)) \u003d\u003e pre_STrees_IsLeftChildOf(tree, node2, node1))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info, data:STrees_Data, direction:STrees_Direction \u0026 (((direction \u003d \u003cToRoot\u003e) \u003d\u003e (tree \u003d {})) \u003d\u003e ((direction \u003d \u003cToLeft\u003e) \u003d\u003e pre_STrees_HasLeftChild(tree, current))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, data:STrees_Data, direction:STrees_Direction \u0026 (((direction \u003d \u003cToRoot\u003e) \u003d\u003e (tree \u003d {})) \u003d\u003e ((direction \u003d \u003cToLeft\u003e) \u003d\u003e is_(current, STrees_Node))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info, data:STrees_Data, direction:STrees_Direction \u0026 (((direction \u003d \u003cToRoot\u003e) \u003d\u003e (tree \u003d {})) \u003d\u003e (((direction \u003d \u003cToLeft\u003e) \u003d\u003e (not STrees_HasLeftChild(tree, current))) \u003d\u003e ((direction \u003d \u003cToRight\u003e) \u003d\u003e pre_STrees_HasRightChild(tree, current)))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, data:STrees_Data, direction:STrees_Direction \u0026 (((direction \u003d \u003cToRoot\u003e) \u003d\u003e (tree \u003d {})) \u003d\u003e (((direction \u003d \u003cToLeft\u003e) \u003d\u003e (not STrees_HasLeftChild(tree, current))) \u003d\u003e ((direction \u003d \u003cToRight\u003e) \u003d\u003e is_(current, STrees_Node)))))","function establishes postcondition obligation:(forall mk_STrees_Info(tree, current):STrees_Info, data:STrees_Data, direction:STrees_Direction \u0026 (pre_STrees_Insert(mk_STrees_Info(tree, current), data, direction) \u003d\u003e post_STrees_Insert(mk_STrees_Info(tree, current), data, direction, (cases mk_(current, direction) :\nmk_(nil, \u003cToRoot\u003e) -\u003e STrees_InsertRoot(data),\nmk_(-, \u003cToLeft\u003e) -\u003e STrees_InsertLeft(tree, current, data),\nmk_(-, \u003cToRight\u003e) -\u003e STrees_InsertRight(tree, current, data)\n end))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info, data:STrees_Data, direction:STrees_Direction \u0026 ((((direction \u003d \u003cToRoot\u003e) \u003d\u003e (tree \u003d {})) and (((direction \u003d \u003cToLeft\u003e) \u003d\u003e (not STrees_HasLeftChild(tree, current))) and ((direction \u003d \u003cToRight\u003e) \u003d\u003e (not STrees_HasRightChild(tree, current))))) \u003d\u003e ((not (mk_(nil, \u003cToRoot\u003e) \u003d mk_(current, direction))) \u003d\u003e (exists mk_(-, \u003cToLeft\u003e):([STrees_Node] * STrees_Direction) \u0026 ((mk_(any1, \u003cToLeft\u003e) \u003d mk_(current, direction)) \u003d\u003e let mk_(-, \u003cToLeft\u003e) \u003d mk_(current, direction) in pre_STrees_InsertLeft(tree, current, data))))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, data:STrees_Data, direction:STrees_Direction \u0026 ((((direction \u003d \u003cToRoot\u003e) \u003d\u003e (tree \u003d {})) and (((direction \u003d \u003cToLeft\u003e) \u003d\u003e (not STrees_HasLeftChild(tree, current))) and ((direction \u003d \u003cToRight\u003e) \u003d\u003e (not STrees_HasRightChild(tree, current))))) \u003d\u003e ((not (mk_(nil, \u003cToRoot\u003e) \u003d mk_(current, direction))) \u003d\u003e (exists mk_(-, \u003cToLeft\u003e):([STrees_Node] * STrees_Direction) \u0026 ((mk_(any1, \u003cToLeft\u003e) \u003d mk_(current, direction)) \u003d\u003e let mk_(-, \u003cToLeft\u003e) \u003d mk_(current, direction) in is_(current, STrees_Node))))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info, data:STrees_Data, direction:STrees_Direction \u0026 ((((direction \u003d \u003cToRoot\u003e) \u003d\u003e (tree \u003d {})) and (((direction \u003d \u003cToLeft\u003e) \u003d\u003e (not STrees_HasLeftChild(tree, current))) and ((direction \u003d \u003cToRight\u003e) \u003d\u003e (not STrees_HasRightChild(tree, current))))) \u003d\u003e ((not (mk_(nil, \u003cToRoot\u003e) \u003d mk_(current, direction))) \u003d\u003e ((not (exists mk_(-, \u003cToLeft\u003e):([STrees_Node] * STrees_Direction) \u0026 (mk_(any1, \u003cToLeft\u003e) \u003d mk_(current, direction)))) \u003d\u003e (exists mk_(-, \u003cToRight\u003e):([STrees_Node] * STrees_Direction) \u0026 ((mk_(any1, \u003cToRight\u003e) \u003d mk_(current, direction)) \u003d\u003e let mk_(-, \u003cToRight\u003e) \u003d mk_(current, direction) in pre_STrees_InsertRight(tree, current, data)))))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, data:STrees_Data, direction:STrees_Direction \u0026 ((((direction \u003d \u003cToRoot\u003e) \u003d\u003e (tree \u003d {})) and (((direction \u003d \u003cToLeft\u003e) \u003d\u003e (not STrees_HasLeftChild(tree, current))) and ((direction \u003d \u003cToRight\u003e) \u003d\u003e (not STrees_HasRightChild(tree, current))))) \u003d\u003e ((not (mk_(nil, \u003cToRoot\u003e) \u003d mk_(current, direction))) \u003d\u003e ((not (exists mk_(-, \u003cToLeft\u003e):([STrees_Node] * STrees_Direction) \u0026 (mk_(any1, \u003cToLeft\u003e) \u003d mk_(current, direction)))) \u003d\u003e (exists mk_(-, \u003cToRight\u003e):([STrees_Node] * STrees_Direction) \u0026 ((mk_(any1, \u003cToRight\u003e) \u003d mk_(current, direction)) \u003d\u003e let mk_(-, \u003cToRight\u003e) \u003d mk_(current, direction) in is_(current, STrees_Node)))))))","cases exhaustive obligation:(forall mk_STrees_Info(tree, current):STrees_Info, data:STrees_Data, direction:STrees_Direction \u0026 ((((direction \u003d \u003cToRoot\u003e) \u003d\u003e (tree \u003d {})) and (((direction \u003d \u003cToLeft\u003e) \u003d\u003e (not STrees_HasLeftChild(tree, current))) and ((direction \u003d \u003cToRight\u003e) \u003d\u003e (not STrees_HasRightChild(tree, current))))) \u003d\u003e (((mk_(current, direction) \u003d mk_(nil, \u003cToRoot\u003e)) or (exists mk_(-, \u003cToLeft\u003e):([STrees_Node] * STrees_Direction) \u0026 (mk_(current, direction) \u003d mk_(any1, \u003cToLeft\u003e)))) or (exists mk_(-, \u003cToRight\u003e):([STrees_Node] * STrees_Direction) \u0026 (mk_(current, direction) \u003d mk_(any1, \u003cToRight\u003e))))))","type compatibility obligation:(forall data:STrees_Data \u0026 let root:STrees_Node \u003d mk_STrees_Node(data, 1) in inv_STrees_Tree({root}))","type compatibility obligation:(forall data:STrees_Data \u0026 let root:STrees_Node \u003d mk_STrees_Node(data, 1) in (inv_STrees_Info(mk_STrees_Info({root}, root)) and inv_STrees_Tree({root})))","legal function application obligation:(forall tree:STrees_Tree, current:STrees_Node, data:STrees_Data \u0026 pre_STrees_HasLeftChild(tree, current))","type compatibility obligation:(forall tree:STrees_Tree, current:STrees_Node, data:STrees_Data \u0026 ((not STrees_HasLeftChild(tree, current)) \u003d\u003e let mk_STrees_Node(-, position):STrees_Node \u003d current in let new:STrees_Node \u003d mk_STrees_Node(data, (2 * position)) in inv_STrees_Tree((tree union {new}))))","type compatibility obligation:(forall tree:STrees_Tree, current:STrees_Node, data:STrees_Data \u0026 ((not STrees_HasLeftChild(tree, current)) \u003d\u003e let mk_STrees_Node(-, position):STrees_Node \u003d current in let new:STrees_Node \u003d mk_STrees_Node(data, (2 * position)) in (inv_STrees_Info(mk_STrees_Info((tree union {new}), new)) and inv_STrees_Tree((tree union {new})))))","legal function application obligation:(forall tree:STrees_Tree, current:STrees_Node, data:STrees_Data \u0026 pre_STrees_HasRightChild(tree, current))","type compatibility obligation:(forall tree:STrees_Tree, current:STrees_Node, data:STrees_Data \u0026 ((not STrees_HasRightChild(tree, current)) \u003d\u003e let mk_STrees_Node(-, position):STrees_Node \u003d current in let new:STrees_Node \u003d mk_STrees_Node(data, ((2 * position) + 1)) in inv_STrees_Tree((tree union {new}))))","type compatibility obligation:(forall tree:STrees_Tree, current:STrees_Node, data:STrees_Data \u0026 ((not STrees_HasRightChild(tree, current)) \u003d\u003e let mk_STrees_Node(-, position):STrees_Node \u003d current in let new:STrees_Node \u003d mk_STrees_Node(data, ((2 * position) + 1)) in (inv_STrees_Info(mk_STrees_Info((tree union {new}), new)) and inv_STrees_Tree((tree union {new})))))","legal function application obligation:(forall treeinfo:STrees_Info, traversal:(STrees_Data -\u003e STrees_Data) \u0026 let mk_STrees_Info(tree, current):STrees_Info \u003d treeinfo in ((current \u003c\u003e nil) \u003d\u003e let mk_STrees_Node(data, position):[STrees_Node] \u003d current in (forall mk_STrees_Node(data, position) in set tree \u0026 pre_(traversaldata))))","legal function application obligation:(forall treeinfo:STrees_Info, traversal:(STrees_Data -\u003e STrees_Data) \u0026 let mk_STrees_Info(tree, current):STrees_Info \u003d treeinfo in ((current \u003c\u003e nil) \u003d\u003e let mk_STrees_Node(data, position):[STrees_Node] \u003d current in let newtree:set of (STrees_Node) \u003d {mk_STrees_Node(traversal(data), position) | mk_STrees_Node(data, position) in set tree} in pre_(traversaldata)))","type compatibility obligation:(forall treeinfo:STrees_Info, traversal:(STrees_Data -\u003e STrees_Data) \u0026 let mk_STrees_Info(tree, current):STrees_Info \u003d treeinfo in ((current \u003c\u003e nil) \u003d\u003e let mk_STrees_Node(data, position):[STrees_Node] \u003d current in let newtree:set of (STrees_Node) \u003d {mk_STrees_Node(traversal(data), position) | mk_STrees_Node(data, position) in set tree} in inv_STrees_Tree(newtree)))","type compatibility obligation:(forall treeinfo:STrees_Info, traversal:(STrees_Data -\u003e STrees_Data) \u0026 let mk_STrees_Info(tree, current):STrees_Info \u003d treeinfo in ((current \u003c\u003e nil) \u003d\u003e let mk_STrees_Node(data, position):[STrees_Node] \u003d current in let newtree:set of (STrees_Node) \u003d {mk_STrees_Node(traversal(data), position) | mk_STrees_Node(data, position) in set tree} in (inv_STrees_Info(mk_STrees_Info(newtree, mk_STrees_Node(traversal(data), position))) and inv_STrees_Tree(newtree))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, direction:STrees_Direction \u0026 inv_STrees_Info(mk_STrees_Info(tree, current)))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info, direction:STrees_Direction \u0026 (STrees_ExistsDirection(mk_STrees_Info(tree, current), direction) \u003d\u003e ((\u003cToRoot\u003e \u003d direction) \u003d\u003e pre_STrees_Root(tree))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, direction:STrees_Direction \u0026 (STrees_ExistsDirection(mk_STrees_Info(tree, current), direction) \u003d\u003e ((\u003cToRoot\u003e \u003d direction) \u003d\u003e inv_STrees_Info(mk_STrees_Info(tree, STrees_Root(tree))))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info, direction:STrees_Direction \u0026 (STrees_ExistsDirection(mk_STrees_Info(tree, current), direction) \u003d\u003e ((not (\u003cToRoot\u003e \u003d direction)) \u003d\u003e ((\u003cToLeft\u003e \u003d direction) \u003d\u003e pre_STrees_LeftChild(tree, current)))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, direction:STrees_Direction \u0026 (STrees_ExistsDirection(mk_STrees_Info(tree, current), direction) \u003d\u003e ((not (\u003cToRoot\u003e \u003d direction)) \u003d\u003e ((\u003cToLeft\u003e \u003d direction) \u003d\u003e is_(current, STrees_Node)))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, direction:STrees_Direction \u0026 (STrees_ExistsDirection(mk_STrees_Info(tree, current), direction) \u003d\u003e ((not (\u003cToRoot\u003e \u003d direction)) \u003d\u003e ((\u003cToLeft\u003e \u003d direction) \u003d\u003e inv_STrees_Info(mk_STrees_Info(tree, STrees_LeftChild(tree, current)))))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info, direction:STrees_Direction \u0026 (STrees_ExistsDirection(mk_STrees_Info(tree, current), direction) \u003d\u003e ((not (\u003cToRoot\u003e \u003d direction)) \u003d\u003e ((not (\u003cToLeft\u003e \u003d direction)) \u003d\u003e ((\u003cToRight\u003e \u003d direction) \u003d\u003e pre_STrees_RightChild(tree, current))))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, direction:STrees_Direction \u0026 (STrees_ExistsDirection(mk_STrees_Info(tree, current), direction) \u003d\u003e ((not (\u003cToRoot\u003e \u003d direction)) \u003d\u003e ((not (\u003cToLeft\u003e \u003d direction)) \u003d\u003e ((\u003cToRight\u003e \u003d direction) \u003d\u003e is_(current, STrees_Node))))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, direction:STrees_Direction \u0026 (STrees_ExistsDirection(mk_STrees_Info(tree, current), direction) \u003d\u003e ((not (\u003cToRoot\u003e \u003d direction)) \u003d\u003e ((not (\u003cToLeft\u003e \u003d direction)) \u003d\u003e ((\u003cToRight\u003e \u003d direction) \u003d\u003e inv_STrees_Info(mk_STrees_Info(tree, STrees_RightChild(tree, current))))))))","cases exhaustive obligation:(forall mk_STrees_Info(tree, current):STrees_Info, direction:STrees_Direction \u0026 (STrees_ExistsDirection(mk_STrees_Info(tree, current), direction) \u003d\u003e (((direction \u003d \u003cToRoot\u003e) or (direction \u003d \u003cToLeft\u003e)) or (direction \u003d \u003cToRight\u003e))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, position:nat1 \u0026 inv_STrees_Info(mk_STrees_Info(tree, current)))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info, position:nat1 \u0026 (STrees_ExistsNode(mk_STrees_Info(tree, current), position) \u003d\u003e pre_STrees_GetNode(tree, position)))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, position:nat1 \u0026 (STrees_ExistsNode(mk_STrees_Info(tree, current), position) \u003d\u003e inv_STrees_Info(mk_STrees_Info(tree, STrees_GetNode(tree, position)))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 pre_STrees_IsRoot(tree, current))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 is_(current, STrees_Node))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((not STrees_IsRoot(tree, current)) \u003d\u003e pre_STrees_Parent(tree, current)))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((not STrees_IsRoot(tree, current)) \u003d\u003e is_(current, STrees_Node)))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((not STrees_IsRoot(tree, current)) \u003d\u003e inv_STrees_Info(mk_STrees_Info(tree, STrees_Parent(tree, current)))))","legal function application obligation:(forall treeinfo:STrees_Info, pathlength:nat1 \u0026 (pre_STrees_MoveToParent(treeinfo) \u003d\u003e ((pathlength \u003e 1) \u003d\u003e pre_STrees_MoveToAnscestor(STrees_MoveToParent(treeinfo), (pathlength - 1)))))","type compatibility obligation:(forall treeinfo:STrees_Info, pathlength:nat1 \u0026 (pre_STrees_MoveToParent(treeinfo) \u003d\u003e ((pathlength \u003e 1) \u003d\u003e ((pathlength - 1) \u003e 0))))","legal function application obligation:(forall treeinfo:STrees_Info, pathlength:nat1 \u0026 (pre_STrees_MoveToParent(treeinfo) \u003d\u003e ((pathlength \u003e 1) \u003d\u003e pre_STrees_MoveToParent(treeinfo))))","legal function application obligation:(forall treeinfo:STrees_Info, pathlength:nat1 \u0026 (pre_STrees_MoveToParent(treeinfo) \u003d\u003e ((not (pathlength \u003e 1)) \u003d\u003e pre_STrees_MoveToParent(treeinfo))))","unique existence binding obligation:(forall tree:STrees_Tree \u0026 ((tree \u003c\u003e {}) \u003d\u003e (exists1 root in set tree \u0026 STrees_IsRoot(tree, root))))","legal function application obligation:(forall tree:STrees_Tree \u0026 ((tree \u003c\u003e {}) \u003d\u003e (forall root in set tree \u0026 pre_STrees_IsRoot(tree, root))))","legal function application obligation:(forall tree:STrees_Tree, node:STrees_Node \u0026 ((node in set tree) \u003d\u003e pre_STrees_IsRoot(tree, node)))","unique existence binding obligation:(forall tree:STrees_Tree, node:STrees_Node \u0026 (((node in set tree) and (not STrees_IsRoot(tree, node))) \u003d\u003e (exists1 parent in set tree \u0026 STrees_IsParentOf(tree, parent, node))))","legal function application obligation:(forall tree:STrees_Tree, node:STrees_Node \u0026 (((node in set tree) and (not STrees_IsRoot(tree, node))) \u003d\u003e (forall parent in set tree \u0026 pre_STrees_IsParentOf(tree, parent, node))))","legal function application obligation:(forall tree:STrees_Tree, parent:STrees_Node \u0026 ((parent in set tree) \u003d\u003e pre_STrees_HasLeftChild(tree, parent)))","unique existence binding obligation:(forall tree:STrees_Tree, parent:STrees_Node \u0026 (((parent in set tree) and STrees_HasLeftChild(tree, parent)) \u003d\u003e (exists1 leftchild in set tree \u0026 STrees_IsLeftChildOf(tree, leftchild, parent))))","legal function application obligation:(forall tree:STrees_Tree, parent:STrees_Node \u0026 (((parent in set tree) and STrees_HasLeftChild(tree, parent)) \u003d\u003e (forall leftchild in set tree \u0026 pre_STrees_IsLeftChildOf(tree, leftchild, parent))))","legal function application obligation:(forall tree:STrees_Tree, parent:STrees_Node \u0026 ((parent in set tree) \u003d\u003e pre_STrees_HasRightChild(tree, parent)))","unique existence binding obligation:(forall tree:STrees_Tree, parent:STrees_Node \u0026 (((parent in set tree) and STrees_HasRightChild(tree, parent)) \u003d\u003e (exists1 rightchild in set tree \u0026 STrees_IsRightChildOf(tree, rightchild, parent))))","legal function application obligation:(forall tree:STrees_Tree, parent:STrees_Node \u0026 (((parent in set tree) and STrees_HasRightChild(tree, parent)) \u003d\u003e (forall rightchild in set tree \u0026 pre_STrees_IsRightChildOf(tree, rightchild, parent))))","unique existence binding obligation:(forall tree:STrees_Tree, position:nat1 \u0026 ((exists node in set tree \u0026 ((node.position) \u003d position)) \u003d\u003e (exists1 node in set tree \u0026 ((node.position) \u003d position))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, position:nat1 \u0026 inv_STrees_Info(mk_STrees_Info(tree, current)))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info, position:nat1 \u0026 (STrees_ExistsNode(mk_STrees_Info(tree, current), position) \u003d\u003e pre_STrees_GetNode(tree, position)))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, data:STrees_Data \u0026 ((current \u003c\u003e nil) \u003d\u003e let mk_STrees_Node(-, position):[STrees_Node] \u003d current in let newcurrent:STrees_Node \u003d mk_STrees_Node(data, position) in inv_STrees_Tree(((tree \\ {current}) union {newcurrent}))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, data:STrees_Data \u0026 ((current \u003c\u003e nil) \u003d\u003e let mk_STrees_Node(-, position):[STrees_Node] \u003d current in let newcurrent:STrees_Node \u003d mk_STrees_Node(data, position) in (inv_STrees_Info(mk_STrees_Info(((tree \\ {current}) union {newcurrent}), newcurrent)) and inv_STrees_Tree(((tree \\ {current}) union {newcurrent})))))","type compatibility obligation:(forall mk_STrees_Info(-, current):STrees_Info \u0026 is_(current, STrees_Node))","type compatibility obligation:(forall mk_STrees_Info(tree, -):STrees_Info, newcurrent:STrees_Node \u0026 ((newcurrent in set tree) \u003d\u003e inv_STrees_Info(mk_STrees_Info(tree, newcurrent))))","legal function application obligation:(forall tree:STrees_Tree, parent:STrees_Node \u0026 ((parent in set tree) \u003d\u003e (forall child in set tree \u0026 pre_STrees_IsLeftChildOf(tree, child, parent))))","legal function application obligation:(forall tree:STrees_Tree, parent:STrees_Node \u0026 ((parent in set tree) \u003d\u003e (forall child in set tree \u0026 pre_STrees_IsRightChildOf(tree, child, parent))))","legal function application obligation:(forall tree:STrees_Tree, node:STrees_Node \u0026 ((node in set tree) \u003d\u003e pre_STrees_HasLeftChild(tree, node)))","legal function application obligation:(forall tree:STrees_Tree, node:STrees_Node \u0026 (((node in set tree) and STrees_HasLeftChild(tree, node)) \u003d\u003e pre_STrees_LeftChild(tree, node)))","legal function application obligation:(forall tree:STrees_Tree, node:STrees_Node \u0026 (((node in set tree) and STrees_HasLeftChild(tree, node)) \u003d\u003e let leftchild:STrees_Node \u003d STrees_LeftChild(tree, node) in pre_STrees_Subtree(tree, leftchild)))","unique existence binding obligation:(forall tree:STrees_Tree, node:STrees_Node \u0026 (((node in set tree) and STrees_HasLeftChild(tree, node)) \u003d\u003e let leftchild:STrees_Node \u003d STrees_LeftChild(tree, node) in let left:STrees_Tree \u003d STrees_Subtree(tree, leftchild) in let rightpath:set of (STrees_Node) \u003d {n | n in set left \u0026 (exists p in set {0, ... ,(card left)} \u0026 ((n.position) \u003d ((((leftchild.position) + 1) * (2 ** p)) - 1)))} in (exists1 pred in set rightpath \u0026 (forall n in set rightpath \u0026 ((n.position) \u003c\u003d (pred.position))))))","function establishes postcondition obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 (pre_STrees_Delete(mk_STrees_Info(tree, current)) \u003d\u003e post_STrees_Delete(mk_STrees_Info(tree, current), let old:STrees_Tree \u003d STrees_Subtree(tree, current) in (if (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))\nthen let leftchild:STrees_Node \u003d STrees_LeftChild(tree, current), rightchild:STrees_Node \u003d STrees_RightChild(tree, current), left:STrees_Tree \u003d STrees_Subtree(old, leftchild), mk_STrees_Node(-, position):STrees_Node \u003d STrees_InOrderPredecessor(old, current), newright:STrees_Tree \u003d STrees_MoveSubtree(old, rightchild, ((2 * position) + 1)), newleft:STrees_Tree \u003d (left union newright), new:STrees_Tree \u003d STrees_MoveSubtree(newleft, STrees_Root(newleft), (current.position)) in mk_STrees_Info(((tree \\ old) union new), STrees_Root(new))\nelseif STrees_HasLeftChild(tree, current)\nthen let leftchild:STrees_Node \u003d STrees_LeftChild(tree, current), new:STrees_Tree \u003d STrees_MoveSubtree(old, leftchild, (current.position)) in mk_STrees_Info(((tree \\ old) union new), STrees_Root(new))\nelseif STrees_HasRightChild(tree, current)\nthen let rightchild:STrees_Node \u003d STrees_RightChild(tree, current), new:STrees_Tree \u003d STrees_MoveSubtree(old, rightchild, (current.position)) in mk_STrees_Info(((tree \\ old) union new), STrees_Root(new))\nelse mk_STrees_Info((tree \\ {current}), STrees_Parent(tree, current))))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e pre_STrees_Subtree(tree, current)))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e is_(current, STrees_Node)))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in pre_STrees_HasRightChild(tree, current)))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in is_(current, STrees_Node)))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in (STrees_HasRightChild(tree, current) \u003d\u003e pre_STrees_HasLeftChild(tree, current))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in (STrees_HasRightChild(tree, current) \u003d\u003e is_(current, STrees_Node))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current)) \u003d\u003e pre_STrees_LeftChild(tree, current))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current)) \u003d\u003e is_(current, STrees_Node))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current)) \u003d\u003e pre_STrees_RightChild(tree, current))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current)) \u003d\u003e is_(current, STrees_Node))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current)) \u003d\u003e pre_STrees_Subtree(old, leftchild))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current)) \u003d\u003e pre_STrees_InOrderPredecessor(old, current))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current)) \u003d\u003e is_(current, STrees_Node))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current)) \u003d\u003e pre_STrees_MoveSubtree(old, rightchild, ((2 * position) + 1)))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current)) \u003d\u003e pre_STrees_MoveSubtree(newleft, STrees_Root(newleft), (current.position)))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current)) \u003d\u003e pre_STrees_Root(newleft))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current)) \u003d\u003e let leftchild:STrees_Node \u003d STrees_LeftChild(tree, current), rightchild:STrees_Node \u003d STrees_RightChild(tree, current), left:STrees_Tree \u003d STrees_Subtree(old, leftchild), mk_STrees_Node(-, position):STrees_Node \u003d STrees_InOrderPredecessor(old, current), newright:STrees_Tree \u003d STrees_MoveSubtree(old, rightchild, ((2 * position) + 1)), newleft:STrees_Tree \u003d (left union newright), new:STrees_Tree \u003d STrees_MoveSubtree(newleft, STrees_Root(newleft), (current.position)) in pre_STrees_Root(new))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current)) \u003d\u003e let leftchild:STrees_Node \u003d STrees_LeftChild(tree, current), rightchild:STrees_Node \u003d STrees_RightChild(tree, current), left:STrees_Tree \u003d STrees_Subtree(old, leftchild), mk_STrees_Node(-, position):STrees_Node \u003d STrees_InOrderPredecessor(old, current), newright:STrees_Tree \u003d STrees_MoveSubtree(old, rightchild, ((2 * position) + 1)), newleft:STrees_Tree \u003d (left union newright), new:STrees_Tree \u003d STrees_MoveSubtree(newleft, STrees_Root(newleft), (current.position)) in inv_STrees_Info(mk_STrees_Info(((tree \\ old) union new), STrees_Root(new))))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((not (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))) \u003d\u003e (STrees_HasLeftChild(tree, current) \u003d\u003e pre_STrees_LeftChild(tree, current)))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((not (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))) \u003d\u003e (STrees_HasLeftChild(tree, current) \u003d\u003e is_(current, STrees_Node)))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((not (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))) \u003d\u003e (STrees_HasLeftChild(tree, current) \u003d\u003e pre_STrees_MoveSubtree(old, leftchild, (current.position))))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((not (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))) \u003d\u003e (STrees_HasLeftChild(tree, current) \u003d\u003e let leftchild:STrees_Node \u003d STrees_LeftChild(tree, current), new:STrees_Tree \u003d STrees_MoveSubtree(old, leftchild, (current.position)) in pre_STrees_Root(new)))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((not (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))) \u003d\u003e (STrees_HasLeftChild(tree, current) \u003d\u003e let leftchild:STrees_Node \u003d STrees_LeftChild(tree, current), new:STrees_Tree \u003d STrees_MoveSubtree(old, leftchild, (current.position)) in inv_STrees_Info(mk_STrees_Info(((tree \\ old) union new), STrees_Root(new)))))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((not (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))) \u003d\u003e ((not STrees_HasLeftChild(tree, current)) \u003d\u003e (STrees_HasRightChild(tree, current) \u003d\u003e pre_STrees_RightChild(tree, current))))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((not (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))) \u003d\u003e ((not STrees_HasLeftChild(tree, current)) \u003d\u003e (STrees_HasRightChild(tree, current) \u003d\u003e is_(current, STrees_Node))))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((not (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))) \u003d\u003e ((not STrees_HasLeftChild(tree, current)) \u003d\u003e (STrees_HasRightChild(tree, current) \u003d\u003e pre_STrees_MoveSubtree(old, rightchild, (current.position)))))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((not (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))) \u003d\u003e ((not STrees_HasLeftChild(tree, current)) \u003d\u003e (STrees_HasRightChild(tree, current) \u003d\u003e let rightchild:STrees_Node \u003d STrees_RightChild(tree, current), new:STrees_Tree \u003d STrees_MoveSubtree(old, rightchild, (current.position)) in pre_STrees_Root(new))))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((not (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))) \u003d\u003e ((not STrees_HasLeftChild(tree, current)) \u003d\u003e (STrees_HasRightChild(tree, current) \u003d\u003e let rightchild:STrees_Node \u003d STrees_RightChild(tree, current), new:STrees_Tree \u003d STrees_MoveSubtree(old, rightchild, (current.position)) in inv_STrees_Info(mk_STrees_Info(((tree \\ old) union new), STrees_Root(new))))))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((not (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))) \u003d\u003e ((not STrees_HasLeftChild(tree, current)) \u003d\u003e ((not STrees_HasRightChild(tree, current)) \u003d\u003e pre_STrees_Parent(tree, current))))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((not (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))) \u003d\u003e ((not STrees_HasLeftChild(tree, current)) \u003d\u003e ((not STrees_HasRightChild(tree, current)) \u003d\u003e is_(current, STrees_Node))))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info \u0026 ((current \u003c\u003e nil) \u003d\u003e let old:STrees_Tree \u003d STrees_Subtree(tree, current) in ((not (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))) \u003d\u003e ((not STrees_HasLeftChild(tree, current)) \u003d\u003e ((not STrees_HasRightChild(tree, current)) \u003d\u003e inv_STrees_Info(mk_STrees_Info((tree \\ {current}), STrees_Parent(tree, current))))))))","type compatibility obligation:(forall tree:STrees_Tree, mk_STrees_Node(rootdata, rootpos):STrees_Node \u0026 ((mk_STrees_Node(rootdata, rootpos) in set tree) \u003d\u003e inv_STrees_Tree({mk_STrees_Node(d, p) | mk_STrees_Node(d, p) in set tree \u0026 (exists1 n in set {0, ... ,(card tree)} \u0026 ((p \u003e\u003d (rootpos * (2 ** n))) and (p \u003c ((rootpos + 1) * (2 ** n)))))})))","legal function application obligation:(forall tree:STrees_Tree, subtreeRoot:STrees_Node, newRootPos:nat1 \u0026 ((subtreeRoot in set tree) \u003d\u003e pre_STrees_Subtree(tree, subtreeRoot)))","type compatibility obligation:(forall tree:STrees_Tree, subtreeRoot:STrees_Node, newRootPos:nat1 \u0026 ((subtreeRoot in set tree) \u003d\u003e inv_STrees_Tree(let subtree:STrees_Tree \u003d STrees_Subtree(tree, subtreeRoot), mk_STrees_Node(-, oldRootPos):STrees_Node \u003d subtreeRoot in {STrees_MoveNode(tree, node, oldRootPos, newRootPos) | node in set subtree})))","unique existence binding obligation:(forall tree:STrees_Tree, mk_STrees_Node(d, p):STrees_Node, oldRootPos:nat1, newRootPos:nat1 \u0026 (exists1 n in set {0, ... ,(card tree)} \u0026 ((p \u003e\u003d (oldRootPos * (2 ** n))) and (p \u003c ((oldRootPos + 1) * (2 ** n))))))","type compatibility obligation:(forall tree:STrees_Tree, mk_STrees_Node(d, p):STrees_Node, oldRootPos:nat1, newRootPos:nat1 \u0026 let n:nat \u003d (iota n in set {0, ... ,(card tree)} \u0026 ((p \u003e\u003d (oldRootPos * (2 ** n))) and (p \u003c ((oldRootPos + 1) * (2 ** n))))) in ((((newRootPos * (2 ** n)) + p) - (oldRootPos * (2 ** n))) \u003e 0))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info, direction:STrees_Direction \u0026 ((not (\u003cToRoot\u003e \u003d direction)) \u003d\u003e ((\u003cToLeft\u003e \u003d direction) \u003d\u003e ((current \u003c\u003e nil) \u003d\u003e pre_STrees_HasLeftChild(tree, current)))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, direction:STrees_Direction \u0026 ((not (\u003cToRoot\u003e \u003d direction)) \u003d\u003e ((\u003cToLeft\u003e \u003d direction) \u003d\u003e ((current \u003c\u003e nil) \u003d\u003e is_(current, STrees_Node)))))","legal function application obligation:(forall mk_STrees_Info(tree, current):STrees_Info, direction:STrees_Direction \u0026 ((not (\u003cToRoot\u003e \u003d direction)) \u003d\u003e ((not (\u003cToLeft\u003e \u003d direction)) \u003d\u003e ((\u003cToRight\u003e \u003d direction) \u003d\u003e ((current \u003c\u003e nil) \u003d\u003e pre_STrees_HasRightChild(tree, current))))))","type compatibility obligation:(forall mk_STrees_Info(tree, current):STrees_Info, direction:STrees_Direction \u0026 ((not (\u003cToRoot\u003e \u003d direction)) \u003d\u003e ((not (\u003cToLeft\u003e \u003d direction)) \u003d\u003e ((\u003cToRight\u003e \u003d direction) \u003d\u003e ((current \u003c\u003e nil) \u003d\u003e is_(current, STrees_Node))))))","cases exhaustive obligation:(forall mk_STrees_Info(tree, current):STrees_Info, direction:STrees_Direction \u0026 (((direction \u003d \u003cToRoot\u003e) or (direction \u003d \u003cToLeft\u003e)) or (direction \u003d \u003cToRight\u003e)))","legal function application obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr \u0026 ((child \u003c\u003e NIL) \u003d\u003e pre_Nodes_GetParent(Heaps_Retrieve(heap, child))))","type compatibility obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr \u0026 ((child \u003c\u003e NIL) \u003d\u003e ((is_(Heaps_Retrieve(heap, child), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, child), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, child), Nodes_SingleLink))))","legal function application obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr \u0026 ((child \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, child)))","legal function application obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr \u0026 ((child \u003c\u003e NIL) \u003d\u003e let parent:Nodes_NodePtr \u003d Nodes_GetParent(Heaps_Retrieve(heap, child)) in ((not (parent \u003d NIL)) \u003d\u003e (Trees_IsRightChildOf(heap, child, parent) \u003d\u003e pre_Trees_Position(heap, parent)))))","legal function application obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr \u0026 ((child \u003c\u003e NIL) \u003d\u003e let parent:Nodes_NodePtr \u003d Nodes_GetParent(Heaps_Retrieve(heap, child)) in ((not (parent \u003d NIL)) \u003d\u003e ((not Trees_IsRightChildOf(heap, child, parent)) \u003d\u003e pre_Trees_Position(heap, parent)))))","legal function application obligation:(forall heap:Heaps_Heap, mk_Trees_Tree(treePtr, current):Trees_Tree \u0026 ((treePtr \u003c\u003e NIL) \u003d\u003e pre_STrees_MkTree(Trees_SubtreeToSet(heap, treePtr, 1))))","legal function application obligation:(forall heap:Heaps_Heap, mk_Trees_Tree(treePtr, current):Trees_Tree \u0026 ((treePtr \u003c\u003e NIL) \u003d\u003e let treeset:STrees_Tree \u003d STrees_MkTree(Trees_SubtreeToSet(heap, treePtr, 1)) in pre_Nodes_GetData(Heaps_Retrieve(heap, current))))","type compatibility obligation:(forall heap:Heaps_Heap, mk_Trees_Tree(treePtr, current):Trees_Tree \u0026 ((treePtr \u003c\u003e NIL) \u003d\u003e let treeset:STrees_Tree \u003d STrees_MkTree(Trees_SubtreeToSet(heap, treePtr, 1)) in ((is_(Heaps_Retrieve(heap, current), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, current), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, current), Nodes_SingleLink))))","legal function application obligation:(forall heap:Heaps_Heap, mk_Trees_Tree(treePtr, current):Trees_Tree \u0026 ((treePtr \u003c\u003e NIL) \u003d\u003e let treeset:STrees_Tree \u003d STrees_MkTree(Trees_SubtreeToSet(heap, treePtr, 1)) in pre_Heaps_Retrieve(heap, current)))","legal function application obligation:(forall heap:Heaps_Heap, mk_Trees_Tree(treePtr, current):Trees_Tree \u0026 ((treePtr \u003c\u003e NIL) \u003d\u003e let treeset:STrees_Tree \u003d STrees_MkTree(Trees_SubtreeToSet(heap, treePtr, 1)) in let data:Nodes_Data \u003d Nodes_GetData(Heaps_Retrieve(heap, current)) in pre_Trees_Position(heap, current)))","legal function application obligation:(forall heap:Heaps_Heap, mk_Trees_Tree(treePtr, current):Trees_Tree \u0026 ((treePtr \u003c\u003e NIL) \u003d\u003e let treeset:STrees_Tree \u003d STrees_MkTree(Trees_SubtreeToSet(heap, treePtr, 1)) in let data:Nodes_Data \u003d Nodes_GetData(Heaps_Retrieve(heap, current)) in let position:nat1 \u003d Trees_Position(heap, current) in let currentnode:STrees_Node \u003d STrees_MkNode(data, position) in pre_STrees_MkInfo(treeset, currentnode)))","legal function application obligation:(forall heap:Heaps_Heap, subtree:Nodes_NodePtr, position:nat1 \u0026 ((subtree \u003c\u003e NIL) \u003d\u003e pre_Nodes_GetData(Heaps_Retrieve(heap, subtree))))","type compatibility obligation:(forall heap:Heaps_Heap, subtree:Nodes_NodePtr, position:nat1 \u0026 ((subtree \u003c\u003e NIL) \u003d\u003e ((is_(Heaps_Retrieve(heap, subtree), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, subtree), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, subtree), Nodes_SingleLink))))","legal function application obligation:(forall heap:Heaps_Heap, subtree:Nodes_NodePtr, position:nat1 \u0026 ((subtree \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, subtree)))","legal function application obligation:(forall heap:Heaps_Heap, subtree:Nodes_NodePtr, position:nat1 \u0026 ((subtree \u003c\u003e NIL) \u003d\u003e pre_Nodes_GetLeft(Heaps_Retrieve(heap, subtree))))","type compatibility obligation:(forall heap:Heaps_Heap, subtree:Nodes_NodePtr, position:nat1 \u0026 ((subtree \u003c\u003e NIL) \u003d\u003e ((is_(Heaps_Retrieve(heap, subtree), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, subtree), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, subtree), Nodes_SingleLink))))","legal function application obligation:(forall heap:Heaps_Heap, subtree:Nodes_NodePtr, position:nat1 \u0026 ((subtree \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, subtree)))","legal function application obligation:(forall heap:Heaps_Heap, subtree:Nodes_NodePtr, position:nat1 \u0026 ((subtree \u003c\u003e NIL) \u003d\u003e pre_Nodes_GetRight(Heaps_Retrieve(heap, subtree))))","type compatibility obligation:(forall heap:Heaps_Heap, subtree:Nodes_NodePtr, position:nat1 \u0026 ((subtree \u003c\u003e NIL) \u003d\u003e ((is_(Heaps_Retrieve(heap, subtree), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, subtree), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, subtree), Nodes_SingleLink))))","legal function application obligation:(forall heap:Heaps_Heap, subtree:Nodes_NodePtr, position:nat1 \u0026 ((subtree \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, subtree)))","legal function application obligation:(forall heap:Heaps_Heap, ptr:Nodes_NodePtr \u0026 (((ptr \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, ptr)) \u003d\u003e ((ptr \u003c\u003e NIL) \u003d\u003e pre_Nodes_GetLeft(Heaps_Retrieve(heap, ptr)))))","type compatibility obligation:(forall heap:Heaps_Heap, ptr:Nodes_NodePtr \u0026 (((ptr \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, ptr)) \u003d\u003e ((ptr \u003c\u003e NIL) \u003d\u003e ((is_(Heaps_Retrieve(heap, ptr), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, ptr), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, ptr), Nodes_SingleLink)))))","legal function application obligation:(forall heap:Heaps_Heap, ptr:Nodes_NodePtr \u0026 (((ptr \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, ptr)) \u003d\u003e ((ptr \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, ptr))))","legal function application obligation:(forall heap:Heaps_Heap, ptr:Nodes_NodePtr \u0026 (((ptr \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, ptr)) \u003d\u003e ((ptr \u003c\u003e NIL) \u003d\u003e pre_Nodes_GetRight(Heaps_Retrieve(heap, ptr)))))","type compatibility obligation:(forall heap:Heaps_Heap, ptr:Nodes_NodePtr \u0026 (((ptr \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, ptr)) \u003d\u003e ((ptr \u003c\u003e NIL) \u003d\u003e ((is_(Heaps_Retrieve(heap, ptr), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, ptr), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, ptr), Nodes_SingleLink)))))","legal function application obligation:(forall heap:Heaps_Heap, ptr:Nodes_NodePtr \u0026 (((ptr \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, ptr)) \u003d\u003e ((ptr \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, ptr))))","legal function application obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr, parent:Nodes_NodePtr \u0026 ((pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child)) \u003d\u003e pre_Nodes_GetRight(Heaps_Retrieve(heap, parent))))","type compatibility obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr, parent:Nodes_NodePtr \u0026 ((pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child)) \u003d\u003e ((is_(Heaps_Retrieve(heap, parent), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, parent), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, parent), Nodes_SingleLink))))","legal function application obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr, parent:Nodes_NodePtr \u0026 ((pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child)) \u003d\u003e pre_Heaps_Retrieve(heap, parent)))","legal function application obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr, parent:Nodes_NodePtr \u0026 ((pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child)) \u003d\u003e ((child \u003d Nodes_GetRight(Heaps_Retrieve(heap, parent))) \u003d\u003e pre_Nodes_GetParent(Heaps_Retrieve(heap, child)))))","type compatibility obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr, parent:Nodes_NodePtr \u0026 ((pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child)) \u003d\u003e ((child \u003d Nodes_GetRight(Heaps_Retrieve(heap, parent))) \u003d\u003e ((is_(Heaps_Retrieve(heap, child), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, child), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, child), Nodes_SingleLink)))))","legal function application obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr, parent:Nodes_NodePtr \u0026 ((pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child)) \u003d\u003e ((child \u003d Nodes_GetRight(Heaps_Retrieve(heap, parent))) \u003d\u003e pre_Heaps_Retrieve(heap, child))))","legal function application obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr, parent:Nodes_NodePtr \u0026 ((pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child)) \u003d\u003e pre_Nodes_GetLeft(Heaps_Retrieve(heap, parent))))","type compatibility obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr, parent:Nodes_NodePtr \u0026 ((pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child)) \u003d\u003e ((is_(Heaps_Retrieve(heap, parent), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, parent), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, parent), Nodes_SingleLink))))","legal function application obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr, parent:Nodes_NodePtr \u0026 ((pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child)) \u003d\u003e pre_Heaps_Retrieve(heap, parent)))","legal function application obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr, parent:Nodes_NodePtr \u0026 ((pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child)) \u003d\u003e ((child \u003d Nodes_GetLeft(Heaps_Retrieve(heap, parent))) \u003d\u003e pre_Nodes_GetParent(Heaps_Retrieve(heap, child)))))","type compatibility obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr, parent:Nodes_NodePtr \u0026 ((pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child)) \u003d\u003e ((child \u003d Nodes_GetLeft(Heaps_Retrieve(heap, parent))) \u003d\u003e ((is_(Heaps_Retrieve(heap, child), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, child), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, child), Nodes_SingleLink)))))","legal function application obligation:(forall heap:Heaps_Heap, child:Nodes_NodePtr, parent:Nodes_NodePtr \u0026 ((pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child)) \u003d\u003e ((child \u003d Nodes_GetLeft(Heaps_Retrieve(heap, parent))) \u003d\u003e pre_Heaps_Retrieve(heap, child))))","legal function application obligation:(forall heap:Heaps_Heap, ptr:Nodes_NodePtr \u0026 ((ptr \u003c\u003e NIL) \u003d\u003e pre_Nodes_GetParent(Heaps_Retrieve(heap, ptr))))","type compatibility obligation:(forall heap:Heaps_Heap, ptr:Nodes_NodePtr \u0026 ((ptr \u003c\u003e NIL) \u003d\u003e ((is_(Heaps_Retrieve(heap, ptr), Nodes_BinaryTree) or is_(Heaps_Retrieve(heap, ptr), Nodes_DoubleLink)) or is_(Heaps_Retrieve(heap, ptr), Nodes_SingleLink))))","legal function application obligation:(forall heap:Heaps_Heap, ptr:Nodes_NodePtr \u0026 ((ptr \u003c\u003e NIL) \u003d\u003e pre_Heaps_Retrieve(heap, ptr)))","legal function application obligation:(forall tree:Trees_Tree, data:Trees_Data, direction:Trees_Direction, oldstate:SystemState \u0026 ((Heaps_Available(heap) and let mk_Trees_Tree(treePtr, current):Trees_Tree \u003d tree in (((direction \u003d \u003cToRoot\u003e) \u003d\u003e (treePtr \u003d NIL)) and (((direction \u003d \u003cToRight\u003e) \u003d\u003e (not Trees_HasRightChild(heap, current))) and ((direction \u003d \u003cToLeft\u003e) \u003d\u003e (not Trees_HasLeftChild(heap, current)))))) \u003d\u003e (Heaps_Available(heap) \u003d\u003e let mk_Trees_Tree(treePtr, current):Trees_Tree \u003d tree in (((direction \u003d \u003cToRoot\u003e) \u003d\u003e (treePtr \u003d NIL)) \u003d\u003e ((direction \u003d \u003cToRight\u003e) \u003d\u003e pre_Trees_HasRightChild(heap, current))))))","legal function application obligation:(forall tree:Trees_Tree, data:Trees_Data, direction:Trees_Direction, oldstate:SystemState \u0026 ((Heaps_Available(heap) and let mk_Trees_Tree(treePtr, current):Trees_Tree \u003d tree in (((direction \u003d \u003cToRoot\u003e) \u003d\u003e (treePtr \u003d NIL)) and (((direction \u003d \u003cToRight\u003e) \u003d\u003e (not Trees_HasRightChild(heap, current))) and ((direction \u003d \u003cToLeft\u003e) \u003d\u003e (not Trees_HasLeftChild(heap, current)))))) \u003d\u003e (Heaps_Available(heap) \u003d\u003e let mk_Trees_Tree(treePtr, current):Trees_Tree \u003d tree in (((direction \u003d \u003cToRoot\u003e) \u003d\u003e (treePtr \u003d NIL)) \u003d\u003e (((direction \u003d \u003cToRight\u003e) \u003d\u003e (not Trees_HasRightChild(heap, current))) \u003d\u003e ((direction \u003d \u003cToLeft\u003e) \u003d\u003e pre_Trees_HasLeftChild(heap, current)))))))","legal function application obligation:(forall tree:Trees_Tree, data:Trees_Data, direction:Trees_Direction, oldstate:SystemState \u0026 ((Heaps_Available(heap) and let mk_Trees_Tree(treePtr, current):Trees_Tree \u003d tree in (((direction \u003d \u003cToRoot\u003e) \u003d\u003e (treePtr \u003d NIL)) and (((direction \u003d \u003cToRight\u003e) \u003d\u003e (not Trees_HasRightChild(heap, current))) and ((direction \u003d \u003cToLeft\u003e) \u003d\u003e (not Trees_HasLeftChild(heap, current)))))) \u003d\u003e (((Heaps_AmountUsed(heap~) + 1) \u003d Heaps_AmountUsed(heap)) \u003d\u003e let old:STrees_Info \u003d Trees_Set(heap~, tree) in pre_STrees_Insert(old, data, direction))))","operation establishes postcondition obligation:(forall tree:Trees_Tree, data:Trees_Data, direction:Trees_Direction, oldstate:SystemState \u0026 ((Heaps_Available(heap) and let mk_Trees_Tree(treePtr, current):Trees_Tree \u003d tree in (((direction \u003d \u003cToRoot\u003e) \u003d\u003e (treePtr \u003d NIL)) and (((direction \u003d \u003cToRight\u003e) \u003d\u003e (not Trees_HasRightChild(heap, current))) and ((direction \u003d \u003cToLeft\u003e) \u003d\u003e (not Trees_HasLeftChild(heap, current)))))) \u003d\u003e (((Heaps_AmountUsed(heap~) + 1) \u003d Heaps_AmountUsed(heap)) and let old:STrees_Info \u003d Trees_Set(heap~, tree) in (STrees_Insert(old, data, direction) \u003d Trees_Set(heap, RESULT)))))","legal function application obligation:(forall ptr:Nodes_NodePtr, oldstate:SystemState \u0026 (Trees_HasLeftChild(heap, ptr) \u003d\u003e pre_Trees_HasLeftChild(heap, ptr)))","while loop termination obligation:...","legal function application obligation:(forall ptr:Nodes_NodePtr, oldstate:SystemState \u0026 (Trees_HasLeftChild(heap, ptr) \u003d\u003e pre_Trees_HasRightChild(heap, pred)))","legal function application obligation:(forall mk_Trees_Tree(treePtr, current):Trees_Tree, oldstate:SystemState \u0026 ((treePtr \u003c\u003e NIL) \u003d\u003e pre_Trees_HasLeftChild(heap, current)))","legal function application obligation:(forall mk_Trees_Tree(treePtr, current):Trees_Tree, oldstate:SystemState \u0026 ((treePtr \u003c\u003e NIL) \u003d\u003e pre_Trees_HasRightChild(heap, current)))","legal function application obligation:(forall mk_Trees_Tree(treePtr, current):Trees_Tree, oldstate:SystemState \u0026 ((treePtr \u003c\u003e NIL) \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e pre_Trees_IsRoot(heap, current))))))","legal function application obligation:(forall mk_Trees_Tree(treePtr, current):Trees_Tree, oldstate:SystemState \u0026 ((treePtr \u003c\u003e NIL) \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e pre_Trees_IsRightChildOf(heap, current, parent))))))","operation call obligation:(forall mk_Trees_Tree(treePtr, current):Trees_Tree, oldstate:SystemState \u0026 ((treePtr \u003c\u003e NIL) \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e pre_Heaps_ModifyLoc(heap, address, mk_Heaps_Location(nil, false)))))))))","legal function application obligation:(forall mk_Trees_Tree(treePtr, current):Trees_Tree, oldstate:SystemState \u0026 ((treePtr \u003c\u003e NIL) \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e ((Heaps_AmountUsed(heap~) \u003d (Heaps_AmountUsed(heap) + 1)) \u003d\u003e let old:STrees_Info \u003d Trees_Set(heap~, mk_Trees_Tree(treePtr, current)) in pre_STrees_Delete(old))))))))))","operation establishes postcondition obligation:(forall mk_Trees_Tree(treePtr, current):Trees_Tree, oldstate:SystemState \u0026 ((treePtr \u003c\u003e NIL) \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e (true \u003d\u003e ((Heaps_AmountUsed(heap~) \u003d (Heaps_AmountUsed(heap) + 1)) and let old:STrees_Info \u003d Trees_Set(heap~, mk_Trees_Tree(treePtr, current)) in (STrees_Delete(old) \u003d Trees_Set(heap, RESULT)))))))))))","operation establishes postcondition obligation:(forall tree:Trees_Tree, data:Trees_Data, oldstate:SystemState \u0026 (true \u003d\u003e (STrees_ExistsData(Trees_Set(heap, tree), data) \u003d RESULT)))","legal function application obligation:(forall tree:Trees_Tree, direction:Trees_Direction, oldstate:SystemState \u0026 (((tree.current) \u003c\u003e NIL) \u003d\u003e pre_Trees_HasLeftChild(heap, (tree.current))))","legal function application obligation:(forall tree:Trees_Tree, direction:Trees_Direction, oldstate:SystemState \u0026 (((tree.current) \u003c\u003e NIL) \u003d\u003e pre_Trees_HasRightChild(heap, (tree.current))))","operation establishes postcondition obligation:(forall tree:Trees_Tree, direction:Trees_Direction, oldstate:SystemState \u0026 (STrees_ExistsDirection(Trees_Set(heap, tree), direction) \u003d RESULT))","legal function application obligation:(forall tree:Trees_Tree, oldstate:SystemState \u0026 (((tree.treePtr) \u003c\u003e NIL) \u003d\u003e (true \u003d\u003e pre_STrees_GetCurrentData(Trees_Set(heap, tree)))))","operation establishes postcondition obligation:(forall tree:Trees_Tree, oldstate:SystemState \u0026 (((tree.treePtr) \u003c\u003e NIL) \u003d\u003e (true \u003d\u003e (STrees_GetCurrentData(Trees_Set(heap, tree)) \u003d RESULT))))","legal function application obligation:(forall tree:Trees_Tree, data:Trees_Data, oldstate:SystemState \u0026 (((tree.treePtr) \u003c\u003e NIL) \u003d\u003e (true \u003d\u003e pre_STrees_StoreCurrentData(Trees_Set(heap~, tree), data))))","operation establishes postcondition obligation:(forall tree:Trees_Tree, data:Trees_Data, oldstate:SystemState \u0026 (((tree.treePtr) \u003c\u003e NIL) \u003d\u003e (true \u003d\u003e (STrees_StoreCurrentData(Trees_Set(heap~, tree), data) \u003d Trees_Set(heap, RESULT)))))","legal function application obligation:(forall tree:Trees_Tree, direction:Trees_Direction, oldstate:SystemState \u0026 ((((tree.treePtr) \u003c\u003e NIL) and (((direction \u003d \u003cToLeft\u003e) \u003d\u003e Trees_HasLeftChild(heap, (tree.current))) and ((direction \u003d \u003cToRight\u003e) \u003d\u003e Trees_HasRightChild(heap, (tree.current))))) \u003d\u003e (((tree.treePtr) \u003c\u003e NIL) \u003d\u003e ((direction \u003d \u003cToLeft\u003e) \u003d\u003e pre_Trees_HasLeftChild(heap, (tree.current))))))","legal function application obligation:(forall tree:Trees_Tree, direction:Trees_Direction, oldstate:SystemState \u0026 ((((tree.treePtr) \u003c\u003e NIL) and (((direction \u003d \u003cToLeft\u003e) \u003d\u003e Trees_HasLeftChild(heap, (tree.current))) and ((direction \u003d \u003cToRight\u003e) \u003d\u003e Trees_HasRightChild(heap, (tree.current))))) \u003d\u003e (((tree.treePtr) \u003c\u003e NIL) \u003d\u003e (((direction \u003d \u003cToLeft\u003e) \u003d\u003e Trees_HasLeftChild(heap, (tree.current))) \u003d\u003e ((direction \u003d \u003cToRight\u003e) \u003d\u003e pre_Trees_HasRightChild(heap, (tree.current)))))))","legal function application obligation:(forall tree:Trees_Tree, direction:Trees_Direction, oldstate:SystemState \u0026 ((((tree.treePtr) \u003c\u003e NIL) and (((direction \u003d \u003cToLeft\u003e) \u003d\u003e Trees_HasLeftChild(heap, (tree.current))) and ((direction \u003d \u003cToRight\u003e) \u003d\u003e Trees_HasRightChild(heap, (tree.current))))) \u003d\u003e pre_STrees_MoveInDir(Trees_Set(heap~, tree), direction)))","operation establishes postcondition obligation:(forall tree:Trees_Tree, direction:Trees_Direction, oldstate:SystemState \u0026 ((((tree.treePtr) \u003c\u003e NIL) and (((direction \u003d \u003cToLeft\u003e) \u003d\u003e Trees_HasLeftChild(heap, (tree.current))) and ((direction \u003d \u003cToRight\u003e) \u003d\u003e Trees_HasRightChild(heap, (tree.current))))) \u003d\u003e (STrees_MoveInDir(Trees_Set(heap~, tree), direction) \u003d Trees_Set(heap, RESULT))))","legal function application obligation:(forall tree:Trees_Tree, oldstate:SystemState \u0026 ((not Trees_IsRoot(heap, (tree.current))) \u003d\u003e pre_Trees_IsRoot(heap, (tree.current))))","legal function application obligation:(forall tree:Trees_Tree, oldstate:SystemState \u0026 ((not Trees_IsRoot(heap, (tree.current))) \u003d\u003e pre_STrees_MoveToParent(Trees_Set(heap~, tree))))","operation establishes postcondition obligation:(forall tree:Trees_Tree, oldstate:SystemState \u0026 ((not Trees_IsRoot(heap, (tree.current))) \u003d\u003e (STrees_MoveToParent(Trees_Set(heap~, tree)) \u003d Trees_Set(heap, RESULT))))","operation establishes postcondition obligation:(forall tree:Trees_Tree, oldstate:SystemState \u0026 (true \u003d\u003e (STrees_Size(Trees_Set(heap~, tree)) \u003d RESULT)))","operation establishes postcondition obligation:(forall tree:Trees_Tree, traversal:(Trees_Data -\u003e Trees_Data), oldstate:SystemState \u0026 (true \u003d\u003e (STrees_Traverse(Trees_Set(heap~, tree), traversal) \u003d Trees_Set(heap, RESULT))))","legal function application obligation:(forall subtree:Nodes_NodePtr, traversal:(Trees_Data -\u003e Trees_Data), oldstate:SystemState \u0026 pre_(traversalDATA(subtree)))","legal function application obligation:pre_STrees_MkTree({STrees_MkNode(\u0027a\u0027, 1), STrees_MkNode(\u0027b\u0027, 2), STrees_MkNode(\u0027c\u0027, 3), STrees_MkNode(\u0027d\u0027, 4), STrees_MkNode(\u0027e\u0027, 5), STrees_MkNode(\u0027f\u0027, 6), STrees_MkNode(\u0027g\u0027, 7), STrees_MkNode(\u0027h\u0027, 8), STrees_MkNode(\u0027i\u0027, 9), STrees_MkNode(\u0027j\u0027, 10), STrees_MkNode(\u0027k\u0027, 11), STrees_MkNode(\u0027l\u0027, 12), STrees_MkNode(\u0027m\u0027, 13), STrees_MkNode(\u0027n\u0027, 14), STrees_MkNode(\u0027o\u0027, 15), STrees_MkNode(\u0027p\u0027, 16), STrees_MkNode(\u0027q\u0027, 17), STrees_MkNode(\u0027r\u0027, 18), STrees_MkNode(\u0027s\u0027, 19), STrees_MkNode(\u0027t\u0027, 20), STrees_MkNode(\u0027u\u0027, 21), STrees_MkNode(\u0027v\u0027, 22), STrees_MkNode(\u0027w\u0027, 23), STrees_MkNode(\u0027x\u0027, 24), STrees_MkNode(\u0027y\u0027, 25), STrees_MkNode(\u0027z\u0027, 26)})","legal function application obligation:pre_STrees_MkTree({STrees_MkNode(\u0027a\u0027, 1), STrees_MkNode(\u0027d\u0027, 2), STrees_MkNode(\u0027c\u0027, 3), STrees_MkNode(\u0027h\u0027, 4), STrees_MkNode(\u0027i\u0027, 5), STrees_MkNode(\u0027f\u0027, 6), STrees_MkNode(\u0027o\u0027, 7), STrees_MkNode(\u0027p\u0027, 8), STrees_MkNode(\u0027r\u0027, 10), STrees_MkNode(\u0027s\u0027, 11), STrees_MkNode(\u0027l\u0027, 12), STrees_MkNode(\u0027z\u0027, 13), STrees_MkNode(\u0027j\u0027, 23), STrees_MkNode(\u0027x\u0027, 24), STrees_MkNode(\u0027y\u0027, 25), STrees_MkNode(\u0027t\u0027, 46), STrees_MkNode(\u0027u\u0027, 47), STrees_MkNode(\u0027k\u0027, 95), STrees_MkNode(\u0027v\u0027, 190), STrees_MkNode(\u0027w\u0027, 191)})","legal function application obligation:pre_STrees_MkTree({STrees_MkNode(\u0027a\u0027, 1), STrees_MkNode(\u0027a\u0027, 2), STrees_MkNode(\u0027a\u0027, 3), STrees_MkNode(\u0027a\u0027, 4), STrees_MkNode(\u0027a\u0027, 5), STrees_MkNode(\u0027a\u0027, 6), STrees_MkNode(\u0027b\u0027, 7), STrees_MkNode(\u0027b\u0027, 8), STrees_MkNode(\u0027b\u0027, 10), STrees_MkNode(\u0027b\u0027, 11), STrees_MkNode(\u0027b\u0027, 12), STrees_MkNode(\u0027b\u0027, 13), STrees_MkNode(\u0027a\u0027, 23), STrees_MkNode(\u0027b\u0027, 24), STrees_MkNode(\u0027b\u0027, 25), STrees_MkNode(\u0027b\u0027, 46), STrees_MkNode(\u0027b\u0027, 47), STrees_MkNode(\u0027b\u0027, 95), STrees_MkNode(\u0027b\u0027, 190), STrees_MkNode(\u0027b\u0027, 191)})","legal function application obligation:pre_STrees_Insert(stree, \u0027a\u0027, \u003cToRoot\u003e)","legal function application obligation:pre_STrees_Insert(stree, \u0027b\u0027, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveToParent(stree)","legal function application obligation:pre_STrees_Insert(stree, \u0027c\u0027, \u003cToRight\u003e)","legal function application obligation:pre_STrees_MoveToParent(stree)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_Insert(stree, \u0027d\u0027, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveToParent(stree)","legal function application obligation:pre_STrees_Insert(stree, \u0027e\u0027, \u003cToRight\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToRoot\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToRight\u003e)","legal function application obligation:pre_STrees_Insert(stree, \u0027f\u0027, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveToParent(stree)","legal function application obligation:pre_STrees_Insert(stree, \u0027g\u0027, \u003cToRight\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToRoot\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_Insert(stree, \u0027h\u0027, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveToParent(stree)","legal function application obligation:pre_STrees_Insert(stree, \u0027i\u0027, \u003cToRight\u003e)","legal function application obligation:pre_STrees_MoveToAnscestor(stree, 2)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToRight\u003e)","legal function application obligation:pre_STrees_Insert(stree, \u0027j\u0027, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveToParent(stree)","legal function application obligation:pre_STrees_Insert(stree, \u0027k\u0027, \u003cToRight\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToRoot\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToRight\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_Insert(stree, \u0027l\u0027, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveToParent(stree)","legal function application obligation:pre_STrees_Insert(stree, \u0027m\u0027, \u003cToRight\u003e)","legal function application obligation:pre_STrees_MoveToAnscestor(stree, 2)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToRight\u003e)","legal function application obligation:pre_STrees_Insert(stree, \u0027n\u0027, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveToParent(stree)","legal function application obligation:pre_STrees_Insert(stree, \u0027o\u0027, \u003cToRight\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToRoot\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_Insert(stree, \u0027p\u0027, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveToParent(stree)","legal function application obligation:pre_STrees_Insert(stree, \u0027q\u0027, \u003cToRight\u003e)","legal function application obligation:pre_STrees_MoveToAnscestor(stree, 2)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToRight\u003e)","legal function application obligation:pre_STrees_Insert(stree, \u0027r\u0027, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveToParent(stree)","legal function application obligation:pre_STrees_Insert(stree, \u0027s\u0027, \u003cToRight\u003e)","legal function application obligation:pre_STrees_MoveToAnscestor(stree, 3)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToRight\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_Insert(stree, \u0027t\u0027, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveToParent(stree)","legal function application obligation:pre_STrees_Insert(stree, \u0027u\u0027, \u003cToRight\u003e)","legal function application obligation:pre_STrees_MoveToAnscestor(stree, 2)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToRight\u003e)","legal function application obligation:pre_STrees_Insert(stree, \u0027v\u0027, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveToParent(stree)","legal function application obligation:pre_STrees_Insert(stree, \u0027w\u0027, \u003cToRight\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToRoot\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToRight\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_Insert(stree, \u0027x\u0027, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveToParent(stree)","legal function application obligation:pre_STrees_Insert(stree, \u0027y\u0027, \u003cToRight\u003e)","legal function application obligation:pre_STrees_MoveToAnscestor(stree, 2)","legal function application obligation:pre_STrees_MoveInDir(stree, \u003cToRight\u003e)","legal function application obligation:pre_STrees_Insert(stree, \u0027z\u0027, \u003cToLeft\u003e)","legal function application obligation:pre_STrees_MoveToNode(stree, 14)","legal function application obligation:pre_STrees_Delete(stree)","legal function application obligation:pre_STrees_MoveToNode(stree, 17)","legal function application obligation:pre_STrees_Delete(stree)","legal function application obligation:pre_STrees_MoveToNode(stree, 13)","legal function application obligation:pre_STrees_Delete(stree)","legal function application obligation:pre_STrees_MoveToNode(stree, 7)","legal function application obligation:pre_STrees_Delete(stree)","legal function application obligation:pre_STrees_MoveToNode(stree, 5)","legal function application obligation:pre_STrees_Delete(stree)","legal function application obligation:pre_STrees_MoveToNode(stree, 2)","legal function application obligation:pre_STrees_Delete(stree)","legal function application obligation:pre_STrees_MoveToNode(stree, 3)","legal function application obligation:pre_STrees_GetData(stree, 13)","legal function application obligation:pre_STrees_SetCurrentNode(stree, STrees_MkNode(\u0027z\u0027, 13))","legal function application obligation:pre_STrees_StoreCurrentData(stree, \u0027Z\u0027)","legal function application obligation:pre_STrees_GetCurrentData(stree)"]