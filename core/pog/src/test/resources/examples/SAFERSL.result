["operation establishes postcondition obligation:(forall mk_SwitchPositions(mode, aah):SwitchPositions, raw_grip:HandGripPosition, aah_cmd:RotCommand, oldstate:SAFER \u0026 (true \u003d\u003e (((card RESULT) \u003c\u003d 4) and ThrusterConsistency(RESULT))))","comprehension map injectivity obligation:(forall m1, m2 in set {{a |-\u003e \u003cZero\u003e} | a in set tran_axis_set} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","type compatibility obligation:inv_TranCommand({a |-\u003e \u003cZero\u003e | a in set tran_axis_set})","comprehension map injectivity obligation:(forall m1, m2 in set {{a |-\u003e \u003cZero\u003e} | a in set rot_axis_set} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","type compatibility obligation:inv_RotCommand({a |-\u003e \u003cZero\u003e | a in set rot_axis_set})","type invariant satisfiable obligation:(exists cmd:TranCommand \u0026 ((dom cmd) \u003d tran_axis_set))","type invariant satisfiable obligation:(exists cmd:RotCommand \u0026 ((dom cmd) \u003d rot_axis_set))","type invariant satisfiable obligation:(exists inp:Input \u0026 ((len inp) \u003d 9))","legal sequence application obligation:(forall tm:seq of (seq of (bool)) \u0026 (((len tm) \u003d 4) \u003d\u003e (forall i in set (inds tm) \u0026 (i in set (inds tm)))))","type invariant satisfiable obligation:(exists tm:ThrusterMatrix \u0026 (((len tm) \u003d 4) and (forall i in set (inds tm) \u0026 ((len tm(i)) \u003d 6))))","enumeration map injectivity obligation:(forall input:Input \u0026 let [mode, aah, horiz, trans, vert, twist, roll, pitch, yaw]:Input \u003d input in (forall m1, m2 in set {{\u003cRoll\u003e |-\u003e ConvertAxisCmd(roll)}, {\u003cPitch\u003e |-\u003e ConvertAxisCmd(pitch)}, {\u003cYaw\u003e |-\u003e ConvertAxisCmd(yaw)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:(forall input:Input \u0026 is_(let [mode, aah, horiz, trans, vert, twist, roll, pitch, yaw]:Input \u003d input in let swpos:HCM`SwitchPositions \u003d mk_HCM`SwitchPositions((if (mode \u003d 1)\nthen \u003cTran\u003e\nelse \u003cRot\u003e), (if (aah \u003d 0)\nthen \u003cUp\u003e\nelse \u003cDown\u003e)), hgpos:HCM`HandGripPosition \u003d mk_HCM`HandGripPosition(ConvertAxisCmd(vert), ConvertAxisCmd(horiz), ConvertAxisCmd(trans), ConvertAxisCmd(twist)), rcom:map ((\u003cPitch\u003e | \u003cRoll\u003e | \u003cYaw\u003e)) to (AxisCommand) \u003d {\u003cRoll\u003e |-\u003e ConvertAxisCmd(roll), \u003cPitch\u003e |-\u003e ConvertAxisCmd(pitch), \u003cYaw\u003e |-\u003e ConvertAxisCmd(yaw)} in mk_(swpos, hgpos, rcom), (SwitchPositions * HandGripPosition * RotCommand)))","type compatibility obligation:(forall ts:ThrusterSet \u0026 inv_ThrusterMatrix(let tson:set of ((nat * nat)) \u003d {GenerateThrusterLabel(t) | t in set ts} in [[(mk_(j, i) in set tson) | i in set {1, ... ,6}] | j in set {1, ... ,4}]))","cases exhaustive obligation:(forall tnm:ThrusterName \u0026 ((((((((((((((((((((((((tnm \u003d \u003cB1\u003e) or (tnm \u003d \u003cB2\u003e)) or (tnm \u003d \u003cB3\u003e)) or (tnm \u003d \u003cB4\u003e)) or (tnm \u003d \u003cF1\u003e)) or (tnm \u003d \u003cF2\u003e)) or (tnm \u003d \u003cF3\u003e)) or (tnm \u003d \u003cF4\u003e)) or (tnm \u003d \u003cL1R\u003e)) or (tnm \u003d \u003cL1F\u003e)) or (tnm \u003d \u003cR2R\u003e)) or (tnm \u003d \u003cR2F\u003e)) or (tnm \u003d \u003cL3R\u003e)) or (tnm \u003d \u003cL3F\u003e)) or (tnm \u003d \u003cR4R\u003e)) or (tnm \u003d \u003cR4F\u003e)) or (tnm \u003d \u003cD1R\u003e)) or (tnm \u003d \u003cD1F\u003e)) or (tnm \u003d \u003cD2R\u003e)) or (tnm \u003d \u003cD2F\u003e)) or (tnm \u003d \u003cU3R\u003e)) or (tnm \u003d \u003cU3F\u003e)) or (tnm \u003d \u003cU4R\u003e)) or (tnm \u003d \u003cU4F\u003e)))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cRoll\u003e |-\u003e \u003cZero\u003e}, {\u003cPitch\u003e |-\u003e \u003cZero\u003e}, {\u003cYaw\u003e |-\u003e \u003cZero\u003e}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal map application obligation:(forall cmd:RotCommand \u0026 (forall a in set (dom cmd) \u0026 (a in set (dom cmd))))","legal map application obligation:(forall tran:TranCommand \u0026 (\u003cX\u003e in set (dom tran)))","legal map application obligation:(forall tran:TranCommand \u0026 ((tran(\u003cX\u003e) \u003c\u003e \u003cZero\u003e) \u003d\u003e (\u003cX\u003e in set (dom tran))))","legal map application obligation:(forall tran:TranCommand \u0026 ((not (tran(\u003cX\u003e) \u003c\u003e \u003cZero\u003e)) \u003d\u003e ((tran(\u003cY\u003e) \u003c\u003e \u003cZero\u003e) \u003d\u003e (\u003cY\u003e in set (dom tran)))))","legal map application obligation:(forall tran:TranCommand \u0026 ((not (tran(\u003cX\u003e) \u003c\u003e \u003cZero\u003e)) \u003d\u003e ((not (tran(\u003cY\u003e) \u003c\u003e \u003cZero\u003e)) \u003d\u003e ((tran(\u003cZ\u003e) \u003c\u003e \u003cZero\u003e) \u003d\u003e (\u003cZ\u003e in set (dom tran))))))","type compatibility obligation:(forall tran:TranCommand \u0026 inv_TranCommand((if (tran(\u003cX\u003e) \u003c\u003e \u003cZero\u003e)\nthen (AUX`null_tran_command ++ {\u003cX\u003e |-\u003e tran(\u003cX\u003e)})\nelseif (tran(\u003cY\u003e) \u003c\u003e \u003cZero\u003e)\nthen (AUX`null_tran_command ++ {\u003cY\u003e |-\u003e tran(\u003cY\u003e)})\nelseif (tran(\u003cZ\u003e) \u003c\u003e \u003cZero\u003e)\nthen (AUX`null_tran_command ++ {\u003cZ\u003e |-\u003e tran(\u003cZ\u003e)})\nelse AUX`null_tran_command)))","legal map application obligation:(forall hcm_rot:RotCommand, aah:RotCommand, ignore_hcm:set of (RotAxis) \u0026 (forall a in set AUX`rot_axis_set \u0026 (a in set (dom hcm_rot))))","comprehension map injectivity obligation:(forall hcm_rot:RotCommand, aah:RotCommand, ignore_hcm:set of (RotAxis) \u0026 let aah_axes:set of (RotAxis) \u003d (ignore_hcm union {a | a in set AUX`rot_axis_set \u0026 (hcm_rot(a) \u003d \u003cZero\u003e)}) in (forall m1, m2 in set {{a |-\u003e aah(a)} | a in set aah_axes} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal map application obligation:(forall hcm_rot:RotCommand, aah:RotCommand, ignore_hcm:set of (RotAxis) \u0026 let aah_axes:set of (RotAxis) \u003d (ignore_hcm union {a | a in set AUX`rot_axis_set \u0026 (hcm_rot(a) \u003d \u003cZero\u003e)}) in (forall a in set aah_axes \u0026 (a in set (dom aah))))","comprehension map injectivity obligation:(forall hcm_rot:RotCommand, aah:RotCommand, ignore_hcm:set of (RotAxis) \u0026 let aah_axes:set of (RotAxis) \u003d (ignore_hcm union {a | a in set AUX`rot_axis_set \u0026 (hcm_rot(a) \u003d \u003cZero\u003e)}) in (forall m1, m2 in set {{a |-\u003e hcm_rot(a)} | a in set (AUX`rot_axis_set \\ aah_axes)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","legal map application obligation:(forall hcm_rot:RotCommand, aah:RotCommand, ignore_hcm:set of (RotAxis) \u0026 let aah_axes:set of (RotAxis) \u003d (ignore_hcm union {a | a in set AUX`rot_axis_set \u0026 (hcm_rot(a) \u003d \u003cZero\u003e)}) in (forall a in set (AUX`rot_axis_set \\ aah_axes) \u0026 (a in set (dom hcm_rot))))","map compatible obligation:(forall hcm_rot:RotCommand, aah:RotCommand, ignore_hcm:set of (RotAxis) \u0026 let aah_axes:set of (RotAxis) \u003d (ignore_hcm union {a | a in set AUX`rot_axis_set \u0026 (hcm_rot(a) \u003d \u003cZero\u003e)}) in (forall ldom1 in set (dom {a |-\u003e aah(a) | a in set aah_axes}), rdom2 in set (dom {a |-\u003e hcm_rot(a) | a in set (AUX`rot_axis_set \\ aah_axes)}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e ({a |-\u003e aah(a) | a in set aah_axes}(ldom1) \u003d {a |-\u003e hcm_rot(a) | a in set (AUX`rot_axis_set \\ aah_axes)}(rdom2)))))","type compatibility obligation:(forall hcm_rot:RotCommand, aah:RotCommand, ignore_hcm:set of (RotAxis) \u0026 inv_RotCommand(let aah_axes:set of (RotAxis) \u003d (ignore_hcm union {a | a in set AUX`rot_axis_set \u0026 (hcm_rot(a) \u003d \u003cZero\u003e)}) in ({a |-\u003e aah(a) | a in set aah_axes} munion {a |-\u003e hcm_rot(a) | a in set (AUX`rot_axis_set \\ aah_axes)})))","cases exhaustive obligation:(forall A:AxisCommand, B:AxisCommand, C:AxisCommand \u0026 (((((((((((((((((((((((((((mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cNeg\u003e)) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cPos\u003e))))","cases exhaustive obligation:(forall A:AxisCommand, B:AxisCommand, C:AxisCommand \u0026 (((((((((((((((((((((((((((mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cNeg\u003e)) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cNeg\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cZero\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cNeg\u003e, \u003cPos\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cNeg\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cZero\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cZero\u003e, \u003cPos\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cNeg\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cZero\u003e, \u003cPos\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cNeg\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cZero\u003e))) or (mk_(A, B, C) \u003d mk_(\u003cPos\u003e, \u003cPos\u003e, \u003cPos\u003e))))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cX\u003e in set (dom tran)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cPitch\u003e in set (dom rot)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cYaw\u003e in set (dom rot)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cY\u003e in set (dom tran)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cZ\u003e in set (dom tran)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cRoll\u003e in set (dom rot)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cRoll\u003e in set (dom rot)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 (\u003cPitch\u003e in set (dom rot)))","legal map application obligation:(forall hcm:SixDofCommand, aah:RotCommand, active_axes:set of (RotAxis), ignore_hcm:set of (RotAxis) \u0026 ((rot(\u003cPitch\u003e) \u003d \u003cZero\u003e) \u003d\u003e (\u003cYaw\u003e in set (dom rot))))","enumeration map injectivity obligation:(forall a, b, c in set AUX`axis_command_set \u0026 (forall m1, m2 in set {{\u003cRoll\u003e |-\u003e a}, {\u003cPitch\u003e |-\u003e b}, {\u003cYaw\u003e |-\u003e c}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:is_({{\u003cRoll\u003e |-\u003e a, \u003cPitch\u003e |-\u003e b, \u003cYaw\u003e |-\u003e c} | a, b, c in set AUX`axis_command_set}, set of (RotCommand))","comprehension map injectivity obligation:(forall m1, m2 in set {{mk_(switch, grip, aah_law) |-\u003e SAFER`ControlCycle(switch, grip, aah_law)} | switch in set switch_positions, grip in set grip_positions, aah_law in set all_rot_commands} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","comprehension map injectivity obligation:(forall m1, m2 in set {{mk_(switch, grip, aah_law) |-\u003e SAFER`ControlCycle(switch, grip, aah_law)} | switch in set switch_positions, grip in set all_grip_positions, aah_law in set all_rot_commands} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","let be st existence obligation:(forall ts:ThrusterSet \u0026 ((not (ts \u003d {})) \u003d\u003e (exists t in set ts \u0026 true)))","cases exhaustive obligation:(forall tnm:ThrusterName \u0026 ((((((((((((((((((((((((tnm \u003d \u003cB1\u003e) or (tnm \u003d \u003cB2\u003e)) or (tnm \u003d \u003cB3\u003e)) or (tnm \u003d \u003cB4\u003e)) or (tnm \u003d \u003cF1\u003e)) or (tnm \u003d \u003cF2\u003e)) or (tnm \u003d \u003cF3\u003e)) or (tnm \u003d \u003cF4\u003e)) or (tnm \u003d \u003cL1R\u003e)) or (tnm \u003d \u003cL1F\u003e)) or (tnm \u003d \u003cR2R\u003e)) or (tnm \u003d \u003cR2F\u003e)) or (tnm \u003d \u003cL3R\u003e)) or (tnm \u003d \u003cL3F\u003e)) or (tnm \u003d \u003cR4R\u003e)) or (tnm \u003d \u003cR4F\u003e)) or (tnm \u003d \u003cD1R\u003e)) or (tnm \u003d \u003cD1F\u003e)) or (tnm \u003d \u003cD2R\u003e)) or (tnm \u003d \u003cD2F\u003e)) or (tnm \u003d \u003cU3R\u003e)) or (tnm \u003d \u003cU3F\u003e)) or (tnm \u003d \u003cU4R\u003e)) or (tnm \u003d \u003cU4F\u003e)))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cRoll\u003e |-\u003e ConvertAxisCmd(roll)}, {\u003cPitch\u003e |-\u003e ConvertAxisCmd(pitch)}, {\u003cYaw\u003e |-\u003e ConvertAxisCmd(yaw)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","while loop termination obligation:...","enumeration map injectivity obligation:(forall mk_HandGripPosition(vert, horiz, trans, twist):HandGripPosition, mode:ControlModeSwitch \u0026 (forall m1, m2 in set {{\u003cX\u003e |-\u003e horiz}, {\u003cY\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen trans\nelse \u003cZero\u003e)}, {\u003cZ\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen vert\nelse \u003cZero\u003e)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","enumeration map injectivity obligation:(forall mk_HandGripPosition(vert, horiz, trans, twist):HandGripPosition, mode:ControlModeSwitch \u0026 (forall m1, m2 in set {{\u003cRoll\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen vert\nelse \u003cZero\u003e)}, {\u003cPitch\u003e |-\u003e twist}, {\u003cYaw\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen trans\nelse \u003cZero\u003e)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:(forall mk_HandGripPosition(vert, horiz, trans, twist):HandGripPosition, mode:ControlModeSwitch \u0026 let tran:map ((\u003cX\u003e | \u003cY\u003e | \u003cZ\u003e)) to ((\u003cZero\u003e | AxisCommand)) \u003d {\u003cX\u003e |-\u003e horiz, \u003cY\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen trans\nelse \u003cZero\u003e), \u003cZ\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen vert\nelse \u003cZero\u003e)}, rot:map ((\u003cPitch\u003e | \u003cRoll\u003e | \u003cYaw\u003e)) to ((\u003cZero\u003e | AxisCommand)) \u003d {\u003cRoll\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen vert\nelse \u003cZero\u003e), \u003cPitch\u003e |-\u003e twist, \u003cYaw\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen trans\nelse \u003cZero\u003e)} in inv_TranCommand(tran))","type compatibility obligation:(forall mk_HandGripPosition(vert, horiz, trans, twist):HandGripPosition, mode:ControlModeSwitch \u0026 let tran:map ((\u003cX\u003e | \u003cY\u003e | \u003cZ\u003e)) to ((\u003cZero\u003e | AxisCommand)) \u003d {\u003cX\u003e |-\u003e horiz, \u003cY\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen trans\nelse \u003cZero\u003e), \u003cZ\u003e |-\u003e (if (mode \u003d \u003cTran\u003e)\nthen vert\nelse \u003cZero\u003e)}, rot:map ((\u003cPitch\u003e | \u003cRoll\u003e | \u003cYaw\u003e)) to ((\u003cZero\u003e | AxisCommand)) \u003d {\u003cRoll\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen vert\nelse \u003cZero\u003e), \u003cPitch\u003e |-\u003e twist, \u003cYaw\u003e |-\u003e (if (mode \u003d \u003cRot\u003e)\nthen trans\nelse \u003cZero\u003e)} in inv_RotCommand(rot))","legal map application obligation:(forall button_pos:ControlButton, hcm_cmd:SixDofCommand, clock:nat, oldstate:AAH \u0026 (forall a in set AUX`rot_axis_set \u0026 ((not starting) \u003d\u003e ((engage \u003c\u003e \u003cAAH_off\u003e) \u003d\u003e ((a in set active_axes) \u003d\u003e (a in set (dom (hcm_cmd.rot))))))))","legal map application obligation:(forall button_pos:ControlButton, hcm_cmd:SixDofCommand, clock:nat, oldstate:AAH \u0026 (forall a in set AUX`rot_axis_set \u0026 (starting \u003d\u003e (a in set (dom (hcm_cmd.rot))))))","cases exhaustive obligation:(forall estate:EngageState, button:ControlButton, active:set of (RotAxis), clock:nat, timeout:nat \u0026 ((((((((((((mk_(estate, button) \u003d mk_(\u003cAAH_off\u003e, \u003cUp\u003e)) or (mk_(estate, button) \u003d mk_(\u003cAAH_off\u003e, \u003cDown\u003e))) or (mk_(estate, button) \u003d mk_(\u003cAAH_started\u003e, \u003cUp\u003e))) or (mk_(estate, button) \u003d mk_(\u003cAAH_started\u003e, \u003cDown\u003e))) or (mk_(estate, button) \u003d mk_(\u003cAAH_on\u003e, \u003cUp\u003e))) or (mk_(estate, button) \u003d mk_(\u003cAAH_on\u003e, \u003cDown\u003e))) or (mk_(estate, button) \u003d mk_(\u003cpressed_once\u003e, \u003cUp\u003e))) or (mk_(estate, button) \u003d mk_(\u003cpressed_once\u003e, \u003cDown\u003e))) or (mk_(estate, button) \u003d mk_(\u003cAAH_closing\u003e, \u003cUp\u003e))) or (mk_(estate, button) \u003d mk_(\u003cAAH_closing\u003e, \u003cDown\u003e))) or (mk_(estate, button) \u003d mk_(\u003cpressed_twice\u003e, \u003cUp\u003e))) or (mk_(estate, button) \u003d mk_(\u003cpressed_twice\u003e, \u003cDown\u003e))))"]