["while loop termination obligation:...","non-empty sequence obligation:(inlines \u003c\u003e [])","non-empty sequence obligation:(inlines \u003c\u003e [])","legal function application obligation:(forall fname:seq of (char) \u0026 pre_(((io.freadval))[seq of (inline)]fname))","type compatibility obligation:(forall fname:seq of (char) \u0026 is_(input, seq of (inline)))","map compatible obligation:(forall td:TokenDevice \u0026 (forall ldom1 in set (dom tokenDevices), rdom2 in set (dom {(td.getTokenId)() |-\u003e td}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (tokenDevices(ldom1) \u003d {(td.getTokenId)() |-\u003e td}(rdom2)))))","non-empty sequence obligation:(((len inlines) \u003e 0) \u003d\u003e (inlines \u003c\u003e []))","type invariant satisfiable obligation:(exists n:NavigationInput \u0026 (((len (n.departureLocation)) \u003e 0) and ((len (n.arrivalLocation)) \u003e 0)))","legal sequence application obligation:(forall navInput:NavigationInput, tokenDevice:TokenDevice \u0026 ((exists r in set (railway.getGrid)() \u0026 (((r(1).departureLocation) \u003d (navInput.departureLocation)) and ((r((len r)).arrivalLocation) \u003d (navInput.arrivalLocation)))) \u003d\u003e (forall r in set (railway.getGrid)() \u0026 (1 in set (inds r)))))","legal sequence application obligation:(forall navInput:NavigationInput, tokenDevice:TokenDevice \u0026 ((exists r in set (railway.getGrid)() \u0026 (((r(1).departureLocation) \u003d (navInput.departureLocation)) and ((r((len r)).arrivalLocation) \u003d (navInput.arrivalLocation)))) \u003d\u003e (forall r in set (railway.getGrid)() \u0026 (((r(1).departureLocation) \u003d (navInput.departureLocation)) \u003d\u003e ((len r) in set (inds r))))))","legal sequence application obligation:(forall navInput:NavigationInput, tokenDevice:TokenDevice \u0026 ((exists r in set (railway.getGrid)() \u0026 (((r(1).departureLocation) \u003d (navInput.departureLocation)) and ((r((len r)).arrivalLocation) \u003d (navInput.arrivalLocation)))) \u003d\u003e (forall r in set tempGrid \u0026 (1 in set (inds r)))))","legal sequence application obligation:(forall navInput:NavigationInput, tokenDevice:TokenDevice \u0026 ((exists r in set (railway.getGrid)() \u0026 (((r(1).departureLocation) \u003d (navInput.departureLocation)) and ((r((len r)).arrivalLocation) \u003d (navInput.arrivalLocation)))) \u003d\u003e (forall r in set tempGrid \u0026 (((r(1).departureLocation) \u003d (navInput.departureLocation)) \u003d\u003e ((len r) in set (inds r))))))","non-empty sequence obligation:(((len q_Env_in) \u003e 0) \u003d\u003e (q_Env_in \u003c\u003e []))","operation call obligation:(((len q_Env_in) \u003e 0) \u003d\u003e (forall normalState1:bool, curtime2:nat, railway3:RailwayGrid, q_APM_out4:ActivePlanManager, q_Env_in5:seq of (MessageT), q_APM_in6:seq of (MessageT), busy7:bool, timeout8:nat \u0026 (true \u003d\u003e ((len q_APM_in6) \u003e 0))))","non-empty sequence obligation:(((len q_APM_in) \u003e 0) \u003d\u003e (q_APM_in \u003c\u003e []))","operation call obligation:(((len q_APM_in) \u003e 0) \u003d\u003e (forall normalState1:bool, curtime2:nat, railway3:RailwayGrid, q_APM_out4:ActivePlanManager, q_Env_in5:seq of (MessageT), q_APM_in6:seq of (MessageT), busy7:bool, timeout8:nat \u0026 (true \u003d\u003e ((len q_APM_in6) \u003e 0))))","type compatibility obligation:(forall navi:NavigationInput, tokenDevice:TokenDevice \u0026 is_(calculateTransportPlan(navi, tokenDevice), DTO))","value binding obligation:(forall msg:MessageT \u0026 (exists mk_INACTIVEROUTE(routeid):MessageT \u0026 (mk_INACTIVEROUTE(routeid) \u003d msg)))","type compatibility obligation:(forall msg:MessageT \u0026 is_(msg, INACTIVEROUTE))","non-empty sequence obligation:(((len q_APM_in) \u003e 0) \u003d\u003e (q_APM_in \u003c\u003e []))","non-empty sequence obligation:(((len q_APM_in) \u003e 0) \u003d\u003e (q_Env_in \u003c\u003e []))","while loop termination obligation:...","type compatibility obligation:((i - 1) \u003e\u003d 0)","type invariant satisfiable obligation:(exists r:Route \u0026 (((len (r.platform)) \u003e 0) and (((len (r.arrivalLocation)) \u003e 0) and (((len (r.departureLocation)) \u003e 0) and ((r.fee) \u003e\u003d 0)))))","state invariant holds obligation:(forall routes:seq of (Route), pChoice:Choice, id_tok:nat \u0026 (((len routes) \u003e 0) \u003d\u003e (forall i in set (inds routeList) \u0026 ((i \u003c (len routeList)) \u003d\u003e ((routeList(i).arrivalLocation) \u003d (routeList((i + 1)).departureLocation))))))","non-empty sequence obligation:(((len routeList) \u003e 0) \u003d\u003e (routeList \u003c\u003e []))","legal sequence application obligation:(forall route:Route \u0026 (((routeList((len routeList)).arrivalLocation) \u003d (route.departureLocation)) \u003d\u003e ((len routeList) in set (inds routeList))))","state invariant holds obligation:(forall route:Route \u0026 (((routeList((len routeList)).arrivalLocation) \u003d (route.departureLocation)) \u003d\u003e ((((len routeList) \u003e 0) \u003d\u003e (forall i in set (inds routeList) \u0026 ((i \u003c (len routeList)) \u003d\u003e ((routeList(i).arrivalLocation) \u003d (routeList((i + 1)).departureLocation))))) \u003d\u003e (((len (routeList ^ [route])) \u003e 0) \u003d\u003e (forall i in set (inds routeList) \u0026 ((i \u003c (len routeList)) \u003d\u003e ((routeList(i).arrivalLocation) \u003d (routeList((i + 1)).departureLocation))))))))","state invariant holds obligation:(forall route:Route \u0026 (((routeList((len routeList)).arrivalLocation) \u003d (route.departureLocation)) \u003d\u003e ((((len (routeList ^ [route])) \u003e 0) \u003d\u003e (forall i in set (inds routeList) \u0026 ((i \u003c (len routeList)) \u003d\u003e ((routeList(i).arrivalLocation) \u003d (routeList((i + 1)).departureLocation))))) \u003d\u003e (((len (routeList ^ [route])) \u003e 0) \u003d\u003e (forall i in set (inds routeList) \u0026 ((i \u003c (len routeList)) \u003d\u003e ((routeList(i).arrivalLocation) \u003d (routeList((i + 1)).departureLocation))))))))","state invariant holds obligation:(((len routeList) \u003e 0) \u003d\u003e ((((len routeList) \u003e 0) \u003d\u003e (forall i in set (inds routeList) \u0026 ((i \u003c (len routeList)) \u003d\u003e ((routeList(i).arrivalLocation) \u003d (routeList((i + 1)).departureLocation))))) \u003d\u003e (((len routeList) \u003e 0) \u003d\u003e (forall i in set (inds routeList) \u0026 ((i \u003c (len routeList)) \u003d\u003e ((routeList(i).arrivalLocation) \u003d (routeList((i + 1)).departureLocation)))))))","non-empty sequence obligation:(((len routeList) \u003e 0) \u003d\u003e (routeList \u003c\u003e []))","state invariant holds obligation:(((len routeList) \u003e 0) \u003d\u003e ((((len routeList) \u003e 0) \u003d\u003e (forall i in set (inds routeList) \u0026 ((i \u003c (len routeList)) \u003d\u003e ((routeList(i).arrivalLocation) \u003d (routeList((i + 1)).departureLocation))))) \u003d\u003e (((len (tl routeList)) \u003e 0) \u003d\u003e (forall i in set (inds routeList) \u0026 ((i \u003c (len routeList)) \u003d\u003e ((routeList(i).arrivalLocation) \u003d (routeList((i + 1)).departureLocation)))))))","non-empty sequence obligation:(((len routeList) \u003e 0) \u003d\u003e (routeList \u003c\u003e []))","non-empty sequence obligation:(((len routeList) \u003e 0) \u003d\u003e (routeList \u003c\u003e []))","legal sequence application obligation:(((len routeList) \u003e 0) \u003d\u003e ((len routeList) in set (inds routeList)))","type compatibility obligation:(((len routeList) \u003e 0) \u003d\u003e (id_token \u003e 0))","type compatibility obligation:(((len routeList) \u003e 0) \u003d\u003e (inv_NavigationInput(mk_CyberRail`NavigationInput(((hd routeList).departureLocation), (routeList((len routeList)).arrivalLocation), choice, id_token)) and (id_token \u003e 0)))","legal sequence application obligation:(forall o:TransportPlan \u0026 (1 in set (inds (o.getRouteList)())))","legal sequence application obligation:(forall o:TransportPlan \u0026 ((len (o.getRouteList)()) in set (inds (o.getRouteList)())))","legal function application obligation:pre_(((io.fwriteval))[seq of (logType)]\"logger.log\", log, \u003cstart\u003e)","type compatibility obligation:(forall plan:[TransportPlan], route:[Route], t:nat \u0026 is_((outlines ^ [mk_(plan, route, t)]), seq of (outline)))","legal function application obligation:pre_(((io.fwriteval))[seq of (outline)]outfileName, outlines, \u003cstart\u003e)","legal function application obligation:(forall fname:seq of (char) \u0026 pre_(((io.freadval))[seq of (inline)]fname))","type compatibility obligation:(forall fname:seq of (char) \u0026 is_(input, seq of (inline)))","type compatibility obligation:inv_Route(mk_TransportPlan`Route(\"A\", \"B\", 42, \"P1\", 200, 1))","type compatibility obligation:inv_Route(mk_TransportPlan`Route(\"A\", \"C\", 42, \"P1\", 200, 2))","type compatibility obligation:inv_Route(mk_TransportPlan`Route(\"B\", \"C\", 99, \"P1\", 200, 3))","type compatibility obligation:inv_Route(mk_TransportPlan`Route(\"B\", \"D\", 42, \"P1\", 200, 4))","type compatibility obligation:inv_Route(mk_TransportPlan`Route(\"B\", \"A\", 42, \"P1\", 200, 5))","type compatibility obligation:inv_Route(mk_TransportPlan`Route(\"C\", \"D\", 42, \"P1\", 200, 6))","type compatibility obligation:inv_Route(mk_TransportPlan`Route(\"C\", \"A\", 42, \"P1\", 200, 7))","type compatibility obligation:inv_Route(mk_TransportPlan`Route(\"D\", \"B\", 42, \"P1\", 200, 8))","type compatibility obligation:inv_Route(mk_TransportPlan`Route(\"D\", \"C\", 42, \"P1\", 200, 9))","type compatibility obligation:inv_Route(mk_TransportPlan`Route(\"C\", \"B\", 99, \"P1\", 200, 10))","legal function application obligation:(forall grid:Grid \u0026 pre_(((io.fwriteval))[Grid]\"railway.txt\", grid, \u003cappend\u003e))","state invariant holds obligation:((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))))","state invariant holds obligation:((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))))","state invariant holds obligation:(forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y))))","state invariant holds obligation:(forall plan:TransportPlan, tokenDevice:TokenDevice \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y))))))","type compatibility obligation:(forall plan:TransportPlan, tokenDevice:TokenDevice \u0026 is_((activeTokens ++ {tokenDevice |-\u003e plan}), inmap (TokenDevice) to (TransportPlan)))","state invariant holds obligation:(forall plan:TransportPlan, tokenDevice:TokenDevice \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y))))))","state invariant holds obligation:(forall plan:TransportPlan, tokenDevice:TokenDevice \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y))))))","operation call obligation:((len q_CR_in) \u003e 0)","operation call obligation:(forall activeTokens1:inmap (TokenDevice) to (TransportPlan), busy2:bool, q_CR_out3:CyberRail, tokenDevices4:set of (TokenDevice), q_Tok_in5:seq of (MessageT), q_CR_in6:seq of (MessageT), q_Tok_out7:seq of (TransportPlan), state8:State \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (((len q_Tok_out7) \u003e 0) and (exists plan in set (rng activeTokens) \u0026 (plan \u003d (hd q_Tok_out7))))))","operation call obligation:(forall activeTokens1:inmap (TokenDevice) to (TransportPlan), busy2:bool, q_CR_out3:CyberRail, tokenDevices4:set of (TokenDevice), q_Tok_in5:seq of (MessageT), q_CR_in6:seq of (MessageT), q_Tok_out7:seq of (TransportPlan), state8:State \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall activeTokens9:inmap (TokenDevice) to (TransportPlan), busy10:bool, q_CR_out11:CyberRail, tokenDevices12:set of (TokenDevice), q_Tok_in13:seq of (MessageT), q_CR_in14:seq of (MessageT), q_Tok_out15:seq of (TransportPlan), state16:State \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e ((len q_Tok_in13) \u003e 0)))))","state invariant holds obligation:(forall activeTokens1:inmap (TokenDevice) to (TransportPlan), busy2:bool, q_CR_out3:CyberRail, tokenDevices4:set of (TokenDevice), q_Tok_in5:seq of (MessageT), q_CR_in6:seq of (MessageT), q_Tok_out7:seq of (TransportPlan), state8:State \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall activeTokens9:inmap (TokenDevice) to (TransportPlan), busy10:bool, q_CR_out11:CyberRail, tokenDevices12:set of (TokenDevice), q_Tok_in13:seq of (MessageT), q_CR_in14:seq of (MessageT), q_Tok_out15:seq of (TransportPlan), state16:State \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall activeTokens17:inmap (TokenDevice) to (TransportPlan), busy18:bool, q_CR_out19:CyberRail, tokenDevices20:set of (TokenDevice), q_Tok_in21:seq of (MessageT), q_CR_in22:seq of (MessageT), q_Tok_out23:seq of (TransportPlan), state24:State \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))))))))))","non-empty sequence obligation:((((len q_Tok_out) \u003e 0) and (exists plan in set (rng activeTokens) \u0026 (plan \u003d (hd q_Tok_out)))) \u003d\u003e (((len q_Tok_out) \u003e 0) \u003d\u003e (forall plan in set (rng activeTokens) \u0026 (q_Tok_out \u003c\u003e []))))","map inverse obligation:((((len q_Tok_out) \u003e 0) and (exists plan in set (rng activeTokens) \u0026 (plan \u003d (hd q_Tok_out)))) \u003d\u003e is_(activeTokens, inmap (TokenDevice) to (TransportPlan)))","non-empty sequence obligation:((((len q_Tok_out) \u003e 0) and (exists plan in set (rng activeTokens) \u0026 (plan \u003d (hd q_Tok_out)))) \u003d\u003e (q_Tok_out \u003c\u003e []))","legal map application obligation:((((len q_Tok_out) \u003e 0) and (exists plan in set (rng activeTokens) \u0026 (plan \u003d (hd q_Tok_out)))) \u003d\u003e (plan in set (dom ptt_map)))","state invariant holds obligation:((((len q_Tok_out) \u003e 0) and (exists plan in set (rng activeTokens) \u0026 (plan \u003d (hd q_Tok_out)))) \u003d\u003e ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y))))))","non-empty sequence obligation:((((len q_Tok_out) \u003e 0) and (exists plan in set (rng activeTokens) \u0026 (plan \u003d (hd q_Tok_out)))) \u003d\u003e (q_Tok_out \u003c\u003e []))","state invariant holds obligation:(((len q_CR_in) \u003e 0) \u003d\u003e ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y))))))","non-empty sequence obligation:(((len q_CR_in) \u003e 0) \u003d\u003e (q_CR_in \u003c\u003e []))","operation call obligation:(((len q_CR_in) \u003e 0) \u003d\u003e (forall activeTokens1:inmap (TokenDevice) to (TransportPlan), busy2:bool, q_CR_out3:CyberRail, tokenDevices4:set of (TokenDevice), q_Tok_in5:seq of (MessageT), q_CR_in6:seq of (MessageT), q_Tok_out7:seq of (TransportPlan), state8:State \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall activeTokens9:inmap (TokenDevice) to (TransportPlan), busy10:bool, q_CR_out11:CyberRail, tokenDevices12:set of (TokenDevice), q_Tok_in13:seq of (MessageT), q_CR_in14:seq of (MessageT), q_Tok_out15:seq of (TransportPlan), state16:State \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall activeTokens17:inmap (TokenDevice) to (TransportPlan), busy18:bool, q_CR_out19:CyberRail, tokenDevices20:set of (TokenDevice), q_Tok_in21:seq of (MessageT), q_CR_in22:seq of (MessageT), q_Tok_out23:seq of (TransportPlan), state24:State \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall activeTokens25:inmap (TokenDevice) to (TransportPlan), busy26:bool, q_CR_out27:CyberRail, tokenDevices28:set of (TokenDevice), q_Tok_in29:seq of (MessageT), q_CR_in30:seq of (MessageT), q_Tok_out31:seq of (TransportPlan), state32:State \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e ((len q_CR_in30) \u003e 0))))))))))","state invariant holds obligation:(((len q_Tok_in) \u003e 0) \u003d\u003e ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y))))))","non-empty sequence obligation:(((len q_Tok_in) \u003e 0) \u003d\u003e (q_Tok_in \u003c\u003e []))","operation call obligation:(((len q_Tok_in) \u003e 0) \u003d\u003e (forall activeTokens1:inmap (TokenDevice) to (TransportPlan), busy2:bool, q_CR_out3:CyberRail, tokenDevices4:set of (TokenDevice), q_Tok_in5:seq of (MessageT), q_CR_in6:seq of (MessageT), q_Tok_out7:seq of (TransportPlan), state8:State \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e ((len q_Tok_in5) \u003e 0))))","state invariant holds obligation:(forall log1:seq of (logType) \u0026 (true \u003d\u003e (forall log2:seq of (logType) \u0026 (true \u003d\u003e ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))))))))","state invariant holds obligation:((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))))","value binding obligation:(forall msg:MessageT \u0026 (exists mk_STRATEGYNOTIFY(routeid):MessageT \u0026 (mk_STRATEGYNOTIFY(routeid) \u003d msg)))","type compatibility obligation:(forall msg:MessageT \u0026 is_(msg, STRATEGYNOTIFY))","value binding obligation:(forall msg:MessageT \u0026 (exists mk_RETURNPLAN(dto, tok):MessageT \u0026 (mk_RETURNPLAN(dto, tok) \u003d msg)))","type compatibility obligation:(forall msg:MessageT \u0026 is_(msg, RETURNPLAN))","value binding obligation:(forall msg:MessageT \u0026 (exists mk_REQUESTPLAN(navi, tok):MessageT \u0026 (mk_REQUESTPLAN(navi, tok) \u003d msg)))","type compatibility obligation:(forall msg:MessageT \u0026 is_(msg, REQUESTPLAN))","state invariant holds obligation:(((len q_Tok_in) \u003e 0) \u003d\u003e ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y))))))","non-empty sequence obligation:(((len q_Tok_in) \u003e 0) \u003d\u003e (q_Tok_in \u003c\u003e []))","state invariant holds obligation:(((len q_CR_in) \u003e 0) \u003d\u003e ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y))))))","non-empty sequence obligation:(((len q_CR_in) \u003e 0) \u003d\u003e (q_CR_in \u003c\u003e []))","state invariant holds obligation:(forall cr:CyberRail \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y))))))","state invariant holds obligation:(forall msg:MessageT \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y))))))","state invariant holds obligation:(forall msg:MessageT \u0026 ((forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y)))) \u003d\u003e (forall x, y in set (dom activeTokens) \u0026 ((x \u003d y) \u003d\u003e (activeTokens(x) \u003d activeTokens(y))))))","non-empty sequence obligation:(queue \u003c\u003e [])","non-empty sequence obligation:(queue \u003c\u003e [])","operation call obligation:(forall text:seq of (char) \u0026 ((\"\" \u003d \"\") \u003c\u003d\u003e (\"\" \u003d nil)))"]