["state invariant initialized obligation:((card (dom {|-\u003e})) \u003d (card (rng {|-\u003e})))","state invariant satisfiable obligation:(exists typeDefs:seq of (SimpleTypeDefinition), context:map (seq of (char)) to (seq of (char)), varDecls:seq of (GiraffeVariableDeclStatement), uid:nat1 \u0026 ((card (dom context)) \u003d (card (rng context))))","state invariant holds obligation:(((card (dom context)) \u003d (card (rng context))) \u003d\u003e ((card (dom context)) \u003d (card (rng context))))","legal function application obligation:pre_((util.iToS)res)","operation establishes postcondition obligation:(RESULT not in set (rng context))","while loop termination obligation:...","operation establishes postcondition obligation:(RESULT not in set (dom context))","legal sequence application obligation:(forall programName:seq of (char), spec:SimpleSpecification \u0026 ((((len programName) \u003e 0) and (programName(1) not in set {\u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027})) \u003d\u003e (((len programName) \u003e 0) \u003d\u003e (1 in set (inds programName)))))","legal sequence application obligation:(forall programName:seq of (char), spec:SimpleSpecification \u0026 ((((len programName) \u003e 0) and (programName(1) not in set {\u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027})) \u003d\u003e (forall i in set (inds defs) \u0026 (isofclass(SimpleFunctionDefinition,defs(i)) \u003d\u003e (i in set (inds defs))))))","legal sequence application obligation:(forall programName:seq of (char), spec:SimpleSpecification \u0026 ((((len programName) \u003e 0) and (programName(1) not in set {\u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027})) \u003d\u003e (forall i in set (inds defs) \u0026 (i in set (inds defs)))))","state invariant holds obligation:(forall programName:seq of (char), spec:SimpleSpecification \u0026 ((((len programName) \u003e 0) and (programName(1) not in set {\u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027})) \u003d\u003e (((card (dom context)) \u003d (card (rng context))) \u003d\u003e ((card (dom context)) \u003d (card (rng context))))))","legal sequence application obligation:(forall programName:seq of (char), spec:SimpleSpecification \u0026 ((((len programName) \u003e 0) and (programName(1) not in set {\u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027})) \u003d\u003e (forall i in set (inds defs) \u0026 (isofclass(SimpleTypeDefinition,defs(i)) \u003d\u003e (i in set (inds defs))))))","legal sequence application obligation:(forall programName:seq of (char), spec:SimpleSpecification \u0026 ((((len programName) \u003e 0) and (programName(1) not in set {\u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027})) \u003d\u003e (forall i in set (inds defs) \u0026 (i in set (inds defs)))))","type compatibility obligation:(forall programName:seq of (char), spec:SimpleSpecification \u0026 ((((len programName) \u003e 0) and (programName(1) not in set {\u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027})) \u003d\u003e is_([defs(i) | i in set (inds defs) \u0026 isofclass(SimpleTypeDefinition,defs(i))], seq of (SimpleTypeDefinition))))","legal sequence application obligation:(forall func:SimpleFunctionDefinition \u0026 (((varDecls \u003d []) and (context \u003d {|-\u003e})) \u003d\u003e (forall i in set (inds defs) \u0026 (i in set (inds defs)))))","type compatibility obligation:(forall func:SimpleFunctionDefinition \u0026 (((varDecls \u003d []) and (context \u003d {|-\u003e})) \u003d\u003e is_(Compile(GetType((func.getBody)())), GiraffeType)))","state invariant holds obligation:(forall func:SimpleFunctionDefinition \u0026 (((varDecls \u003d []) and (context \u003d {|-\u003e})) \u003d\u003e (((card (dom context)) \u003d (card (rng context))) \u003d\u003e ((card (dom context)) \u003d (card (rng context))))))","operation establishes postcondition obligation:(forall func:SimpleFunctionDefinition \u0026 (((varDecls \u003d []) and (context \u003d {|-\u003e})) \u003d\u003e (([] \u003d []) and (context \u003d {|-\u003e}))))","type compatibility obligation:(forall param:SimpleParameter \u0026 is_(Compile((param.getType)()), GiraffeType))","type compatibility obligation:(forall type:SimpleType \u0026 is_(type, SimpleIdentifier))","type compatibility obligation:(forall type:SimpleType \u0026 is_(type, SimpleBasicType))","operation establishes postcondition obligation:(forall type:SimpleType \u0026 (RESULT \u003c\u003e nil))","type compatibility obligation:(forall exp:SimpleExpression \u0026 is_(exp, SimpleIntegerLiteralExpression))","type compatibility obligation:(forall exp:SimpleExpression \u0026 is_(exp, SimpleBinaryExpression))","type compatibility obligation:(forall exp:SimpleExpression \u0026 is_(exp, SimpleCasesExpression))","type compatibility obligation:(forall exp:SimpleExpression \u0026 is_(exp, SimpleVariableExpression))","legal map application obligation:(forall exp:SimpleExpression \u0026 ((name.getName)() in set (dom context)))","type compatibility obligation:(forall exp:SimpleExpression \u0026 is_(exp, SimpleLetExpression))","type compatibility obligation:(forall exp:SimpleExpression \u0026 is_(exp, SimpleIfExpression))","operation establishes postcondition obligation:(forall exp:SimpleExpression \u0026 (RESULT \u003c\u003e nil))","non-empty sequence obligation:(forall e:SimpleCasesExpression \u0026 ((not (e.hasDeflt)()) \u003d\u003e ((not ((e.getAlts)() \u003d [])) \u003d\u003e ((e.getAlts)() \u003c\u003e []))))","non-empty sequence obligation:(forall e:SimpleCasesExpression \u0026 ((not (e.hasDeflt)()) \u003d\u003e ((not ((e.getAlts)() \u003d [])) \u003d\u003e ((e.getAlts)() \u003c\u003e []))))","legal sequence application obligation:(forall e:SimpleCasesExpression \u0026 ((not (e.hasDeflt)()) \u003d\u003e ((not ((e.getAlts)() \u003d [])) \u003d\u003e (forall i in set (inds rest) \u0026 (i in set (inds rest))))))","legal sequence application obligation:(forall e:SimpleCasesExpression \u0026 ((not (e.hasDeflt)()) \u003d\u003e ((not ((e.getAlts)() \u003d [])) \u003d\u003e (forall i in set (inds rest) \u0026 (i in set (inds rest))))))","type compatibility obligation:(forall e:SimpleCasesExpression \u0026 ((not (e.hasDeflt)()) \u003d\u003e is_(RESULT, GiraffeExpression)))","type compatibility obligation:(forall letExp:SimpleLetExpression \u0026 (((letExp.getDefs)() \u003c\u003e []) \u003d\u003e is_(Compile(type), GiraffeType)))","type compatibility obligation:(forall letExp:SimpleLetExpression \u0026 (((letExp.getDefs)() \u003c\u003e []) \u003d\u003e is_(Compile((x.getValue)()), GiraffeExpression)))","state invariant holds obligation:(forall letExp:SimpleLetExpression \u0026 (((letExp.getDefs)() \u003c\u003e []) \u003d\u003e (((card (dom context)) \u003d (card (rng context))) \u003d\u003e ((card (dom (context ++ {name |-\u003e newName}))) \u003d (card (rng (context ++ {name |-\u003e newName})))))))","state invariant holds obligation:(forall letExp:SimpleLetExpression \u0026 (((letExp.getDefs)() \u003c\u003e []) \u003d\u003e (((card (dom (context ++ {name |-\u003e newName}))) \u003d (card (rng (context ++ {name |-\u003e newName})))) \u003d\u003e ((card (dom (context ++ {name |-\u003e newName}))) \u003d (card (rng (context ++ {name |-\u003e newName})))))))","type compatibility obligation:(forall letExp:SimpleLetExpression \u0026 (((letExp.getDefs)() \u003c\u003e []) \u003d\u003e is_(Compile((letExp.getBody)()), GiraffeExpression)))","state invariant holds obligation:(forall letExp:SimpleLetExpression \u0026 (((letExp.getDefs)() \u003c\u003e []) \u003d\u003e (((card (dom (context ++ {name |-\u003e newName}))) \u003d (card (rng (context ++ {name |-\u003e newName})))) \u003d\u003e ((card (dom oldContext)) \u003d (card (rng oldContext))))))","type compatibility obligation:(forall op:SimpleBinaryOperator, lhs:SimpleExpression, rhs:SimpleExpression \u0026 is_(Compile(lhs), GiraffeExpression))","type compatibility obligation:(forall op:SimpleBinaryOperator, lhs:SimpleExpression, rhs:SimpleExpression \u0026 is_(Compile(rhs), GiraffeExpression))","type compatibility obligation:(forall op:SimpleBinaryOperator, lhs:SimpleExpression, rhs:SimpleExpression \u0026 is_(Compile(lhs), GiraffeExpression))","type compatibility obligation:(forall op:SimpleBinaryOperator, lhs:SimpleExpression, rhs:SimpleExpression \u0026 is_(Compile(rhs), GiraffeExpression))","operation establishes postcondition obligation:(forall op:SimpleBinaryOperator, lhs:SimpleExpression, rhs:SimpleExpression \u0026 (RESULT \u003c\u003e nil))","type compatibility obligation:(forall selif:SimpleIfExpression \u0026 is_(Compile((selif.getTest)()), GiraffeExpression))","type compatibility obligation:(forall selif:SimpleIfExpression \u0026 is_(Compile((selif.getThn)()), GiraffeExpression))","non-empty sequence obligation:(forall elsif:seq of (SimpleElseIfExpression), els:SimpleExpression \u0026 ((not (elsif \u003d [])) \u003d\u003e (elsif \u003c\u003e [])))","type compatibility obligation:(forall elsif:seq of (SimpleElseIfExpression), els:SimpleExpression \u0026 ((not (elsif \u003d [])) \u003d\u003e is_(Compile((head.getTest)()), GiraffeExpression)))","type compatibility obligation:(forall elsif:seq of (SimpleElseIfExpression), els:SimpleExpression \u0026 ((not (elsif \u003d [])) \u003d\u003e is_(Compile((head.getThn)()), GiraffeExpression)))","non-empty sequence obligation:(forall elsif:seq of (SimpleElseIfExpression), els:SimpleExpression \u0026 ((not (elsif \u003d [])) \u003d\u003e (elsif \u003c\u003e [])))","type compatibility obligation:(forall elsif:seq of (SimpleElseIfExpression), els:SimpleExpression \u0026 is_((if (elsif \u003d [])\nthen Compile(els)\nelse let head:SimpleElseIfExpression \u003d (hd elsif), gTest:GiraffeExpression \u003d Compile((head.getTest)()), gThen:GiraffeExpression \u003d Compile((head.getThn)()), gElse:GiraffeExpression \u003d deflatten((tl elsif), els) in new GiraffeIfExpressionImpl(gTest, gThen, gElse)), GiraffeExpression))","legal sequence application obligation:(forall classDef:GiraffeClassDefinition \u0026 (forall i in set (inds mlist) \u0026 (i in set (inds mlist))))","legal sequence application obligation:(forall method:GiraffeMethodDefinition \u0026 (forall i in set (inds params) \u0026 (i in set (inds params))))","legal sequence application obligation:(forall method:GiraffeMethodDefinition \u0026 (forall i in set (inds body) \u0026 (i in set (inds body))))","type compatibility obligation:(forall type:GiraffeType \u0026 is_(type, GiraffeIdentifier))","type compatibility obligation:(forall type:GiraffeType \u0026 is_(type, GiraffeBasicType))","type compatibility obligation:(forall stm:GiraffeStatement \u0026 is_(stm, GiraffeVariableDeclStatement))","type compatibility obligation:(forall stm:GiraffeStatement \u0026 is_(stm, GiraffeReturnStatement))","type compatibility obligation:(forall exp:GiraffeExpression \u0026 is_(exp, GiraffeIntegerLiteralExpression))","legal function application obligation:(forall exp:GiraffeExpression \u0026 pre_((new codegen_Util().iToS)(e.getValue)()))","type compatibility obligation:(forall exp:GiraffeExpression \u0026 is_(exp, GiraffeVariableExpression))","type compatibility obligation:(forall exp:GiraffeExpression \u0026 is_(exp, GiraffeBinaryExpression))","type compatibility obligation:(forall exp:GiraffeExpression \u0026 is_(exp, GiraffeIfExpression))","non-empty sequence obligation:(forall x:seq of (seq of (char)) \u0026 ((not (x \u003d [])) \u003d\u003e (x \u003c\u003e [])))","non-empty sequence obligation:(forall programs:seq of (seq of (char)) \u0026 (programs \u003c\u003e []))","type compatibility obligation:(forall programs:seq of (seq of (char)) \u0026 is_(e, int))","non-empty sequence obligation:(forall programs:seq of (seq of (char)) \u0026 (programs \u003c\u003e []))","non-empty sequence obligation:(forall programs:seq of (seq of (char)) \u0026 (programs \u003c\u003e []))","type compatibility obligation:is_(RESULT, GiraffeExpression)","type compatibility obligation:is_(RESULT, SimpleExpression)","operation call obligation:(forall text:seq of (char) \u0026 ((\"\" \u003d \"\") \u003c\u003d\u003e (\"\" \u003d nil)))"]