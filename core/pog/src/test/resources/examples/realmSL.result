["type compatibility obligation:inv_N(1)","type compatibility obligation:inv_N(1)","type compatibility obligation:inv_N(5)","type compatibility obligation:inv_N(3)","type compatibility obligation:inv_N(1)","type compatibility obligation:inv_N(9)","type compatibility obligation:inv_N(2)","type compatibility obligation:inv_N(3)","type compatibility obligation:inv_N(9)","type compatibility obligation:inv_N(5)","type compatibility obligation:inv_N(6)","type compatibility obligation:inv_N(9)","type compatibility obligation:inv_N(4)","type compatibility obligation:inv_N(5)","type compatibility obligation:inv_N(4)","type compatibility obligation:inv_N(6)","type compatibility obligation:inv_N(1)","type compatibility obligation:inv_N(6)","type compatibility obligation:inv_N(5)","type compatibility obligation:inv_N(0)","type compatibility obligation:inv_N(5)","type compatibility obligation:inv_N(1)","type compatibility obligation:inv_N(6)","type compatibility obligation:inv_N(0)","type compatibility obligation:inv_N(6)","type compatibility obligation:inv_N(1)","type compatibility obligation:inv_NSeg(mk_REALM`NSeg({p1, p2}))","type compatibility obligation:inv_NSeg(mk_REALM`NSeg({p1, p3}))","type compatibility obligation:inv_NSeg(mk_REALM`NSeg({p2, p4}))","type compatibility obligation:inv_NSeg(mk_REALM`NSeg({p4, p3}))","type compatibility obligation:inv_NSeg(mk_REALM`NSeg({p3, p2}))","type compatibility obligation:inv_NSeg(mk_REALM`NSeg({p5, p4}))","type compatibility obligation:inv_NSeg(mk_REALM`NSeg({p6, p1}))","type compatibility obligation:inv_NSeg(mk_REALM`NSeg({p5, p3}))","type compatibility obligation:inv_NSeg(mk_REALM`NSeg({p5, p7}))","type compatibility obligation:inv_NSeg(mk_REALM`NSeg({p9, p3}))","type compatibility obligation:inv_NSeg(mk_REALM`NSeg({p10, p8}))","type compatibility obligation:inv_NSeg(mk_REALM`NSeg({p1, p5}))","type compatibility obligation:inv_NSeg(mk_REALM`NSeg({p10, p13}))","type compatibility obligation:inv_NSeg(mk_REALM`NSeg({p11, p12}))","type compatibility obligation:inv_Realm(mk_REALM`Realm({p1, p2}, {s1}))","type compatibility obligation:inv_Realm(mk_REALM`Realm({p5, p4}, {s6}))","type compatibility obligation:inv_Realm(mk_REALM`Realm({p5, p4, p3}, {s6, s8}))","type compatibility obligation:inv_Realm(mk_REALM`Realm({p1, p3, p4, p5, p6, p7, p8}, {s6, s8}))","type compatibility obligation:inv_Realm(mk_REALM`Realm({p10, p13}, {s13}))","type invariant satisfiable obligation:(exists n:N \u0026 (n \u003c max))","type invariant satisfiable obligation:(exists mk_NSeg(ps):NSeg \u0026 ((card ps) \u003d 2))","let be st existence obligation:(forall mk_NSeg(pts):NSeg \u0026 (exists p in set pts \u0026 true))","let be st existence obligation:(forall mk_NSeg(pts):NSeg \u0026 (forall p in set pts \u0026 (exists q in set (pts \\ {p}) \u0026 true)))","non-zero obligation:(forall s:NSeg, t:NSeg \u0026 let mk_(mk_NPoint(x11, y11), mk_NPoint(x12, y12)):(NPoint * NPoint) \u003d SelPoints(s), mk_(mk_NPoint(x21, y21), mk_NPoint(x22, y22)):(NPoint * NPoint) \u003d SelPoints(t) in let a11:int \u003d (x11 - x12), a12:int \u003d (x22 - x21), a21:int \u003d (y11 - y12), a22:int \u003d (y22 - y21), b1:int \u003d (x11 - x21), b2:int \u003d (y11 - y21) in let d1:int \u003d ((b1 * a22) - (b2 * a12)), d2:int \u003d ((b2 * a11) - (b1 * a21)), d:int \u003d ((a11 * a22) - (a12 * a21)) in ((d \u003c\u003e 0) \u003d\u003e (d \u003c\u003e 0)))","non-zero obligation:(forall s:NSeg, t:NSeg \u0026 let mk_(mk_NPoint(x11, y11), mk_NPoint(x12, y12)):(NPoint * NPoint) \u003d SelPoints(s), mk_(mk_NPoint(x21, y21), mk_NPoint(x22, y22)):(NPoint * NPoint) \u003d SelPoints(t) in let a11:int \u003d (x11 - x12), a12:int \u003d (x22 - x21), a21:int \u003d (y11 - y12), a22:int \u003d (y22 - y21), b1:int \u003d (x11 - x21), b2:int \u003d (y11 - y21) in let d1:int \u003d ((b1 * a22) - (b2 * a12)), d2:int \u003d ((b2 * a11) - (b1 * a21)), d:int \u003d ((a11 * a22) - (a12 * a21)) in ((d \u003c\u003e 0) \u003d\u003e (d \u003c\u003e 0)))","type compatibility obligation:(forall s:NSeg, t:NSeg \u0026 (Intersect(s, t) \u003d\u003e let mk_(mk_NPoint(x11, y11), mk_NPoint(x12, y12)):(NPoint * NPoint) \u003d SelPoints(s), mk_(mk_NPoint(x21, y21), mk_NPoint(x22, y22)):(NPoint * NPoint) \u003d SelPoints(t) in let a11:int \u003d (x11 - x12), a12:int \u003d (x22 - x21), a21:int \u003d (y11 - y12), a22:int \u003d (y22 - y21), b1:int \u003d (x11 - x21), b2:int \u003d (y11 - y21) in let d1:int \u003d ((b1 * a22) - (b2 * a12)), d:int \u003d ((a11 * a22) - (a12 * a21)) in ((d \u003c\u003e 0) \u003d\u003e let x0:int \u003d ((x11 * d) + (d1 * (x12 - x11))), y0:int \u003d ((y11 * d) + (d1 * (y12 - y11))) in inv_N(RoundToN((abs x0), (abs d))))))","type compatibility obligation:(forall s:NSeg, t:NSeg \u0026 (Intersect(s, t) \u003d\u003e let mk_(mk_NPoint(x11, y11), mk_NPoint(x12, y12)):(NPoint * NPoint) \u003d SelPoints(s), mk_(mk_NPoint(x21, y21), mk_NPoint(x22, y22)):(NPoint * NPoint) \u003d SelPoints(t) in let a11:int \u003d (x11 - x12), a12:int \u003d (x22 - x21), a21:int \u003d (y11 - y12), a22:int \u003d (y22 - y21), b1:int \u003d (x11 - x21), b2:int \u003d (y11 - y21) in let d1:int \u003d ((b1 * a22) - (b2 * a12)), d:int \u003d ((a11 * a22) - (a12 * a21)) in ((d \u003c\u003e 0) \u003d\u003e let x0:int \u003d ((x11 * d) + (d1 * (x12 - x11))), y0:int \u003d ((y11 * d) + (d1 * (y12 - y11))) in inv_N(RoundToN((abs y0), (abs d))))))","non-zero obligation:(forall a:nat, b:nat \u0026 ((a \u003e\u003d b) \u003d\u003e (b \u003c\u003e 0)))","type compatibility obligation:(forall a:nat, b:nat \u0026 (let mk_(z, aa):((int * int) | (nat * nat)) \u003d (if (a \u003e\u003d b)\nthen mk_((a div b), (a mod b))\nelse mk_(0, a)) in (if ((aa \u003d 0) or ((2 * aa) \u003c\u003d b))\nthen z\nelse (z + 1)) \u003e\u003d 0))","type invariant satisfiable obligation:(exists mk_Realm(ps, ss):Realm \u0026 ((forall mk_NSeg(pts) in set ss \u0026 (pts subset ps)) and ((forall s in set ss, p in set ps \u0026 (not In(p, s))) and (forall s1, s2 in set ss \u0026 ((s1 \u003c\u003e s2) \u003d\u003e ((not Intersect(s1, s2)) and (not Overlap(s1, s2))))))))","type compatibility obligation:(forall mk_Realm(ps, ss):Realm, p:NPoint \u0026 ((not (exists s in set ss \u0026 In(p, s))) \u003d\u003e ((p in set ps) \u003d\u003e inv_Realm(mk_Realm(ps, ss)))))","type compatibility obligation:(forall mk_Realm(ps, ss):Realm, p:NPoint \u0026 ((not (exists s in set ss \u0026 In(p, s))) \u003d\u003e ((not (p in set ps)) \u003d\u003e ((forall s in set ss \u0026 (p not in set E(s))) \u003d\u003e inv_Realm(mk_Realm((ps union {p}), ss))))))","type compatibility obligation:(forall mk_Realm(ps, ss):Realm, p:NPoint \u0026 ((not (exists s in set ss \u0026 In(p, s))) \u003d\u003e ((not (p in set ps)) \u003d\u003e ((not (forall s in set ss \u0026 (p not in set E(s)))) \u003d\u003e let s_env:set of (NSeg) \u003d {s | s in set ss \u0026 (p in set E(s))} in (forall mk_NSeg({p1, p2}) in set s_env \u0026 ((p not in set {p1, p2}) \u003d\u003e inv_NSeg(mk_NSeg({p1, p}))))))))","type compatibility obligation:(forall mk_Realm(ps, ss):Realm, p:NPoint \u0026 ((not (exists s in set ss \u0026 In(p, s))) \u003d\u003e ((not (p in set ps)) \u003d\u003e ((not (forall s in set ss \u0026 (p not in set E(s)))) \u003d\u003e let s_env:set of (NSeg) \u003d {s | s in set ss \u0026 (p in set E(s))} in (forall mk_NSeg({p1, p2}) in set s_env \u0026 ((p not in set {p1, p2}) \u003d\u003e inv_NSeg(mk_NSeg({p, p2}))))))))","type compatibility obligation:(forall mk_Realm(ps, ss):Realm, p:NPoint \u0026 ((not (exists s in set ss \u0026 In(p, s))) \u003d\u003e ((not (p in set ps)) \u003d\u003e ((not (forall s in set ss \u0026 (p not in set E(s)))) \u003d\u003e let s_env:set of (NSeg) \u003d {s | s in set ss \u0026 (p in set E(s))} in let ss1:set of (NSeg) \u003d (dunion {{mk_NSeg({p1, p}), mk_NSeg({p, p2})} | mk_NSeg({p1, p2}) in set s_env \u0026 (p not in set {p1, p2})}) in inv_Realm(mk_Realm((ps union {p}), ((ss union ss1) \\ s_env)))))))","type compatibility obligation:(forall mk_Realm(ps, ss):Realm, s:NSeg \u0026 (((s.pts) subset ps) \u003d\u003e ((s in set ss) \u003d\u003e inv_Realm(mk_Realm(ps, ss)))))","type compatibility obligation:(forall mk_Realm(ps, ss):Realm, s:NSeg \u0026 (((s.pts) subset ps) \u003d\u003e ((not (s in set ss)) \u003d\u003e (((forall p in set ps \u0026 (p not in set (E(s) \\ EndPoints(ss)))) and (forall t in set ss \u0026 ((not Intersect(s, t)) and (not Overlap(s, t))))) \u003d\u003e inv_Realm(mk_Realm(ps, (ss union {s})))))))","legal function application obligation:(forall mk_Realm(ps, ss):Realm, s:NSeg \u0026 (((s.pts) subset ps) \u003d\u003e ((not (s in set ss)) \u003d\u003e ((not ((forall p in set ps \u0026 (p not in set (E(s) \\ EndPoints(ss)))) and (forall t in set ss \u0026 ((not Intersect(s, t)) and (not Overlap(s, t)))))) \u003d\u003e let p_env:set of (NPoint) \u003d ({p | p in set (ps inter E(s))} \\ EndPoints(ss)), s_inter:set of (NSeg) \u003d {t | t in set ss \u0026 Intersect(s, t)} in pre_ChopNPoints(p_env, {s})))))","type compatibility obligation:(forall mk_Realm(ps, ss):Realm, s:NSeg \u0026 (((s.pts) subset ps) \u003d\u003e ((not (s in set ss)) \u003d\u003e ((not ((forall p in set ps \u0026 (p not in set (E(s) \\ EndPoints(ss)))) and (forall t in set ss \u0026 ((not Intersect(s, t)) and (not Overlap(s, t)))))) \u003d\u003e let p_env:set of (NPoint) \u003d ({p | p in set (ps inter E(s))} \\ EndPoints(ss)), s_inter:set of (NSeg) \u003d {t | t in set ss \u0026 Intersect(s, t)} in let ss1:set of (NSeg) \u003d ChopNPoints(p_env, {s}) in let mk_(new_ps, new_ss):(set of (NPoint) * set of (NSeg)) \u003d ChopNSegs(ss, s_inter, ss1, {}) in inv_Realm(mk_Realm((ps union new_ps), new_ss))))))","let be st existence obligation:(forall ps:set of (NPoint), ss:set of (NSeg) \u0026 ((forall p in set ps \u0026 (exists s in set ss \u0026 ((p in set E(s)) and (p not in set (s.pts))))) \u003d\u003e ((not (ps \u003d {})) \u003d\u003e (exists p in set ps \u0026 true))))","let be st existence obligation:(forall ps:set of (NPoint), ss:set of (NSeg) \u0026 ((forall p in set ps \u0026 (exists s in set ss \u0026 ((p in set E(s)) and (p not in set (s.pts))))) \u003d\u003e ((not (ps \u003d {})) \u003d\u003e (forall p in set ps \u0026 let s_env:set of (NSeg) \u003d {s | s in set ss \u0026 ((p in set E(s)) and (p not in set (s.pts)))} in (exists s in set s_env \u0026 true)))))","legal function application obligation:(forall ps:set of (NPoint), ss:set of (NSeg) \u0026 ((forall p in set ps \u0026 (exists s in set ss \u0026 ((p in set E(s)) and (p not in set (s.pts))))) \u003d\u003e ((not (ps \u003d {})) \u003d\u003e (forall p in set ps \u0026 let s_env:set of (NSeg) \u003d {s | s in set ss \u0026 ((p in set E(s)) and (p not in set (s.pts)))} in (forall s in set s_env \u0026 let mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in pre_ChopNPoints((ps \\ {p}), ((ss \\ {s}) union {mk_NSeg({p1, p}), mk_NSeg({p2, p})})))))))","type compatibility obligation:(forall ps:set of (NPoint), ss:set of (NSeg) \u0026 ((forall p in set ps \u0026 (exists s in set ss \u0026 ((p in set E(s)) and (p not in set (s.pts))))) \u003d\u003e ((not (ps \u003d {})) \u003d\u003e (forall p in set ps \u0026 let s_env:set of (NSeg) \u003d {s | s in set ss \u0026 ((p in set E(s)) and (p not in set (s.pts)))} in (forall s in set s_env \u0026 let mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in inv_NSeg(mk_NSeg({p1, p})))))))","type compatibility obligation:(forall ps:set of (NPoint), ss:set of (NSeg) \u0026 ((forall p in set ps \u0026 (exists s in set ss \u0026 ((p in set E(s)) and (p not in set (s.pts))))) \u003d\u003e ((not (ps \u003d {})) \u003d\u003e (forall p in set ps \u0026 let s_env:set of (NSeg) \u003d {s | s in set ss \u0026 ((p in set E(s)) and (p not in set (s.pts)))} in (forall s in set s_env \u0026 let mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in inv_NSeg(mk_NSeg({p2, p})))))))","let be st existence obligation:(forall ss:set of (NSeg), s_inter:set of (NSeg), newss:set of (NSeg), ps:set of (NPoint) \u0026 ((not (s_inter \u003d {})) \u003d\u003e (exists t in set s_inter \u0026 true)))","legal function application obligation:(forall ss:set of (NSeg), s_inter:set of (NSeg), newss:set of (NSeg), ps:set of (NPoint) \u0026 ((not (s_inter \u003d {})) \u003d\u003e (forall t in set s_inter \u0026 let {s}:set of (NSeg) \u003d {s | s in set newss \u0026 Intersect(s, t)} in pre_Intersection(t, s))))","type compatibility obligation:(forall ss:set of (NSeg), s_inter:set of (NSeg), newss:set of (NSeg), ps:set of (NPoint) \u0026 ((not (s_inter \u003d {})) \u003d\u003e (forall t in set s_inter \u0026 let {s}:set of (NSeg) \u003d {s | s in set newss \u0026 Intersect(s, t)} in let p:NPoint \u003d Intersection(t, s) in (forall sp in set (s.pts) \u0026 ((p \u003c\u003e sp) \u003d\u003e inv_NSeg(mk_NSeg({p, sp})))))))","type compatibility obligation:(forall ss:set of (NSeg), s_inter:set of (NSeg), newss:set of (NSeg), ps:set of (NPoint) \u0026 ((not (s_inter \u003d {})) \u003d\u003e (forall t in set s_inter \u0026 let {s}:set of (NSeg) \u003d {s | s in set newss \u0026 Intersect(s, t)} in let p:NPoint \u003d Intersection(t, s) in (forall tp in set (t.pts) \u0026 ((p \u003c\u003e tp) \u003d\u003e inv_NSeg(mk_NSeg({p, tp})))))))","type compatibility obligation:(forall s:NSeg \u0026 let mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in (forall x in set DiffX(p1, p2), y in set DiffY(p1, p2) \u0026 ((0 \u003c y) \u003d\u003e ((y \u003c (max - 1)) \u003d\u003e (inv_N((y - 1)) and is_((y - 1), nat))))))","type compatibility obligation:(forall s:NSeg \u0026 let mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in (forall x in set DiffX(p1, p2), y in set DiffY(p1, p2) \u0026 ((0 \u003c y) \u003d\u003e ((y \u003c (max - 1)) \u003d\u003e inv_N((y + 1))))))","type compatibility obligation:(forall s:NSeg \u0026 let mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in (forall x in set DiffX(p1, p2), y in set DiffY(p1, p2) \u0026 ((0 \u003c y) \u003d\u003e ((y \u003c (max - 1)) \u003d\u003e inv_NSeg(mk_NSeg({mk_NPoint(x, (y - 1)), mk_NPoint(x, (y + 1))}))))))","type compatibility obligation:(forall s:NSeg \u0026 let mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in (forall x in set DiffX(p1, p2), y in set DiffY(p1, p2) \u0026 ((not ((0 \u003c y) and ((y \u003c (max - 1)) and Intersect(mk_NSeg({mk_NPoint(x, (y - 1)), mk_NPoint(x, (y + 1))}), s)))) \u003d\u003e ((0 \u003c x) \u003d\u003e ((x \u003c (max - 1)) \u003d\u003e (inv_N((x - 1)) and is_((x - 1), nat)))))))","type compatibility obligation:(forall s:NSeg \u0026 let mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in (forall x in set DiffX(p1, p2), y in set DiffY(p1, p2) \u0026 ((not ((0 \u003c y) and ((y \u003c (max - 1)) and Intersect(mk_NSeg({mk_NPoint(x, (y - 1)), mk_NPoint(x, (y + 1))}), s)))) \u003d\u003e ((0 \u003c x) \u003d\u003e ((x \u003c (max - 1)) \u003d\u003e inv_N((x + 1)))))))","type compatibility obligation:(forall s:NSeg \u0026 let mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in (forall x in set DiffX(p1, p2), y in set DiffY(p1, p2) \u0026 ((not ((0 \u003c y) and ((y \u003c (max - 1)) and Intersect(mk_NSeg({mk_NPoint(x, (y - 1)), mk_NPoint(x, (y + 1))}), s)))) \u003d\u003e ((0 \u003c x) \u003d\u003e ((x \u003c (max - 1)) \u003d\u003e inv_NSeg(mk_NSeg({mk_NPoint((x - 1), y), mk_NPoint((x + 1), y)})))))))","legal sequence application obligation:(forall ss:set of (NSeg) \u0026 (forall sl in set AllLists(ss) \u0026 (forall i in set (inds sl) \u0026 (i in set (inds sl)))))","legal sequence application obligation:(forall ss:set of (NSeg) \u0026 (forall sl in set AllLists(ss) \u0026 (forall i in set (inds sl) \u0026 ((if (i \u003d (len sl))\nthen 1\nelse (i + 1)) in set (inds sl)))))","legal sequence application obligation:(forall ss:set of (NSeg) \u0026 (forall sl in set AllLists(ss) \u0026 (forall i in set (inds sl) \u0026 (Meet(sl(i), sl((if (i \u003d (len sl))\nthen 1\nelse (i + 1)))) \u003d\u003e (forall j in set ((inds sl) \\ {(if (i \u003d 1)\nthen (len sl)\nelse (i - 1)), i, (if (i \u003d (len sl))\nthen 1\nelse (i + 1))}) \u0026 (i in set (inds sl)))))))","legal sequence application obligation:(forall ss:set of (NSeg) \u0026 (forall sl in set AllLists(ss) \u0026 (forall i in set (inds sl) \u0026 (Meet(sl(i), sl((if (i \u003d (len sl))\nthen 1\nelse (i + 1)))) \u003d\u003e (forall j in set ((inds sl) \\ {(if (i \u003d 1)\nthen (len sl)\nelse (i - 1)), i, (if (i \u003d (len sl))\nthen 1\nelse (i + 1))}) \u0026 (j in set (inds sl)))))))","type invariant satisfiable obligation:(exists ss:Cycle \u0026 CycleCheck(ss))","legal function application obligation:(forall p:NPoint, c:Cycle \u0026 ((not OnCycle(p, c)) \u003d\u003e pre_SR(p, c)))","legal function application obligation:(forall p:NPoint, ss:Cycle \u0026 (CycleCheck(ss) \u003d\u003e (forall s in set ss \u0026 let mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in (((p.y) \u003c (max - 1)) \u003d\u003e pre_SP(p)))))","legal function application obligation:(forall p:NPoint, ss:Cycle \u0026 (CycleCheck(ss) \u003d\u003e (forall s in set ss \u0026 let mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in (((p.y) \u003c (max - 1)) \u003d\u003e ((not On(p1, SP(p))) \u003d\u003e pre_SP(p))))))","legal function application obligation:(forall p:NPoint, ss:Cycle \u0026 (CycleCheck(ss) \u003d\u003e (forall s in set ss \u0026 let mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in ((not (((p.y) \u003c (max - 1)) and ((not On(p1, SP(p))) and On(p2, SP(p))))) \u003d\u003e (((p.y) \u003c (max - 1)) \u003d\u003e pre_SP(p))))))","legal function application obligation:(forall p:NPoint, ss:Cycle \u0026 (CycleCheck(ss) \u003d\u003e (forall s in set ss \u0026 let mk_(p1, p2):(NPoint * NPoint) \u003d SelPoints(s) in ((not (((p.y) \u003c (max - 1)) and ((not On(p1, SP(p))) and On(p2, SP(p))))) \u003d\u003e (((p.y) \u003c (max - 1)) \u003d\u003e ((not On(p2, SP(p))) \u003d\u003e pre_SP(p)))))))","legal function application obligation:(forall p:NPoint, ss:Cycle \u0026 (forall s in set ss \u0026 (((p.y) \u003c (max - 1)) \u003d\u003e pre_SP(p))))","type compatibility obligation:(forall mk_NPoint(x, y):NPoint \u0026 ((y \u003c (max - 1)) \u003d\u003e (inv_N((max - 1)) and is_((max - 1), nat))))","type compatibility obligation:(forall mk_NPoint(x, y):NPoint \u0026 ((y \u003c (max - 1)) \u003d\u003e inv_NSeg(mk_NSeg({mk_NPoint(x, y), mk_NPoint(x, (max - 1))}))))","type compatibility obligation:(forall pred:(NPoint * set of (NSeg) -\u003e bool), ss:Cycle \u0026 (forall x in set {0, ... ,(max - 1)}, y in set {0, ... ,(max - 1)} \u0026 (pred(mk_NPoint(x, y), ss) \u003d\u003e inv_N(x))))","type compatibility obligation:(forall pred:(NPoint * set of (NSeg) -\u003e bool), ss:Cycle \u0026 (forall x in set {0, ... ,(max - 1)}, y in set {0, ... ,(max - 1)} \u0026 (pred(mk_NPoint(x, y), ss) \u003d\u003e inv_N(y))))","legal function application obligation:(forall pred:(NPoint * set of (NSeg) -\u003e bool), ss:Cycle \u0026 (forall x in set {0, ... ,(max - 1)}, y in set {0, ... ,(max - 1)} \u0026 pre_(predmk_NPoint(x, y), ss)))","type compatibility obligation:(forall pred:(NPoint * set of (NSeg) -\u003e bool), ss:Cycle \u0026 (forall x in set {0, ... ,(max - 1)}, y in set {0, ... ,(max - 1)} \u0026 inv_N(x)))","type compatibility obligation:(forall pred:(NPoint * set of (NSeg) -\u003e bool), ss:Cycle \u0026 (forall x in set {0, ... ,(max - 1)}, y in set {0, ... ,(max - 1)} \u0026 inv_N(y)))","type invariant satisfiable obligation:(exists mk_Face(c, hs):Face \u0026 ((forall h in set hs \u0026 EdgeInside(h, c)) and ((forall h1, h2 in set hs \u0026 ((h1 \u003c\u003e h2) \u003d\u003e EdgeDisjoint(h1, h2))) and (forall ss in set (power (c union (dunion hs))) \u0026 (CycleCheck(ss) \u003d\u003e (ss in set (hs union {c})))))))"]