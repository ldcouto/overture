["type invariant satisfiable obligation:(exists mk_PortType(label, cardinality, portlist):PortType \u0026 (cardinality \u003d (card (elems portlist))))","type invariant satisfiable obligation:(exists mk_Event(label, type, porttype):Event \u0026 (((type \u003d \u003cINTERNAL\u003e) and ((porttype.label) \u003d \"NULLPORT\")) or (((type \u003d \u003cINPUT\u003e) and ((porttype.label) \u003c\u003e \"NULLPORT\")) or ((type \u003d \u003cOUTPUT\u003e) and ((porttype.label) \u003c\u003e \"NULLPORT\")))))","type invariant satisfiable obligation:(exists mk_State(label, type, isinitial, substates):State \u0026 let exists_entry_state: (set of (State) +\u003e bool)\n\texists_entry_state(substates) \u003d\u003d\n((exists1 s in set substates \u0026 ((s.isinitial) \u003d true)) and (forall s in set substates \u0026 ((((s.type) \u003d \u003cSIMPLE\u003e) and ((s.substates) \u003d {})) or (((s.type) \u003d \u003cCOMPLEX\u003e) and exists_entry_state((s.substates)))))) in (((type \u003d \u003cSIMPLE\u003e) and (substates \u003d {})) or ((type \u003d \u003cCOMPLEX\u003e) and exists_entry_state(substates))))","type invariant satisfiable obligation:(exists mk_TimeConstraint(label, transition, cevent, tbounds, dstates, rwindows):TimeConstraint \u0026 ((((cevent.type) \u003d \u003cINTERNAL\u003e) or ((cevent.type) \u003d \u003cOUTPUT\u003e)) and (forall rw in set rwindows \u0026 (((rw.uppertimebound) - (rw.lowertimebound)) \u003d ((tbounds.uppertimebound) - (tbounds.lowertimebound))))))","type invariant satisfiable obligation:(exists mk_ReactionWindow(lowertimebound, uppertimebound):ReactionWindow \u0026 (lowertimebound \u003c\u003d uppertimebound))","type invariant satisfiable obligation:(exists mk_PortLink(tromporttuple1, tromporttuple2):PortLink \u0026 ((tromporttuple1.tromlabel) \u003c\u003e (tromporttuple2.tromlabel)))","legal function application obligation:(forall mk_Trom(label, tromclass, porttypes, events, states, attributes, lsltraits, attrfunctions, transitionspecs, timeconstraints, currentstate, assignmentvector):Trom \u0026 ((forall pt1, pt2 in set porttypes \u0026 (((pt1.label) \u003d (pt2.label)) \u003d\u003e (pt1 \u003d pt2))) \u003d\u003e ((forall e1, e2 in set events \u0026 (((e1.label) \u003d (e2.label)) \u003d\u003e (e1 \u003d e2))) \u003d\u003e ((forall s1, s2 in set states \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) \u003d\u003e ((forall a1, a2 in set attributes \u0026 (((a1.label) \u003d (a2.label)) \u003d\u003e (a1 \u003d a2))) \u003d\u003e ((forall tr1, tr2 in set lsltraits \u0026 (((tr1.traittype) \u003d (tr2.traittype)) \u003d\u003e (tr1 \u003d tr2))) \u003d\u003e ((forall af1, af2 in set attrfunctions \u0026 (((af1.stat) \u003d (af2.stat)) \u003d\u003e (af1 \u003d af2))) \u003d\u003e ((forall ts1, ts2 in set transitionspecs \u0026 (((ts1.label) \u003d (ts2.label)) \u003d\u003e (ts1 \u003d ts2))) \u003d\u003e ((forall tc1, tc2 in set timeconstraints \u0026 (((tc1.label) \u003d (tc2.label)) \u003d\u003e (tc1 \u003d tc2))) \u003d\u003e ((forall e in set events \u0026 (exists pt in set porttypes \u0026 (pt \u003d (e.porttype)))) \u003d\u003e ((exists1 s in set states \u0026 ((s.isinitial) \u003d true)) \u003d\u003e (forall s in set states \u0026 ((not (currentstate \u003d s)) \u003d\u003e pre_substate_of(currentstate, s))))))))))))))","legal function application obligation:(forall mk_Trom(label, tromclass, porttypes, events, states, attributes, lsltraits, attrfunctions, transitionspecs, timeconstraints, currentstate, assignmentvector):Trom \u0026 ((forall pt1, pt2 in set porttypes \u0026 (((pt1.label) \u003d (pt2.label)) \u003d\u003e (pt1 \u003d pt2))) \u003d\u003e ((forall e1, e2 in set events \u0026 (((e1.label) \u003d (e2.label)) \u003d\u003e (e1 \u003d e2))) \u003d\u003e ((forall s1, s2 in set states \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) \u003d\u003e ((forall a1, a2 in set attributes \u0026 (((a1.label) \u003d (a2.label)) \u003d\u003e (a1 \u003d a2))) \u003d\u003e ((forall tr1, tr2 in set lsltraits \u0026 (((tr1.traittype) \u003d (tr2.traittype)) \u003d\u003e (tr1 \u003d tr2))) \u003d\u003e ((forall af1, af2 in set attrfunctions \u0026 (((af1.stat) \u003d (af2.stat)) \u003d\u003e (af1 \u003d af2))) \u003d\u003e ((forall ts1, ts2 in set transitionspecs \u0026 (((ts1.label) \u003d (ts2.label)) \u003d\u003e (ts1 \u003d ts2))) \u003d\u003e ((forall tc1, tc2 in set timeconstraints \u0026 (((tc1.label) \u003d (tc2.label)) \u003d\u003e (tc1 \u003d tc2))) \u003d\u003e ((forall e in set events \u0026 (exists pt in set porttypes \u0026 (pt \u003d (e.porttype)))) \u003d\u003e ((exists1 s in set states \u0026 ((s.isinitial) \u003d true)) \u003d\u003e ((exists1 s in set states \u0026 ((currentstate \u003d s) or substate_of(currentstate, s))) \u003d\u003e ((forall a in set attributes \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d (a.type))) or (exists1 tr in set lsltraits \u0026 ((tr.traittype) \u003d (a.type))))) \u003d\u003e ((forall tr in set lsltraits \u0026 (forall el in set (elems (tr.elementtypes)) \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d el)) or (exists1 tr2 in set lsltraits \u0026 ((tr2.traittype) \u003d el))))) \u003d\u003e (forall af in set attrfunctions \u0026 (forall s in set states \u0026 ((not (s \u003d (af.stat))) \u003d\u003e pre_substate_of((af.stat), s))))))))))))))))))","legal function application obligation:(forall mk_Trom(label, tromclass, porttypes, events, states, attributes, lsltraits, attrfunctions, transitionspecs, timeconstraints, currentstate, assignmentvector):Trom \u0026 ((forall pt1, pt2 in set porttypes \u0026 (((pt1.label) \u003d (pt2.label)) \u003d\u003e (pt1 \u003d pt2))) \u003d\u003e ((forall e1, e2 in set events \u0026 (((e1.label) \u003d (e2.label)) \u003d\u003e (e1 \u003d e2))) \u003d\u003e ((forall s1, s2 in set states \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) \u003d\u003e ((forall a1, a2 in set attributes \u0026 (((a1.label) \u003d (a2.label)) \u003d\u003e (a1 \u003d a2))) \u003d\u003e ((forall tr1, tr2 in set lsltraits \u0026 (((tr1.traittype) \u003d (tr2.traittype)) \u003d\u003e (tr1 \u003d tr2))) \u003d\u003e ((forall af1, af2 in set attrfunctions \u0026 (((af1.stat) \u003d (af2.stat)) \u003d\u003e (af1 \u003d af2))) \u003d\u003e ((forall ts1, ts2 in set transitionspecs \u0026 (((ts1.label) \u003d (ts2.label)) \u003d\u003e (ts1 \u003d ts2))) \u003d\u003e ((forall tc1, tc2 in set timeconstraints \u0026 (((tc1.label) \u003d (tc2.label)) \u003d\u003e (tc1 \u003d tc2))) \u003d\u003e ((forall e in set events \u0026 (exists pt in set porttypes \u0026 (pt \u003d (e.porttype)))) \u003d\u003e ((exists1 s in set states \u0026 ((s.isinitial) \u003d true)) \u003d\u003e ((exists1 s in set states \u0026 ((currentstate \u003d s) or substate_of(currentstate, s))) \u003d\u003e ((forall a in set attributes \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d (a.type))) or (exists1 tr in set lsltraits \u0026 ((tr.traittype) \u003d (a.type))))) \u003d\u003e ((forall tr in set lsltraits \u0026 (forall el in set (elems (tr.elementtypes)) \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d el)) or (exists1 tr2 in set lsltraits \u0026 ((tr2.traittype) \u003d el))))) \u003d\u003e ((forall af in set attrfunctions \u0026 ((exists1 s in set states \u0026 ((s \u003d (af.stat)) or substate_of((af.stat), s))) and (forall afa in set (af.attributes) \u0026 (exists1 a in set attributes \u0026 (a \u003d afa))))) \u003d\u003e (forall ts in set transitionspecs \u0026 (forall s in set states \u0026 ((not (s \u003d (ts.sourcestate))) \u003d\u003e pre_substate_of((ts.sourcestate), s)))))))))))))))))))","legal function application obligation:(forall mk_Trom(label, tromclass, porttypes, events, states, attributes, lsltraits, attrfunctions, transitionspecs, timeconstraints, currentstate, assignmentvector):Trom \u0026 ((forall pt1, pt2 in set porttypes \u0026 (((pt1.label) \u003d (pt2.label)) \u003d\u003e (pt1 \u003d pt2))) \u003d\u003e ((forall e1, e2 in set events \u0026 (((e1.label) \u003d (e2.label)) \u003d\u003e (e1 \u003d e2))) \u003d\u003e ((forall s1, s2 in set states \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) \u003d\u003e ((forall a1, a2 in set attributes \u0026 (((a1.label) \u003d (a2.label)) \u003d\u003e (a1 \u003d a2))) \u003d\u003e ((forall tr1, tr2 in set lsltraits \u0026 (((tr1.traittype) \u003d (tr2.traittype)) \u003d\u003e (tr1 \u003d tr2))) \u003d\u003e ((forall af1, af2 in set attrfunctions \u0026 (((af1.stat) \u003d (af2.stat)) \u003d\u003e (af1 \u003d af2))) \u003d\u003e ((forall ts1, ts2 in set transitionspecs \u0026 (((ts1.label) \u003d (ts2.label)) \u003d\u003e (ts1 \u003d ts2))) \u003d\u003e ((forall tc1, tc2 in set timeconstraints \u0026 (((tc1.label) \u003d (tc2.label)) \u003d\u003e (tc1 \u003d tc2))) \u003d\u003e ((forall e in set events \u0026 (exists pt in set porttypes \u0026 (pt \u003d (e.porttype)))) \u003d\u003e ((exists1 s in set states \u0026 ((s.isinitial) \u003d true)) \u003d\u003e ((exists1 s in set states \u0026 ((currentstate \u003d s) or substate_of(currentstate, s))) \u003d\u003e ((forall a in set attributes \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d (a.type))) or (exists1 tr in set lsltraits \u0026 ((tr.traittype) \u003d (a.type))))) \u003d\u003e ((forall tr in set lsltraits \u0026 (forall el in set (elems (tr.elementtypes)) \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d el)) or (exists1 tr2 in set lsltraits \u0026 ((tr2.traittype) \u003d el))))) \u003d\u003e ((forall af in set attrfunctions \u0026 ((exists1 s in set states \u0026 ((s \u003d (af.stat)) or substate_of((af.stat), s))) and (forall afa in set (af.attributes) \u0026 (exists1 a in set attributes \u0026 (a \u003d afa))))) \u003d\u003e (forall ts in set transitionspecs \u0026 ((exists1 s in set states \u0026 ((s \u003d (ts.sourcestate)) or substate_of((ts.sourcestate), s))) \u003d\u003e (forall d in set states \u0026 ((not (d \u003d (ts.destinstate))) \u003d\u003e pre_substate_of((ts.destinstate), d))))))))))))))))))))","legal function application obligation:(forall mk_Trom(label, tromclass, porttypes, events, states, attributes, lsltraits, attrfunctions, transitionspecs, timeconstraints, currentstate, assignmentvector):Trom \u0026 ((forall pt1, pt2 in set porttypes \u0026 (((pt1.label) \u003d (pt2.label)) \u003d\u003e (pt1 \u003d pt2))) \u003d\u003e ((forall e1, e2 in set events \u0026 (((e1.label) \u003d (e2.label)) \u003d\u003e (e1 \u003d e2))) \u003d\u003e ((forall s1, s2 in set states \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) \u003d\u003e ((forall a1, a2 in set attributes \u0026 (((a1.label) \u003d (a2.label)) \u003d\u003e (a1 \u003d a2))) \u003d\u003e ((forall tr1, tr2 in set lsltraits \u0026 (((tr1.traittype) \u003d (tr2.traittype)) \u003d\u003e (tr1 \u003d tr2))) \u003d\u003e ((forall af1, af2 in set attrfunctions \u0026 (((af1.stat) \u003d (af2.stat)) \u003d\u003e (af1 \u003d af2))) \u003d\u003e ((forall ts1, ts2 in set transitionspecs \u0026 (((ts1.label) \u003d (ts2.label)) \u003d\u003e (ts1 \u003d ts2))) \u003d\u003e ((forall tc1, tc2 in set timeconstraints \u0026 (((tc1.label) \u003d (tc2.label)) \u003d\u003e (tc1 \u003d tc2))) \u003d\u003e ((forall e in set events \u0026 (exists pt in set porttypes \u0026 (pt \u003d (e.porttype)))) \u003d\u003e ((exists1 s in set states \u0026 ((s.isinitial) \u003d true)) \u003d\u003e ((exists1 s in set states \u0026 ((currentstate \u003d s) or substate_of(currentstate, s))) \u003d\u003e ((forall a in set attributes \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d (a.type))) or (exists1 tr in set lsltraits \u0026 ((tr.traittype) \u003d (a.type))))) \u003d\u003e ((forall tr in set lsltraits \u0026 (forall el in set (elems (tr.elementtypes)) \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d el)) or (exists1 tr2 in set lsltraits \u0026 ((tr2.traittype) \u003d el))))) \u003d\u003e ((forall af in set attrfunctions \u0026 ((exists1 s in set states \u0026 ((s \u003d (af.stat)) or substate_of((af.stat), s))) and (forall afa in set (af.attributes) \u0026 (exists1 a in set attributes \u0026 (a \u003d afa))))) \u003d\u003e ((forall ts in set transitionspecs \u0026 ((exists1 s in set states \u0026 ((s \u003d (ts.sourcestate)) or substate_of((ts.sourcestate), s))) and ((exists1 d in set states \u0026 ((d \u003d (ts.destinstate)) or substate_of((ts.destinstate), d))) and (exists1 e in set events \u0026 (e \u003d (ts.triggerevent)))))) \u003d\u003e (forall tc in set timeconstraints \u0026 ((exists1 ts in set transitionspecs \u0026 (ts \u003d (tc.transition))) \u003d\u003e ((exists1 e in set events \u0026 ((e \u003d (tc.constrainedevent)) and (((e.type) \u003d \u003cINTERNAL\u003e) or ((e.type) \u003d \u003cOUTPUT\u003e)))) \u003d\u003e (forall ds in set (tc.disablingstates) \u0026 (forall s in set states \u0026 ((not (s \u003d ds)) \u003d\u003e pre_substate_of(ds, s)))))))))))))))))))))))","type invariant satisfiable obligation:(exists mk_Trom(label, tromclass, porttypes, events, states, attributes, lsltraits, attrfunctions, transitionspecs, timeconstraints, currentstate, assignmentvector):Trom \u0026 ((forall pt1, pt2 in set porttypes \u0026 (((pt1.label) \u003d (pt2.label)) \u003d\u003e (pt1 \u003d pt2))) and ((forall e1, e2 in set events \u0026 (((e1.label) \u003d (e2.label)) \u003d\u003e (e1 \u003d e2))) and ((forall s1, s2 in set states \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) and ((forall a1, a2 in set attributes \u0026 (((a1.label) \u003d (a2.label)) \u003d\u003e (a1 \u003d a2))) and ((forall tr1, tr2 in set lsltraits \u0026 (((tr1.traittype) \u003d (tr2.traittype)) \u003d\u003e (tr1 \u003d tr2))) and ((forall af1, af2 in set attrfunctions \u0026 (((af1.stat) \u003d (af2.stat)) \u003d\u003e (af1 \u003d af2))) and ((forall ts1, ts2 in set transitionspecs \u0026 (((ts1.label) \u003d (ts2.label)) \u003d\u003e (ts1 \u003d ts2))) and ((forall tc1, tc2 in set timeconstraints \u0026 (((tc1.label) \u003d (tc2.label)) \u003d\u003e (tc1 \u003d tc2))) and ((forall e in set events \u0026 (exists pt in set porttypes \u0026 (pt \u003d (e.porttype)))) and ((exists1 s in set states \u0026 ((s.isinitial) \u003d true)) and ((exists1 s in set states \u0026 ((currentstate \u003d s) or substate_of(currentstate, s))) and ((forall a in set attributes \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d (a.type))) or (exists1 tr in set lsltraits \u0026 ((tr.traittype) \u003d (a.type))))) and ((forall tr in set lsltraits \u0026 (forall el in set (elems (tr.elementtypes)) \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d el)) or (exists1 tr2 in set lsltraits \u0026 ((tr2.traittype) \u003d el))))) and ((forall af in set attrfunctions \u0026 ((exists1 s in set states \u0026 ((s \u003d (af.stat)) or substate_of((af.stat), s))) and (forall afa in set (af.attributes) \u0026 (exists1 a in set attributes \u0026 (a \u003d afa))))) and ((forall ts in set transitionspecs \u0026 ((exists1 s in set states \u0026 ((s \u003d (ts.sourcestate)) or substate_of((ts.sourcestate), s))) and ((exists1 d in set states \u0026 ((d \u003d (ts.destinstate)) or substate_of((ts.destinstate), d))) and (exists1 e in set events \u0026 (e \u003d (ts.triggerevent)))))) and (forall tc in set timeconstraints \u0026 ((exists1 ts in set transitionspecs \u0026 (ts \u003d (tc.transition))) and ((exists1 e in set events \u0026 ((e \u003d (tc.constrainedevent)) and (((e.type) \u003d \u003cINTERNAL\u003e) or ((e.type) \u003d \u003cOUTPUT\u003e)))) and (forall ds in set (tc.disablingstates) \u0026 (exists1 s in set states \u0026 ((s \u003d ds) or substate_of(ds, s)))))))))))))))))))))))","finite set obligation:(forall mk_Subsystem(label, includes, troms, portlinks):Subsystem \u0026 ((forall s1, s2 in set includes \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) \u003d\u003e (let included_subsystem: (String * set of (Subsystem) +\u003e bool)\n\tincluded_subsystem(subsystemlabel, subsystems) \u003d\u003d\n(exists1 s in set subsystems \u0026 (((s.label) \u003d subsystemlabel) or included_subsystem(subsystemlabel, (s.includes)))) in (not included_subsystem(label, includes)) \u003d\u003e ((forall trom1, trom2 in set troms \u0026 (((trom1.label) \u003d (trom2.label)) \u003d\u003e (trom1 \u003d trom2))) \u003d\u003e (let included_trom: (String * set of (Subsystem) +\u003e bool)\n\tincluded_trom(tromlabel, subsystems) \u003d\u003d\n(exists1 s in set subsystems \u0026 ((exists1 trom in set (s.troms) \u0026 ((trom.label) \u003d tromlabel)) or included_trom(tromlabel, (s.includes)))) in (forall trom in set troms \u0026 (not included_trom((trom.label), includes))) \u003d\u003e (forall tptuple:TromPortTuple, subsystems:set of (Subsystem) \u0026 (forall s in set subsystems \u0026 (((linked_trom(tptuple, (s.troms)) and (not linked_subsystem(tptuple, (s.includes)))) or ((not linked_trom(tptuple, (s.troms))) and linked_subsystem(tptuple, (s.includes)))) \u003d\u003e (exists finmap1:map (nat) to (Subsystem) \u0026 (forall su:Subsystem \u0026 (((su in set subsystems) and (su \u003c\u003e s)) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d su)))))))))))))","type invariant satisfiable obligation:(exists mk_Subsystem(label, includes, troms, portlinks):Subsystem \u0026 ((forall s1, s2 in set includes \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) and (let included_subsystem: (String * set of (Subsystem) +\u003e bool)\n\tincluded_subsystem(subsystemlabel, subsystems) \u003d\u003d\n(exists1 s in set subsystems \u0026 (((s.label) \u003d subsystemlabel) or included_subsystem(subsystemlabel, (s.includes)))) in (not included_subsystem(label, includes)) and ((forall trom1, trom2 in set troms \u0026 (((trom1.label) \u003d (trom2.label)) \u003d\u003e (trom1 \u003d trom2))) and (let included_trom: (String * set of (Subsystem) +\u003e bool)\n\tincluded_trom(tromlabel, subsystems) \u003d\u003d\n(exists1 s in set subsystems \u0026 ((exists1 trom in set (s.troms) \u0026 ((trom.label) \u003d tromlabel)) or included_trom(tromlabel, (s.includes)))) in (forall trom in set troms \u0026 (not included_trom((trom.label), includes))) and let linked_trom: (TromPortTuple * set of (Trom) +\u003e bool)\n\tlinked_trom(tptuple, troms) \u003d\u003d\n(exists1 trom in set troms \u0026 (((trom.label) \u003d (tptuple.tromlabel)) and (exists1 pt in set (trom.porttypes) \u0026 (exists1 p in set (elems (pt.portlist)) \u0026 ((p.label) \u003d (tptuple.portlabel)))))), linked_subsystem: (TromPortTuple * set of (Subsystem) +\u003e bool)\n\tlinked_subsystem(tptuple, subsystems) \u003d\u003d\n(exists1 s in set subsystems \u0026 (((linked_trom(tptuple, (s.troms)) and (not linked_subsystem(tptuple, (s.includes)))) or ((not linked_trom(tptuple, (s.troms))) and linked_subsystem(tptuple, (s.includes)))) and (forall s2 in set {su | su:Subsystem \u0026 ((su in set subsystems) and (su \u003c\u003e s))} \u0026 ((not linked_trom(tptuple, (s2.troms))) and (not linked_subsystem(tptuple, (s2.includes))))))) in (forall pl in set portlinks \u0026 (((linked_trom((pl.tromporttuple1), troms) and (not linked_subsystem((pl.tromporttuple1), includes))) or ((not linked_trom((pl.tromporttuple1), troms)) and linked_subsystem((pl.tromporttuple1), includes))) and ((linked_trom((pl.tromporttuple2), troms) and (not linked_subsystem((pl.tromporttuple2), includes))) or ((not linked_trom((pl.tromporttuple2), troms)) and linked_subsystem((pl.tromporttuple2), includes))))))))))","legal sequence application obligation:(forall mk_System(subsystem, simulationeventlist, lsllibrary, clock):System \u0026 (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) \u003d\u003e (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) \u003d\u003e (forall i, j in set (inds simulationeventlist) \u0026 ((i \u003d j) \u003d\u003e (i in set (inds simulationeventlist)))))))","legal sequence application obligation:(forall mk_System(subsystem, simulationeventlist, lsllibrary, clock):System \u0026 (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) \u003d\u003e (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) \u003d\u003e (forall i, j in set (inds simulationeventlist) \u0026 ((i \u003d j) \u003d\u003e (j in set (inds simulationeventlist)))))))","legal sequence application obligation:(forall mk_System(subsystem, simulationeventlist, lsllibrary, clock):System \u0026 (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) \u003d\u003e (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) \u003d\u003e (forall i, j in set (inds simulationeventlist) \u0026 ((not ((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j)))) \u003d\u003e ((i \u003c j) \u003d\u003e (i in set (inds simulationeventlist))))))))","legal sequence application obligation:(forall mk_System(subsystem, simulationeventlist, lsllibrary, clock):System \u0026 (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) \u003d\u003e (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) \u003d\u003e (forall i, j in set (inds simulationeventlist) \u0026 ((not ((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j)))) \u003d\u003e ((i \u003c j) \u003d\u003e (j in set (inds simulationeventlist))))))))","legal sequence application obligation:(forall mk_System(subsystem, simulationeventlist, lsllibrary, clock):System \u0026 (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) \u003d\u003e (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) \u003d\u003e (forall i, j in set (inds simulationeventlist) \u0026 ((not ((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j)))) \u003d\u003e ((not ((i \u003c j) and ((simulationeventlist(i).occurtime) \u003c\u003d (simulationeventlist(j).occurtime)))) \u003d\u003e ((i \u003e j) \u003d\u003e (i in set (inds simulationeventlist)))))))))","legal sequence application obligation:(forall mk_System(subsystem, simulationeventlist, lsllibrary, clock):System \u0026 (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) \u003d\u003e (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) \u003d\u003e (forall i, j in set (inds simulationeventlist) \u0026 ((not ((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j)))) \u003d\u003e ((not ((i \u003c j) and ((simulationeventlist(i).occurtime) \u003c\u003d (simulationeventlist(j).occurtime)))) \u003d\u003e ((i \u003e j) \u003d\u003e (j in set (inds simulationeventlist)))))))))","finite set obligation:(forall mk_System(subsystem, simulationeventlist, lsllibrary, clock):System \u0026 (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) \u003d\u003e (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) \u003d\u003e ((forall i, j in set (inds simulationeventlist) \u0026 (((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j))) or (((i \u003c j) and ((simulationeventlist(i).occurtime) \u003c\u003d (simulationeventlist(j).occurtime))) or ((i \u003e j) and ((simulationeventlist(i).occurtime) \u003e\u003d (simulationeventlist(j).occurtime)))))) \u003d\u003e ((forall se1, se2 in set (elems simulationeventlist) \u0026 ((((se1.occurtime) \u003d (se2.occurtime)) and ((se1.tromlabel) \u003c\u003e (se2.tromlabel))) or ((se1.occurtime) \u003c\u003e (se2.occurtime)))) \u003d\u003e let accepted_by_trom: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_trom(se, subsys) \u003d\u003d\n(exists1 trom in set (subsys.troms) \u0026 (((trom.label) \u003d (se.tromlabel)) and (exists1 e in set (trom.events) \u0026 (((e.label) \u003d (se.eventlabel)) and (exists1 pt in set (trom.porttypes) \u0026 ((pt \u003d (e.porttype)) and (exists1 p in set (elems (pt.portlist)) \u0026 ((p.label) \u003d (se.portlabel))))))))) in (forall se:SimulationEvent, subsys:Subsystem \u0026 (forall s in set (subsys.includes) \u0026 (((accepted_by_trom(se, s) and (not accepted_by_subsystem(se, s))) or ((not accepted_by_trom(se, s)) and accepted_by_subsystem(se, s))) \u003d\u003e (exists finmap1:map (nat) to (Subsystem) \u0026 (forall su:Subsystem \u0026 (((su in set (subsys.includes)) and (su \u003c\u003e s)) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d su)))))))))))))","function postcondition satisfiable obligation:(forall tromlabel:String, subsystem:Subsystem \u0026 (exists trom:[Trom] \u0026 post_get_trom_object(tromlabel, subsystem, trom)))","legal function application obligation:(forall trom:Trom, se:SimulationEvent \u0026 (((trom.label) \u003d (se.tromlabel)) \u003d\u003e (exists ts:[TransitionSpec] \u0026 ((ts in set (trom.transitionspecs)) \u003d\u003e ((not (((trom.currentstate).label) \u003d ((ts.sourcestate).label))) \u003d\u003e pre_substate_of((trom.currentstate), (ts.sourcestate)))))))","function postcondition satisfiable obligation:(forall trom:Trom, se:SimulationEvent \u0026 (pre_get_transition_spec(trom, se) \u003d\u003e (exists ts:[TransitionSpec] \u0026 post_get_transition_spec(trom, se, ts))))","legal function application obligation:(forall substate:State, complexstate:State \u0026 (((complexstate.type) \u003d \u003cCOMPLEX\u003e) \u003d\u003e ((not (substate in set (complexstate.substates))) \u003d\u003e (forall s in set (complexstate.substates) \u0026 (((s.type) \u003d \u003cCOMPLEX\u003e) \u003d\u003e pre_substate_of(substate, s))))))","legal function application obligation:(forall complexstate:State \u0026 (((complexstate.type) \u003d \u003cCOMPLEX\u003e) \u003d\u003e (exists entry:State \u0026 (forall s in set (complexstate.substates) \u0026 (((s.isinitial) \u003d true) \u003d\u003e ((not (((s.type) \u003d \u003cSIMPLE\u003e) and (entry \u003d s))) \u003d\u003e (((s.type) \u003d \u003cCOMPLEX\u003e) \u003d\u003e pre_get_entry_state(s))))))))","function postcondition satisfiable obligation:(forall complexstate:State \u0026 (pre_get_entry_state(complexstate) \u003d\u003e (exists entry:State \u0026 post_get_entry_state(complexstate, entry))))","legal function application obligation:(forall trom:Trom \u0026 (((trom.states) \u003c\u003e {}) \u003d\u003e (exists initial:State \u0026 (forall s in set (trom.states) \u0026 (((s.isinitial) \u003d true) \u003d\u003e ((not (((s.type) \u003d \u003cSIMPLE\u003e) and (initial \u003d s))) \u003d\u003e (((s.type) \u003d \u003cCOMPLEX\u003e) \u003d\u003e pre_get_entry_state(s))))))))","function postcondition satisfiable obligation:(forall trom:Trom \u0026 (pre_get_initial_state(trom) \u003d\u003e (exists initial:State \u0026 post_get_initial_state(trom, initial))))","function postcondition satisfiable obligation:(forall tupleA:TromPortTuple, subsystem:Subsystem \u0026 (exists tupleB:[TromPortTuple] \u0026 post_get_linked_tromport_tuple(tupleA, subsystem, tupleB)))","legal function application obligation:(forall trom:Trom, subsys:Subsystem \u0026 ((((subsys.troms) \u003c\u003e {}) or ((subsys.includes) \u003c\u003e {})) \u003d\u003e ((not (trom in set (subsys.troms))) \u003d\u003e (forall subsystem in set (subsys.includes) \u0026 pre_exists_in_subsystem(trom, subsystem)))))","legal function application obligation:(forall trom:Trom \u0026 (exists event:[Event] \u0026 (forall ts in set (trom.transitionspecs) \u0026 (((ts.sourcestate) \u003d (trom.currentstate)) \u003d\u003e ((((ts.triggerevent).type) \u003d \u003cINTERNAL\u003e) \u003d\u003e pre_constrained_event(trom, (ts.triggerevent)))))))","function postcondition satisfiable obligation:(forall trom:Trom \u0026 (exists event:[Event] \u0026 post_get_unconstrained_internal_event(trom, event)))","legal sequence application obligation:(forall se:SimulationEvent, se_list:seq of (SimulationEvent) \u0026 ((se in set (elems se_list)) \u003d\u003e (exists index:nat1 \u0026 (index in set (inds se_list)))))","function postcondition satisfiable obligation:(forall se:SimulationEvent, se_list:seq of (SimulationEvent) \u0026 (pre_get_simevent_index(se, se_list) \u003d\u003e (exists index:nat1 \u0026 post_get_simevent_index(se, se_list, index))))","function postcondition satisfiable obligation:(forall rw:ReactionWindow \u0026 (exists time:nat \u0026 post_get_random_time_within_rw(rw, time)))","function postcondition satisfiable obligation:(forall portlist:seq of (Port) \u0026 (pre_get_lru_port(portlist) \u003d\u003e (exists port:Port \u0026 post_get_lru_port(portlist, port))))","finite set obligation:(((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((SIMULATIONEVENTLIST \u003c\u003e []) \u003d\u003e ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) \u003d\u003e (exists finmap1:map (nat) to (Trom) \u0026 (forall trom:Trom \u0026 (exists_in_subsystem(trom, SUBSYSTEM) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d trom))))))))","legal function application obligation:(((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((SIMULATIONEVENTLIST \u003c\u003e []) \u003d\u003e ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) \u003d\u003e (forall trom:Trom \u0026 pre_exists_in_subsystem(trom, SUBSYSTEM)))))","legal function application obligation:(((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((SIMULATIONEVENTLIST \u003c\u003e []) \u003d\u003e ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) \u003d\u003e (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 pre_get_initial_state(trom)))))","operation call obligation:(((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (CLOCK \u003d 0)))","while loop termination obligation:...","while loop termination obligation:...","legal sequence application obligation:(((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST)))))","while loop termination obligation:...","legal sequence application obligation:(((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e ((i \u003c\u003d (len SIMULATIONEVENTLIST)) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST)))))))","legal sequence application obligation:(((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST))))))","operation call obligation:(((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e ((SIMULATIONEVENTLIST(i).occurtime) \u003d CLOCK)))))","state invariant holds obligation:(((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e ((CLOCK \u003d CLOCK~) \u003d\u003e let mk_System(subsystem, simulationeventlist, lsllibrary, clock) \u003d System in (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) and (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) and ((forall i, j in set (inds simulationeventlist) \u0026 (((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j))) or (((i \u003c j) and ((simulationeventlist(i).occurtime) \u003c\u003d (simulationeventlist(j).occurtime))) or ((i \u003e j) and ((simulationeventlist(i).occurtime) \u003e\u003d (simulationeventlist(j).occurtime)))))) and ((forall se1, se2 in set (elems simulationeventlist) \u0026 ((((se1.occurtime) \u003d (se2.occurtime)) and ((se1.tromlabel) \u003c\u003e (se2.tromlabel))) or ((se1.occurtime) \u003c\u003e (se2.occurtime)))) and (let accepted_by_trom: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_trom(se, subsys) \u003d\u003d\n(exists1 trom in set (subsys.troms) \u0026 (((trom.label) \u003d (se.tromlabel)) and (exists1 e in set (trom.events) \u0026 (((e.label) \u003d (se.eventlabel)) and (exists1 pt in set (trom.porttypes) \u0026 ((pt \u003d (e.porttype)) and (exists1 p in set (elems (pt.portlist)) \u0026 ((p.label) \u003d (se.portlabel))))))))) in let accepted_by_subsystem: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_subsystem(se, subsys) \u003d\u003d\n(exists1 s in set (subsys.includes) \u0026 (((accepted_by_trom(se, s) and (not accepted_by_subsystem(se, s))) or ((not accepted_by_trom(se, s)) and accepted_by_subsystem(se, s))) and (forall s2 in set {su | su:Subsystem \u0026 ((su in set (subsys.includes)) and (su \u003c\u003e s))} \u0026 ((not accepted_by_trom(se, s2)) and (not accepted_by_subsystem(se, s2)))))) in (forall se in set (elems simulationeventlist) \u0026 ((accepted_by_trom(se, subsystem) and (not accepted_by_subsystem(se, subsystem))) or ((not accepted_by_trom(se, subsystem)) and accepted_by_subsystem(se, subsystem)))) and let exists_lsltrait: (Subsystem +\u003e bool)\n\texists_lsltrait(subsys) \u003d\u003d\n((forall trom in set (subsys.troms) \u0026 (forall tr in set (trom.lsltraits) \u0026 (exists traitdef in set lsllibrary \u0026 ((traitdef.label) \u003d (tr.traitlabel))))) and (forall s in set (subsys.includes) \u0026 exists_lsltrait(s))) in exists_lsltrait(subsystem)))))))))))","legal sequence application obligation:(((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e ((CLOCK \u003d CLOCK~) \u003d\u003e ((SIMULATIONEVENTLIST \u003c\u003e []) \u003d\u003e ((len SIMULATIONEVENTLIST) in set (inds SIMULATIONEVENTLIST))))))))","finite set obligation:(((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e ((CLOCK \u003d CLOCK~) \u003d\u003e ((SIMULATIONEVENTLIST \u003c\u003e []) \u003d\u003e (((SIMULATIONEVENTLIST((len SIMULATIONEVENTLIST)).occurtime) \u003d CLOCK) \u003d\u003e ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003c\u003d CLOCK) and ((se.eventhistory) \u003c\u003e nil))) \u003d\u003e (exists finmap1:map (nat) to (Trom) \u0026 (forall trom:Trom \u0026 (exists_in_subsystem(trom, SUBSYSTEM) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d trom)))))))))))))","legal function application obligation:(((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e ((CLOCK \u003d CLOCK~) \u003d\u003e ((SIMULATIONEVENTLIST \u003c\u003e []) \u003d\u003e (((SIMULATIONEVENTLIST((len SIMULATIONEVENTLIST)).occurtime) \u003d CLOCK) \u003d\u003e ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003c\u003d CLOCK) and ((se.eventhistory) \u003c\u003e nil))) \u003d\u003e (forall trom:Trom \u0026 pre_exists_in_subsystem(trom, SUBSYSTEM))))))))))","operation establishes postcondition obligation:(((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e ((CLOCK \u003d CLOCK~) \u003d\u003e ((SIMULATIONEVENTLIST \u003c\u003e []) and (((SIMULATIONEVENTLIST((len SIMULATIONEVENTLIST)).occurtime) \u003d CLOCK) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003c\u003d CLOCK) and ((se.eventhistory) \u003c\u003e nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))))))))","state invariant holds obligation:(forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e let mk_System(subsystem, simulationeventlist, lsllibrary, clock) \u003d System in (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) and (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) and ((forall i, j in set (inds simulationeventlist) \u0026 (((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j))) or (((i \u003c j) and ((simulationeventlist(i).occurtime) \u003c\u003d (simulationeventlist(j).occurtime))) or ((i \u003e j) and ((simulationeventlist(i).occurtime) \u003e\u003d (simulationeventlist(j).occurtime)))))) and ((forall se1, se2 in set (elems simulationeventlist) \u0026 ((((se1.occurtime) \u003d (se2.occurtime)) and ((se1.tromlabel) \u003c\u003e (se2.tromlabel))) or ((se1.occurtime) \u003c\u003e (se2.occurtime)))) and (let accepted_by_trom: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_trom(se, subsys) \u003d\u003d\n(exists1 trom in set (subsys.troms) \u0026 (((trom.label) \u003d (se.tromlabel)) and (exists1 e in set (trom.events) \u0026 (((e.label) \u003d (se.eventlabel)) and (exists1 pt in set (trom.porttypes) \u0026 ((pt \u003d (e.porttype)) and (exists1 p in set (elems (pt.portlist)) \u0026 ((p.label) \u003d (se.portlabel))))))))) in let accepted_by_subsystem: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_subsystem(se, subsys) \u003d\u003d\n(exists1 s in set (subsys.includes) \u0026 (((accepted_by_trom(se, s) and (not accepted_by_subsystem(se, s))) or ((not accepted_by_trom(se, s)) and accepted_by_subsystem(se, s))) and (forall s2 in set {su | su:Subsystem \u0026 ((su in set (subsys.includes)) and (su \u003c\u003e s))} \u0026 ((not accepted_by_trom(se, s2)) and (not accepted_by_subsystem(se, s2)))))) in (forall se in set (elems simulationeventlist) \u0026 ((accepted_by_trom(se, subsystem) and (not accepted_by_subsystem(se, subsystem))) or ((not accepted_by_trom(se, subsystem)) and accepted_by_subsystem(se, subsystem)))) and let exists_lsltrait: (Subsystem +\u003e bool)\n\texists_lsltrait(subsys) \u003d\u003d\n((forall trom in set (subsys.troms) \u0026 (forall tr in set (trom.lsltraits) \u0026 (exists traitdef in set lsllibrary \u0026 ((traitdef.label) \u003d (tr.traitlabel))))) and (forall s in set (subsys.includes) \u0026 exists_lsltrait(s))) in exists_lsltrait(subsystem))))))))","state invariant holds obligation:(forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e let mk_System(subsystem, simulationeventlist, lsllibrary, clock) \u003d System in (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) and (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) and ((forall i, j in set (inds simulationeventlist) \u0026 (((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j))) or (((i \u003c j) and ((simulationeventlist(i).occurtime) \u003c\u003d (simulationeventlist(j).occurtime))) or ((i \u003e j) and ((simulationeventlist(i).occurtime) \u003e\u003d (simulationeventlist(j).occurtime)))))) and ((forall se1, se2 in set (elems simulationeventlist) \u0026 ((((se1.occurtime) \u003d (se2.occurtime)) and ((se1.tromlabel) \u003c\u003e (se2.tromlabel))) or ((se1.occurtime) \u003c\u003e (se2.occurtime)))) and (let accepted_by_trom: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_trom(se, subsys) \u003d\u003d\n(exists1 trom in set (subsys.troms) \u0026 (((trom.label) \u003d (se.tromlabel)) and (exists1 e in set (trom.events) \u0026 (((e.label) \u003d (se.eventlabel)) and (exists1 pt in set (trom.porttypes) \u0026 ((pt \u003d (e.porttype)) and (exists1 p in set (elems (pt.portlist)) \u0026 ((p.label) \u003d (se.portlabel))))))))) in let accepted_by_subsystem: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_subsystem(se, subsys) \u003d\u003d\n(exists1 s in set (subsys.includes) \u0026 (((accepted_by_trom(se, s) and (not accepted_by_subsystem(se, s))) or ((not accepted_by_trom(se, s)) and accepted_by_subsystem(se, s))) and (forall s2 in set {su | su:Subsystem \u0026 ((su in set (subsys.includes)) and (su \u003c\u003e s))} \u0026 ((not accepted_by_trom(se, s2)) and (not accepted_by_subsystem(se, s2)))))) in (forall se in set (elems simulationeventlist) \u0026 ((accepted_by_trom(se, subsystem) and (not accepted_by_subsystem(se, subsystem))) or ((not accepted_by_trom(se, subsystem)) and accepted_by_subsystem(se, subsystem)))) and let exists_lsltrait: (Subsystem +\u003e bool)\n\texists_lsltrait(subsys) \u003d\u003d\n((forall trom in set (subsys.troms) \u0026 (forall tr in set (trom.lsltraits) \u0026 (exists traitdef in set lsllibrary \u0026 ((traitdef.label) \u003d (tr.traitlabel))))) and (forall s in set (subsys.includes) \u0026 exists_lsltrait(s))) in exists_lsltrait(subsystem))))))))","legal function application obligation:(forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e pre_get_transition_spec(trom, se)))","type compatibility obligation:(forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (inv_Trom(trom) and is_(trom, Trom))))","operation call obligation:(forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((get_trom_object((se.tromlabel), SUBSYSTEM) \u003d nil) or ((get_trom_object((se.tromlabel), SUBSYSTEM).postcondition) \u003d false))))","operation call obligation:(forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e (get_trom_object((se.tromlabel), SUBSYSTEM) \u003c\u003e nil))))","operation call obligation:(forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) \u003d\u003e ((get_trom_object((se.tromlabel), SUBSYSTEM) \u003d nil) or ((get_trom_object((se.tromlabel), SUBSYSTEM).postcondition) \u003d false))))))","operation call obligation:(forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((get_trom_object((se.tromlabel), SUBSYSTEM).postcondition) \u003d true))))))","operation call obligation:(forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d true) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).currentstate)) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((get_trom_object((se.tromlabel), SUBSYSTEM).postcondition) \u003d true)))))))","operation call obligation:(forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d true) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).currentstate)) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((((get_trom_object((se.tromlabel), SUBSYSTEM).destinstate).type) \u003d \u003cSIMPLE\u003e) and ((get_trom_object((se.tromlabel), SUBSYSTEM).currentstate) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).destinstate))) or ((((get_trom_object((se.tromlabel), SUBSYSTEM).destinstate).type) \u003d \u003cCOMPLEX\u003e) and ((get_trom_object((se.tromlabel), SUBSYSTEM).currentstate) \u003d get_entry_state((ts.destinstate))))) \u003d\u003e ((get_trom_object((se.tromlabel), SUBSYSTEM).occurtime) \u003d CLOCK))))))))","operation call obligation:(forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d true) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).currentstate)) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((((get_trom_object((se.tromlabel), SUBSYSTEM).destinstate).type) \u003d \u003cSIMPLE\u003e) and ((get_trom_object((se.tromlabel), SUBSYSTEM).currentstate) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).destinstate))) or ((((get_trom_object((se.tromlabel), SUBSYSTEM).destinstate).type) \u003d \u003cCOMPLEX\u003e) and ((get_trom_object((se.tromlabel), SUBSYSTEM).currentstate) \u003d get_entry_state((ts.destinstate))))) \u003d\u003e ((CLOCK \u003d CLOCK~) \u003d\u003e ((get_trom_object((se.tromlabel), SUBSYSTEM) in set (elems SIMULATIONEVENTLIST)) and ((get_trom_object((se.tromlabel), SUBSYSTEM).tromlabel) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).label)))))))))))","operation establishes postcondition obligation:(forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d true) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).currentstate)) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((((get_trom_object((se.tromlabel), SUBSYSTEM).destinstate).type) \u003d \u003cSIMPLE\u003e) and ((get_trom_object((se.tromlabel), SUBSYSTEM).currentstate) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).destinstate))) or ((((get_trom_object((se.tromlabel), SUBSYSTEM).destinstate).type) \u003d \u003cCOMPLEX\u003e) and ((get_trom_object((se.tromlabel), SUBSYSTEM).currentstate) \u003d get_entry_state((ts.destinstate))))) \u003d\u003e ((CLOCK \u003d CLOCK~) \u003d\u003e (let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let j:nat1 be st (j \u003d get_simevent_index(se, SIMULATIONEVENTLIST)) in let se2:SimulationEvent be st (se2 \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in (SIMULATIONEVENTLIST \u003d (([SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (i \u003c\u003d j)] ^ [se2]) ^ [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (i \u003e j)]))) or (event \u003d nil)) \u003d\u003e (CLOCK \u003d CLOCK~))))))))))","operation call obligation:(forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((((trom.constrainedevent).label) \u003d (trom.eventlabel)) and ((trom in set (trom.reactionwindows)) and (((trom.occurtime) \u003e\u003d (trom.lowertimebound)) and ((trom.occurtime) \u003c\u003d (trom.uppertimebound)))))))","operation call obligation:(forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cFIRED\u003e)))) \u003d\u003e ((((trom.constrainedevent).label) \u003d (trom.eventlabel)) and ((trom in set (trom.reactionwindows)) and (((trom.occurtime) \u003e\u003d (trom.lowertimebound)) and ((trom.occurtime) \u003c\u003d (trom.uppertimebound))))))))","operation call obligation:(forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cFIRED\u003e)))) \u003d\u003e ((trom not in set (trom.reactionwindows)) \u003d\u003e (((trom.currentstate) in set (trom.disablingstates)) and (trom in set (trom.reactionwindows)))))))","operation call obligation:(forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cFIRED\u003e)))) \u003d\u003e ((trom not in set (trom.reactionwindows)) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cDISABLED\u003e)))) \u003d\u003e (((trom.currentstate) in set (trom.disablingstates)) and (trom in set (trom.reactionwindows))))))))","operation call obligation:(forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cFIRED\u003e)))) \u003d\u003e ((trom not in set (trom.reactionwindows)) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cDISABLED\u003e)))) \u003d\u003e (((trom not in set (trom.reactionwindows)) and let se2:SimulationEvent be st (se2 \u003d get_enabled_simevent(trom, tc)) in (((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)])) or ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) and let tromporttuple:[TromPortTuple] be st (tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) in let se3:SimulationEvent be st (se3 \u003d get_enabled_simevent_synch(tromporttuple, tc)) in (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 ((SIMULATIONEVENTLIST~(i) \u003c\u003e se2) and (SIMULATIONEVENTLIST~(i) \u003c\u003e se3))])))) \u003d\u003e ((trom.label) \u003d ((trom.transition).label))))))))","operation call obligation:(forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cFIRED\u003e)))) \u003d\u003e ((trom not in set (trom.reactionwindows)) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cDISABLED\u003e)))) \u003d\u003e (((trom not in set (trom.reactionwindows)) and let se2:SimulationEvent be st (se2 \u003d get_enabled_simevent(trom, tc)) in (((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)])) or ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) and let tromporttuple:[TromPortTuple] be st (tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) in let se3:SimulationEvent be st (se3 \u003d get_enabled_simevent_synch(tromporttuple, tc)) in (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 ((SIMULATIONEVENTLIST~(i) \u003c\u003e se2) and (SIMULATIONEVENTLIST~(i) \u003c\u003e se3))])))) \u003d\u003e (let rw:ReactionWindow be st (rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) in (exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d tc) and (((rh.reactionwindow) \u003d rw) and ((rh.reaction) \u003d \u003cENABLED\u003e)))) \u003d\u003e ((trom.label) \u003d ((trom.transition).label)))))))))","operation establishes postcondition obligation:(forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cFIRED\u003e)))) \u003d\u003e ((trom not in set (trom.reactionwindows)) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cDISABLED\u003e)))) \u003d\u003e (((trom not in set (trom.reactionwindows)) and let se2:SimulationEvent be st (se2 \u003d get_enabled_simevent(trom, tc)) in (((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)])) or ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) and let tromporttuple:[TromPortTuple] be st (tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) in let se3:SimulationEvent be st (se3 \u003d get_enabled_simevent_synch(tromporttuple, tc)) in (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 ((SIMULATIONEVENTLIST~(i) \u003c\u003e se2) and (SIMULATIONEVENTLIST~(i) \u003c\u003e se3))])))) \u003d\u003e (let rw:ReactionWindow be st (rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) in (exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d tc) and (((rh.reactionwindow) \u003d rw) and ((rh.reaction) \u003d \u003cENABLED\u003e)))) \u003d\u003e (let rw:ReactionWindow be st (rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) in let port:Port be st (port \u003d get_lru_port((((tc.constrainedevent).porttype).portlist))) in let occurtime:nat be st (occurtime \u003d get_random_time_within_rw(rw)) in let se2:SimulationEvent be st (se2 \u003d mk_SimulationEvent(((tc.constrainedevent).label), (trom.label), (port.label), occurtime, nil)) in ((rw in set (tc.reactionwindows)) and ((se2 in set (elems SIMULATIONEVENTLIST)) and (((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) and let tromporttuple:[TromPortTuple] be st (tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) in (((tromporttuple \u003c\u003e nil) and let se3:SimulationEvent be st (se3 \u003d mk_SimulationEvent((se2.eventlabel), (tromporttuple.tromlabel), (tromporttuple.portlabel), (se2.occurtime), nil)) in (se3 in set (elems SIMULATIONEVENTLIST))) or (tromporttuple \u003d nil))) or (((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e)))) \u003d\u003e (CLOCK \u003d CLOCK~)))))))))","legal function application obligation:(((ts.postcondition) \u003d true) \u003d\u003e ((not ((((ts.destinstate).type) \u003d \u003cSIMPLE\u003e) and ((trom.currentstate) \u003d (ts.destinstate)))) \u003d\u003e ((((ts.destinstate).type) \u003d \u003cCOMPLEX\u003e) \u003d\u003e pre_get_entry_state((ts.destinstate)))))","operation postcondition satisfiable obligation:(forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (pre_update_trom_current_state(trom, se, ts, oldstate) \u003d\u003e (exists newstate:System \u0026 post_update_trom_current_state(trom, se, ts, oldstate, newstate))))","operation postcondition satisfiable obligation:(forall trom:Trom, se:SimulationEvent, ts:[TransitionSpec], oldstate:System \u0026 (pre_update_history_assignment_vector(trom, se, ts, oldstate) \u003d\u003e (exists newstate:System \u0026 post_update_history_assignment_vector(trom, se, ts, oldstate, newstate))))","operation postcondition satisfiable obligation:(forall trom:Trom, se:SimulationEvent, ts:[TransitionSpec], oldstate:System \u0026 (pre_update_history_notransition(trom, se, ts, oldstate) \u003d\u003e (exists newstate:System \u0026 post_update_history_notransition(trom, se, ts, oldstate, newstate))))","operation postcondition satisfiable obligation:(forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (pre_update_history_transition(trom, se, ts, oldstate) \u003d\u003e (exists newstate:System \u0026 post_update_history_transition(trom, se, ts, oldstate, newstate))))","operation postcondition satisfiable obligation:(forall trom:Trom, se:SimulationEvent, tc:TimeConstraint, rw:ReactionWindow, oldstate:System \u0026 (pre_update_history_fire_reaction(trom, se, tc, rw, oldstate) \u003d\u003e (exists newstate:System \u0026 post_update_history_fire_reaction(trom, se, tc, rw, oldstate, newstate))))","operation postcondition satisfiable obligation:(forall trom:Trom, se:SimulationEvent, tc:TimeConstraint, rw:ReactionWindow, oldstate:System \u0026 (pre_update_history_disable_reaction(trom, se, tc, rw, oldstate) \u003d\u003e (exists newstate:System \u0026 post_update_history_disable_reaction(trom, se, tc, rw, oldstate, newstate))))","let be st existence obligation:(((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (exists rw:ReactionWindow \u0026 (rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK)))))","type compatibility obligation:(((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 inv_ReactionWindow(mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK)))))","operation postcondition satisfiable obligation:(forall trom:Trom, se:SimulationEvent, tc:TimeConstraint, ts:TransitionSpec, oldstate:System \u0026 (pre_update_history_enable_reaction(trom, se, tc, ts, oldstate) \u003d\u003e (exists newstate:System \u0026 post_update_history_enable_reaction(trom, se, tc, ts, oldstate, newstate))))","operation postcondition satisfiable obligation:(forall trom:Trom, se:SimulationEvent, tc:TimeConstraint, rw:ReactionWindow, oldstate:System \u0026 (pre_fire_reaction(trom, se, tc, rw, oldstate) \u003d\u003e (exists newstate:System \u0026 post_fire_reaction(trom, se, tc, rw, oldstate, newstate))))","let be st existence obligation:((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (exists se2:SimulationEvent \u0026 (se2 \u003d get_enabled_simevent(trom, tc)))))","legal sequence application obligation:((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d get_enabled_simevent(trom, tc)) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) \u003d\u003e (forall i in set (inds SIMULATIONEVENTLIST~) \u0026 ((SIMULATIONEVENTLIST~(i) \u003c\u003e se2) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST~)))))))))","legal sequence application obligation:((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d get_enabled_simevent(trom, tc)) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) \u003d\u003e (forall i in set (inds SIMULATIONEVENTLIST~) \u0026 (i in set (inds SIMULATIONEVENTLIST~))))))))","let be st existence obligation:((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d get_enabled_simevent(trom, tc)) \u003d\u003e ((not ((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)]))) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) \u003d\u003e (exists tromporttuple:[TromPortTuple] \u0026 (tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)))))))))","let be st existence obligation:((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d get_enabled_simevent(trom, tc)) \u003d\u003e ((not ((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)]))) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) \u003d\u003e (forall tromporttuple:[TromPortTuple] \u0026 ((tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) \u003d\u003e (exists se3:SimulationEvent \u0026 (se3 \u003d get_enabled_simevent_synch(tromporttuple, tc)))))))))))","legal sequence application obligation:((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d get_enabled_simevent(trom, tc)) \u003d\u003e ((not ((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)]))) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) \u003d\u003e (forall tromporttuple:[TromPortTuple] \u0026 ((tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) \u003d\u003e (forall se3:SimulationEvent \u0026 ((se3 \u003d get_enabled_simevent_synch(tromporttuple, tc)) \u003d\u003e (forall i in set (inds SIMULATIONEVENTLIST~) \u0026 (((SIMULATIONEVENTLIST~(i) \u003c\u003e se2) and (SIMULATIONEVENTLIST~(i) \u003c\u003e se3)) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST~))))))))))))))","legal sequence application obligation:((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d get_enabled_simevent(trom, tc)) \u003d\u003e ((not ((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)]))) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) \u003d\u003e (forall tromporttuple:[TromPortTuple] \u0026 ((tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) \u003d\u003e (forall se3:SimulationEvent \u0026 ((se3 \u003d get_enabled_simevent_synch(tromporttuple, tc)) \u003d\u003e (forall i in set (inds SIMULATIONEVENTLIST~) \u0026 (i in set (inds SIMULATIONEVENTLIST~)))))))))))))","legal sequence application obligation:((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d get_enabled_simevent(trom, tc)) \u003d\u003e ((not ((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)]))) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) \u003d\u003e (forall tromporttuple:[TromPortTuple] \u0026 ((tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) \u003d\u003e (forall se3:SimulationEvent \u0026 ((se3 \u003d get_enabled_simevent_synch(tromporttuple, tc)) \u003d\u003e (forall i in set (inds SIMULATIONEVENTLIST~) \u0026 ((SIMULATIONEVENTLIST~(i) \u003c\u003e se2) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST~))))))))))))))","operation postcondition satisfiable obligation:(forall trom:Trom, se:SimulationEvent, tc:TimeConstraint, rw:ReactionWindow, oldstate:System \u0026 (pre_disable_reaction(trom, se, tc, rw, oldstate) \u003d\u003e (exists newstate:System \u0026 post_disable_reaction(trom, se, tc, rw, oldstate, newstate))))","let be st existence obligation:(((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (exists rw:ReactionWindow \u0026 (rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK)))))","type compatibility obligation:(((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 inv_ReactionWindow(mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK)))))","let be st existence obligation:(((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 ((rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) \u003d\u003e (exists port:Port \u0026 (port \u003d get_lru_port((((tc.constrainedevent).porttype).portlist)))))))","legal function application obligation:(((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 ((rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) \u003d\u003e (forall port:Port \u0026 pre_get_lru_port((((tc.constrainedevent).porttype).portlist))))))","let be st existence obligation:(((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 ((rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) \u003d\u003e (forall port:Port \u0026 ((port \u003d get_lru_port((((tc.constrainedevent).porttype).portlist))) \u003d\u003e (exists occurtime:nat \u0026 (occurtime \u003d get_random_time_within_rw(rw))))))))","let be st existence obligation:(((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 ((rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) \u003d\u003e (forall port:Port \u0026 ((port \u003d get_lru_port((((tc.constrainedevent).porttype).portlist))) \u003d\u003e (forall occurtime:nat \u0026 ((occurtime \u003d get_random_time_within_rw(rw)) \u003d\u003e (exists se2:SimulationEvent \u0026 (se2 \u003d mk_SimulationEvent(((tc.constrainedevent).label), (trom.label), (port.label), occurtime, nil))))))))))","let be st existence obligation:(((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 ((rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) \u003d\u003e (forall port:Port \u0026 ((port \u003d get_lru_port((((tc.constrainedevent).porttype).portlist))) \u003d\u003e (forall occurtime:nat \u0026 ((occurtime \u003d get_random_time_within_rw(rw)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d mk_SimulationEvent(((tc.constrainedevent).label), (trom.label), (port.label), occurtime, nil)) \u003d\u003e ((rw in set (tc.reactionwindows)) \u003d\u003e ((se2 in set (elems SIMULATIONEVENTLIST)) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) \u003d\u003e (exists tromporttuple:[TromPortTuple] \u0026 (tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)))))))))))))))","let be st existence obligation:(((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 ((rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) \u003d\u003e (forall port:Port \u0026 ((port \u003d get_lru_port((((tc.constrainedevent).porttype).portlist))) \u003d\u003e (forall occurtime:nat \u0026 ((occurtime \u003d get_random_time_within_rw(rw)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d mk_SimulationEvent(((tc.constrainedevent).label), (trom.label), (port.label), occurtime, nil)) \u003d\u003e ((rw in set (tc.reactionwindows)) \u003d\u003e ((se2 in set (elems SIMULATIONEVENTLIST)) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) \u003d\u003e (forall tromporttuple:[TromPortTuple] \u0026 ((tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) \u003d\u003e ((tromporttuple \u003c\u003e nil) \u003d\u003e (exists se3:SimulationEvent \u0026 (se3 \u003d mk_SimulationEvent((se2.eventlabel), (tromporttuple.tromlabel), (tromporttuple.portlabel), (se2.occurtime), nil))))))))))))))))))","operation postcondition satisfiable obligation:(forall trom:Trom, se:SimulationEvent, tc:TimeConstraint, ts:TransitionSpec, oldstate:System \u0026 (pre_enable_reaction(trom, se, tc, ts, oldstate) \u003d\u003e (exists newstate:System \u0026 post_enable_reaction(trom, se, tc, ts, oldstate, newstate))))","operation postcondition satisfiable obligation:(forall trom:Trom, tc:TimeConstraint, oldstate:System \u0026 (pre_get_enabled_simevent(trom, tc, oldstate) \u003d\u003e (exists se:SimulationEvent \u0026 post_get_enabled_simevent(trom, tc, oldstate, se, oldstate, newstate))))","operation postcondition satisfiable obligation:(forall tromporttuple:TromPortTuple, tc:TimeConstraint, oldstate:System \u0026 (exists se:SimulationEvent \u0026 post_get_enabled_simevent_synch(tromporttuple, tc, oldstate, se, oldstate, newstate)))","finite set obligation:((CLOCK \u003d 0) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (exists finmap1:map (nat) to (Trom) \u0026 (forall trom:Trom \u0026 (exists_in_subsystem(trom, SUBSYSTEM) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d trom)))))))","legal function application obligation:((CLOCK \u003d 0) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (forall trom:Trom \u0026 pre_exists_in_subsystem(trom, SUBSYSTEM))))","let be st existence obligation:((CLOCK \u003d 0) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (exists se:SimulationEvent \u0026 (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)))))))","let be st existence obligation:((CLOCK \u003d 0) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall se:SimulationEvent \u0026 ((se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) \u003d\u003e ((se in set (elems SIMULATIONEVENTLIST)) \u003d\u003e (exists i:nat1 \u0026 (SIMULATIONEVENTLIST(i) \u003d se)))))))))","legal sequence application obligation:((CLOCK \u003d 0) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall se:SimulationEvent \u0026 ((se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) \u003d\u003e ((se in set (elems SIMULATIONEVENTLIST)) \u003d\u003e (forall i:nat1 \u0026 (i in set (inds SIMULATIONEVENTLIST))))))))))","let be st existence obligation:((CLOCK \u003d 0) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall se:SimulationEvent \u0026 ((se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) \u003d\u003e ((se in set (elems SIMULATIONEVENTLIST)) \u003d\u003e (forall i:nat1 \u0026 ((SIMULATIONEVENTLIST(i) \u003d se) \u003d\u003e (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 (exists j:nat1 \u0026 (SIMULATIONEVENTLIST(j) \u003d se2))))))))))))","legal sequence application obligation:((CLOCK \u003d 0) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall se:SimulationEvent \u0026 ((se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) \u003d\u003e ((se in set (elems SIMULATIONEVENTLIST)) \u003d\u003e (forall i:nat1 \u0026 ((SIMULATIONEVENTLIST(i) \u003d se) \u003d\u003e (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 (forall j:nat1 \u0026 (j in set (inds SIMULATIONEVENTLIST)))))))))))))","operation postcondition satisfiable obligation:(pre_schedule_unconstrained_internal_events_from_initial_state(oldstate) \u003d\u003e (exists newstate:System \u0026 post_schedule_unconstrained_internal_events_from_initial_state(oldstate, newstate)))","let be st existence obligation:(((se in set (elems SIMULATIONEVENTLIST)) and ((se.tromlabel) \u003d (trom.label))) \u003d\u003e let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (exists j:nat1 \u0026 (j \u003d get_simevent_index(se, SIMULATIONEVENTLIST)))))","legal function application obligation:(((se in set (elems SIMULATIONEVENTLIST)) and ((se.tromlabel) \u003d (trom.label))) \u003d\u003e let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall j:nat1 \u0026 pre_get_simevent_index(se, SIMULATIONEVENTLIST))))","let be st existence obligation:(((se in set (elems SIMULATIONEVENTLIST)) and ((se.tromlabel) \u003d (trom.label))) \u003d\u003e let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall j:nat1 \u0026 ((j \u003d get_simevent_index(se, SIMULATIONEVENTLIST)) \u003d\u003e (exists se2:SimulationEvent \u0026 (se2 \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)))))))","legal sequence application obligation:(((se in set (elems SIMULATIONEVENTLIST)) and ((se.tromlabel) \u003d (trom.label))) \u003d\u003e let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall j:nat1 \u0026 ((j \u003d get_simevent_index(se, SIMULATIONEVENTLIST)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) \u003d\u003e (forall i in set (inds SIMULATIONEVENTLIST~) \u0026 ((i \u003c\u003d j) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST~))))))))))","legal sequence application obligation:(((se in set (elems SIMULATIONEVENTLIST)) and ((se.tromlabel) \u003d (trom.label))) \u003d\u003e let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall j:nat1 \u0026 ((j \u003d get_simevent_index(se, SIMULATIONEVENTLIST)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) \u003d\u003e (forall i in set (inds SIMULATIONEVENTLIST~) \u0026 ((i \u003e j) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST~))))))))))","operation postcondition satisfiable obligation:(forall trom:Trom, se:SimulationEvent, oldstate:System \u0026 (pre_schedule_unconstrained_internal_event(trom, se, oldstate) \u003d\u003e (exists newstate:System \u0026 post_schedule_unconstrained_internal_event(trom, se, oldstate, newstate))))","operation postcondition satisfiable obligation:(exists newstate:System \u0026 post_initialize_simulation_clock(oldstate, newstate))","operation postcondition satisfiable obligation:(exists newstate:System \u0026 post_update_simulation_clock(oldstate, newstate))"]